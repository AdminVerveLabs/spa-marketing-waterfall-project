{
  "Analyze Website HTML": "// runOnceForAllItems — index-paired with Has Website?\nconst upstreamAll = $('Has Website?').all();\nconst inputAll = $input.all();\nconst results = [];\n\n// === HOISTED CONSTANTS ===\nconst bookingSignatures = {\n  'jane_app': ['jane.app', 'janeapp.com'],\n  'acuity': ['acuityscheduling.com', 'squareup.com/appointments', 'app.acuityscheduling.com'],\n  'mindbody': ['mindbodyonline.com', 'clients.mindbodyonline.com', 'mindbody.io', 'healcode.com'],\n  'square': ['square.site', 'squareup.com'],\n  'vagaro': ['vagaro.com'],\n  'fresha': ['fresha.com', 'shedul.com'],\n  'schedulicity': ['schedulicity.com'],\n  'schedulista': ['schedulista.com'],\n  'booksy': ['booksy.com'],\n  'massagebook': ['massagebook.com'],\n  'genbook': ['genbook.com'],\n  'noterro': ['noterro.com'],\n  'clinicsense': ['clinicsense.com'],\n  'wix_bookings': ['wix.com/booking', 'bookings.wixapps.net'],\n  'calendly': ['calendly.com']\n};\n\nconst junkEmailDomains = [\n  'sentry.io', 'schema.org', 'w3.org', 'wordpress.com', 'wordpress.org',\n  'squarespace.com', 'wix.com', 'gravatar.com', 'facebook.com', 'twitter.com',\n  'instagram.com', 'youtube.com', 'linkedin.com', 'pinterest.com', 'tiktok.com',\n  'cloudflare.com', 'googleapis.com', 'googletagmanager.com', 'google-analytics.com',\n  'gstatic.com', 'jsdelivr.net', 'cdnjs.cloudflare.com', 'unpkg.com',\n  'bootstrapcdn.com', 'fontawesome.com', 'typekit.net', 'fonts.googleapis.com',\n  'example.com', 'example.org', 'test.com', 'localhost',\n  'mailinator.com', 'guerrillamail.com', 'tempmail.com', 'yopmail.com'\n];\n\nconst junkLocalPatterns = [\n  /^noreply$/i, /^no-reply$/i, /^donotreply$/i, /^do-not-reply$/i,\n  /^postmaster$/i, /^mailer-daemon$/i, /^webmaster$/i, /^root$/i,\n  /^null$/i, /^test$/i, /^admin$/i, /^abuse$/i\n];\n\nconst roleBasedPrefixes = ['info', 'contact', 'hello', 'office', 'reception',\n  'frontdesk', 'front.desk', 'appointments', 'booking', 'bookings',\n  'schedule', 'scheduling', 'inquiries', 'inquiry', 'general', 'team', 'staff',\n  'support', 'sales', 'billing'];\n\nconst adSignatures = [\n  'googleadservices.com', 'googlesyndication.com', 'googleads.g.doubleclick.net',\n  'google_conversion', 'conversion_async', 'ads/ga-audiences',\n  'fbevents.js', 'fbq(', 'snap.licdn.com', 'linkedin.com/insight',\n  'analytics.tiktok.com', 'tiktok.com/i18n/pixel', 'ads-twitter.com', 'static.ads-twitter.com'\n];\n\nconst socialPatterns = {\n  facebook: /https?:\\/\\/(?:www\\.)?facebook\\.com\\/[a-zA-Z0-9._-]+/gi,\n  instagram: /https?:\\/\\/(?:www\\.)?instagram\\.com\\/[a-zA-Z0-9._-]+/gi,\n  tiktok: /https?:\\/\\/(?:www\\.)?tiktok\\.com\\/@[a-zA-Z0-9._-]+/gi,\n  linkedin: /https?:\\/\\/(?:www\\.)?linkedin\\.com\\/(?:company|in)\\/[a-zA-Z0-9._-]+/gi,\n  x: /https?:\\/\\/(?:www\\.)?(?:twitter\\.com|x\\.com)\\/[a-zA-Z0-9._-]+/gi,\n  youtube: /https?:\\/\\/(?:www\\.)?youtube\\.com\\/(?:c\\/|channel\\/|@)[a-zA-Z0-9._-]+/gi\n};\n\nconst teamPatterns = [\n  /our\\s+team/i, /meet\\s+(?:the\\s+)?team/i, /our\\s+(?:therapists|practitioners|staff|massage\\s+therapists)/i,\n  /meet\\s+(?:our|the)\\s+(?:therapists|practitioners|staff)/i\n];\n\nconst emailRegex = /[a-zA-Z0-9._%+\\-]+@[a-zA-Z0-9.\\-]+\\.[a-zA-Z]{2,}/g;\nconst mailtoRegex = /mailto:([a-zA-Z0-9._%+\\-]+@[a-zA-Z0-9.\\-]+\\.[a-zA-Z]{2,})/gi;\n\nconst bookingPatterns = ['book now', 'book online', 'book appointment', 'schedule now', 'schedule online', 'book a massage', 'online booking'];\n\nconst soloSignals = ['sole proprietor', 'solo practice', 'independent massage',\n  'i am a licensed', \"i'm a licensed\", 'about me', 'my practice', 'my approach',\n  'my services', 'i specialize', 'i provide'];\n\nfor (let i = 0; i < inputAll.length; i++) {\n  const company = upstreamAll[i].json;\n  const response = inputAll[i].json;\n  const domain = (company.domain || '').toLowerCase();\n\n  // === DOMAIN-BASED BOOKING DETECTION (runs even if fetch fails) ===\n  let booking_platform = null;\n  let has_online_booking = false;\n\n  // Check domain first\n  for (const [platform, signatures] of Object.entries(bookingSignatures)) {\n    for (const sig of signatures) {\n      if (domain.includes(sig)) {\n        booking_platform = platform;\n        has_online_booking = true;\n        break;\n      }\n    }\n    if (has_online_booking) break;\n  }\n\n  // Handle fetch errors\n  if (response.error || (!response.body && !response.data)) {\n    results.push({\n      json: {\n        ...company,\n        _website_enrichment: {\n          has_online_booking,\n          booking_platform,\n          has_paid_ads: false,\n          estimated_size: null,\n          social_links_found: [],\n          emails_found: [],\n          best_email: null,\n          _website_fetch_status: 'error',\n          _website_error: response.error || 'Empty response'\n        }\n      }\n    });\n    continue;\n  }\n\n  const rawHtml = response.body || response.data || '';\n  const html = (typeof rawHtml === 'string' ? rawHtml : '').toLowerCase();\n  const htmlOriginal = typeof rawHtml === 'string' ? rawHtml : '';\n\n  // === EMAIL EXTRACTION ===\n  const allEmailMatches = htmlOriginal.match(emailRegex) || [];\n\n  // Also extract from mailto: links (higher confidence)\n  // Reset regex lastIndex since we reuse it across loop iterations\n  mailtoRegex.lastIndex = 0;\n  const mailtoEmails = new Set();\n  let mailtoMatch;\n  while ((mailtoMatch = mailtoRegex.exec(htmlOriginal)) !== null) {\n    mailtoEmails.add(mailtoMatch[1].toLowerCase());\n  }\n\n  // Deduplicate and filter\n  const uniqueEmails = [...new Set(allEmailMatches.map(e => e.toLowerCase()))];\n  const scoredEmails = [];\n\n  for (const email of uniqueEmails) {\n    const [localPart, emailDomain] = email.split('@');\n    if (!emailDomain) continue;\n\n    // Filter out junk domains\n    if (junkEmailDomains.some(d => emailDomain.includes(d))) continue;\n\n    // Filter out junk local parts\n    if (junkLocalPatterns.some(p => p.test(localPart))) continue;\n\n    // Filter out numeric-only local parts\n    if (/^\\d+$/.test(localPart)) continue;\n\n    // Score the email\n    let score = 0;\n    if (domain && emailDomain.includes(domain.replace('www.', ''))) score += 20;\n    if (mailtoEmails.has(email)) score += 10;\n    if (roleBasedPrefixes.some(p => localPart === p || localPart.startsWith(p + '.'))) score += 5;\n\n    scoredEmails.push({ email, score, from_mailto: mailtoEmails.has(email) });\n  }\n\n  // Sort by score descending\n  scoredEmails.sort((a, b) => b.score - a.score);\n  const best_email = scoredEmails.length > 0 ? scoredEmails[0].email : null;\n\n  // === HTML-BASED BOOKING DETECTION ===\n  if (!has_online_booking) {\n    for (const [platform, signatures] of Object.entries(bookingSignatures)) {\n      for (const sig of signatures) {\n        if (html.includes(sig)) {\n          booking_platform = platform;\n          has_online_booking = true;\n          break;\n        }\n      }\n      if (has_online_booking) break;\n    }\n  }\n\n  if (!has_online_booking) {\n    for (const pattern of bookingPatterns) {\n      if (html.includes(pattern)) {\n        has_online_booking = true;\n        booking_platform = 'unknown';\n        break;\n      }\n    }\n  }\n\n  // === PAID ADS DETECTION ===\n  let has_paid_ads = false;\n  for (const sig of adSignatures) {\n    if (html.includes(sig)) {\n      has_paid_ads = true;\n      break;\n    }\n  }\n\n  // === SOCIAL LINKS EXTRACTION ===\n  const social_links_found = [];\n  const seenPlatforms = new Set();\n\n  for (const [platform, regex] of Object.entries(socialPatterns)) {\n    // Reset regex lastIndex since we reuse across loop iterations\n    regex.lastIndex = 0;\n    const matches = htmlOriginal.match(regex) || [];\n    for (const url of matches) {\n      const lowerUrl = url.toLowerCase();\n      if (lowerUrl.includes('/sharer') || lowerUrl.includes('/share') ||\n          lowerUrl.includes('/intent') || lowerUrl.includes('/login') ||\n          lowerUrl.includes('/help') || lowerUrl.includes('/about') ||\n          lowerUrl.includes('/policies') || lowerUrl.includes('/privacy')) {\n        continue;\n      }\n      if (!seenPlatforms.has(platform)) {\n        social_links_found.push({ platform, url: url.replace(/\\/+$/, '') });\n        seenPlatforms.add(platform);\n      }\n    }\n  }\n\n  // === TEAM SIZE ESTIMATION ===\n  let estimated_size = null;\n\n  let hasTeamPage = false;\n  for (const p of teamPatterns) {\n    if (p.test(htmlOriginal)) {\n      hasTeamPage = true;\n      break;\n    }\n  }\n\n  if (hasTeamPage) {\n    const namePatterns = htmlOriginal.match(/<h[2-4][^>]*>[^<]{2,40}<\\/h[2-4]>/gi) || [];\n    const staffLinks = htmlOriginal.match(/\\/(?:team|staff|therapist|practitioner)s?\\/[a-z-]+/gi) || [];\n    const memberCount = Math.max(namePatterns.length, staffLinks.length);\n    if (memberCount <= 1) estimated_size = 'solo';\n    else if (memberCount <= 5) estimated_size = 'small';\n    else estimated_size = 'medium';\n  } else {\n    const isSolo = soloSignals.some(s => html.includes(s));\n    if (isSolo) estimated_size = 'solo';\n  }\n\n  results.push({\n    json: {\n      ...company,\n      _website_enrichment: {\n        has_online_booking,\n        booking_platform,\n        has_paid_ads,\n        estimated_size,\n        social_links_found,\n        emails_found: scoredEmails.slice(0, 5),\n        best_email,\n        _website_fetch_status: 'success'\n      }\n    }\n  });\n}\n\nreturn results;",

  "Parse Google Details": "// runOnceForAllItems — index-paired with Has Google Place ID?\nconst upstreamAll = $('Has Google Place ID?').all();\nconst inputAll = $input.all();\nconst results = [];\n\nfor (let i = 0; i < inputAll.length; i++) {\n  const company = upstreamAll[i].json;\n  const details = inputAll[i].json;\n\n  // Extract incremental data from Google Places Details\n  let opening_hours = null;\n  let business_status = null;\n  let photo_count = 0;\n  let price_level = null;\n  let additional_types = [];\n\n  if (details && !details.error) {\n    if (details.regularOpeningHours && details.regularOpeningHours.periods) {\n      opening_hours = details.regularOpeningHours;\n    } else if (details.currentOpeningHours && details.currentOpeningHours.periods) {\n      opening_hours = details.currentOpeningHours;\n    }\n    business_status = details.businessStatus || null;\n    if (details.photos && Array.isArray(details.photos)) {\n      photo_count = details.photos.length;\n    }\n    price_level = details.priceLevel || null;\n    if (details.types && Array.isArray(details.types)) {\n      additional_types = details.types;\n    }\n  }\n\n  results.push({\n    json: {\n      ...company,\n      _google_details: {\n        opening_hours,\n        business_status,\n        photo_count,\n        price_level,\n        additional_types,\n        _fetch_status: details.error ? 'error' : 'success'\n      }\n    }\n  });\n}\n\nreturn results;",

  "Prepare Social Processing": "// runOnceForAllItems — index-paired with Prepare Company Update\n// Enrichment Config is a single-item node, hoisted outside loop\nconst upstreamAll = $('Prepare Company Update').all();\nconst inputAll = $input.all();\nconst config = $('Enrichment Config').first().json;\nconst skipSocial = config.skip_social_discovery === 'true' || config.skip_social_discovery === true;\nconst results = [];\n\nfor (let i = 0; i < inputAll.length; i++) {\n  const item = upstreamAll[i].json;\n\n  const socialLinks = item._social_links_found || [];\n  const needsDiscovery = item._needs_social_discovery && !skipSocial;\n\n  results.push({\n    json: {\n      company_id: item.id,\n      company_name: item.name,\n      city: item.city,\n      state: item.state,\n      domain: item.domain,\n      social_links_found: socialLinks,\n      needs_social_discovery: needsDiscovery,\n      _skip_social: skipSocial\n    }\n  });\n}\n\nreturn results;",

  "Parse Apollo Search": "// runOnceForAllItems — index-paired with Solo Practitioner Check\nconst upstreamAll = $('Solo Practitioner Check').all();\nconst inputAll = $input.all();\nconst results = [];\n\n// Hoisted keyword arrays\nconst ownerKeywords = ['owner', 'founder', 'ceo', 'proprietor', 'principal', 'co-founder'];\nconst managerKeywords = ['manager', 'director', 'general manager', 'gm', 'head'];\nconst practitionerKeywords = ['massage', 'therapist', 'lmt', 'cmt', 'rmt', 'bodywork', 'esthetician'];\n\nfor (let i = 0; i < inputAll.length; i++) {\n  const company = upstreamAll[i].json;\n  const response = inputAll[i].json;\n  const people = response.people || [];\n\n  if (!people || people.length === 0) {\n    results.push({\n      json: {\n        ...company,\n        _apollo_found: false,\n        _apollo_person_id: null,\n        _apollo_person_count: 0\n      }\n    });\n    continue;\n  }\n\n  // Score people by role relevance - prefer owners/founders\n  let bestPerson = null;\n  let bestScore = -1;\n\n  for (const person of people) {\n    const title = (person.title || '').toLowerCase();\n    let score = 0;\n\n    if (ownerKeywords.some(k => title.includes(k))) score = 10;\n    else if (managerKeywords.some(k => title.includes(k))) score = 5;\n    else if (practitionerKeywords.some(k => title.includes(k))) score = 3;\n    else score = 1;\n\n    // Bonus for having email available\n    if (person.has_email === true || person.has_email === 'true') score += 1;\n\n    if (score > bestScore) {\n      bestScore = score;\n      bestPerson = person;\n    }\n  }\n\n  console.log(`Apollo search for ${company.domain}: ${people.length} people found. Best: ${bestPerson.first_name} (${bestPerson.title || 'no title'}, score ${bestScore})`);\n\n  results.push({\n    json: {\n      ...company,\n      _apollo_found: true,\n      _apollo_person_id: bestPerson.id,\n      _apollo_first_name: bestPerson.first_name,\n      _apollo_last_name_obfuscated: bestPerson.last_name_obfuscated || null,\n      _apollo_title: bestPerson.title || null,\n      _apollo_person_count: people.length\n    }\n  });\n}\n\nreturn results;",

  "Parse Apollo Enrich": "// runOnceForAllItems — index-paired with Parse Apollo Search\nconst upstreamAll = $('Parse Apollo Search').all();\nconst inputAll = $input.all();\nconst results = [];\n\nfor (let i = 0; i < inputAll.length; i++) {\n  const company = upstreamAll[i].json;\n  const response = inputAll[i].json;\n  const person = response.person || response.match || response;\n\n  if (!person || !person.first_name) {\n    // Enrichment failed but we still have search data\n    results.push({\n      json: {\n        _contact: {\n          company_id: company.id,\n          first_name: company._apollo_first_name || null,\n          last_name: null,\n          role: (company._apollo_title || '').toLowerCase().includes('owner') ? 'owner' : 'unknown',\n          is_owner: (company._apollo_title || '').toLowerCase().includes('owner'),\n          email_business: null,\n          email_personal: null,\n          phone_direct: null,\n          linkedin_url: null,\n          location: [company.city, company.state].filter(Boolean).join(', ') || null,\n          cultural_affinity: null,\n          source: 'apollo'\n        },\n        _company_name: company.name,\n        _company_id: company.id,\n        _source_method: 'apollo_search_only',\n        _has_contact: !!(company._apollo_first_name)\n      }\n    });\n    continue;\n  }\n\n  // Extract phone number\n  let phoneNumber = null;\n  if (person.phone_numbers && person.phone_numbers.length > 0) {\n    phoneNumber = person.phone_numbers[0].sanitized_number || person.phone_numbers[0].raw_number || null;\n  }\n\n  // Determine role\n  const title = (person.title || '').toLowerCase();\n  let role = 'unknown';\n  let isOwner = false;\n  if (['owner', 'founder', 'ceo', 'proprietor', 'principal', 'co-founder'].some(k => title.includes(k))) {\n    role = 'owner';\n    isOwner = true;\n  } else if (['manager', 'director', 'gm', 'general manager'].some(k => title.includes(k))) {\n    role = 'manager';\n  } else if (['massage', 'therapist', 'lmt', 'cmt', 'rmt', 'esthetician'].some(k => title.includes(k))) {\n    role = 'practitioner';\n  }\n\n  results.push({\n    json: {\n      _contact: {\n        company_id: company.id,\n        first_name: person.first_name || null,\n        last_name: person.last_name || null,\n        role: role,\n        is_owner: isOwner,\n        email_business: person.email || null,\n        email_personal: (person.personal_emails && person.personal_emails[0]) || null,\n        phone_direct: phoneNumber,\n        linkedin_url: person.linkedin_url || null,\n        location: [person.city, person.state].filter(Boolean).join(', ') || [company.city, company.state].filter(Boolean).join(', ') || null,\n        cultural_affinity: null,\n        source: 'apollo'\n      },\n      _company_name: company.name,\n      _company_id: company.id,\n      _source_method: 'apollo_enriched',\n      _has_contact: true\n    }\n  });\n}\n\nreturn results;",

  "Parse SociaVault Response": "// runOnceForAllItems — index-paired with Should Enrich?\nconst upstreamAll = $('Should Enrich?').all();\nconst inputAll = $input.all();\nconst results = [];\n\nfor (let i = 0; i < inputAll.length; i++) {\n  const response = inputAll[i].json;\n  const profileData = upstreamAll[i].json;\n  const platform = profileData._platform;\n  const profileId = profileData.id;\n  const companyId = profileData.company_id;\n  let follower_count = null;\n  let post_count = null;\n  let last_post_date = null;\n  let fetchStatus = 'success';\n  let errorMsg = null;\n  try {\n    if (response.error || response.status === 'error' || response.success === false) {\n      fetchStatus = 'error';\n      errorMsg = response.error || response.message || 'API returned error';\n    } else if (platform === 'instagram') {\n      const user = response.data?.data?.user || response.data?.user || response.user || response.data || {};\n      follower_count = user.edge_followed_by?.count ?? user.follower_count ?? user.followers_count ?? null;\n      post_count = user.edge_owner_to_timeline_media?.count ?? user.media_count ?? null;\n      const edges = user.edge_owner_to_timeline_media?.edges || [];\n      const edgeArray = Array.isArray(edges) ? edges : Object.values(edges);\n      if (edgeArray.length > 0) {\n        const firstPost = edgeArray[0]?.node || edgeArray[0] || {};\n        if (firstPost.taken_at) {\n          last_post_date = new Date(firstPost.taken_at * 1000).toISOString().split('T')[0];\n        }\n      }\n    } else if (platform === 'facebook') {\n      const data = response.data || response;\n      follower_count = data.followerCount ?? data.follower_count ?? data.followers_count ?? data.likes ?? data.likeCount ?? data.fan_count ?? null;\n      post_count = data.posts_count ?? data.postCount ?? null;\n    } else if (platform === 'tiktok') {\n      const stats = response.data?.userInfo?.stats || response.data?.stats || {};\n      const user = response.data?.userInfo?.user || response.data?.user || response.data || response;\n      follower_count = stats.followerCount ?? user.followerCount ?? user.followers_count ?? null;\n      post_count = stats.videoCount ?? user.videoCount ?? null;\n    } else if (platform === 'x' || platform === 'twitter') {\n      const data = response.data || {};\n      const legacy = data.legacy || {};\n      const user = data.user || data;\n      follower_count = legacy.followers_count ?? legacy.normal_followers_count ?? user.followers_count ?? user.followerCount ?? user.public_metrics?.followers_count ?? null;\n      post_count = legacy.statuses_count ?? user.statuses_count ?? user.tweet_count ?? user.public_metrics?.tweet_count ?? null;\n      if (data.message === \"Account doesn't exist\" || data.userId === null && data.handle) {\n        fetchStatus = 'not_found';\n        errorMsg = `Account @${data.handle} does not exist`;\n        follower_count = null;\n        post_count = null;\n      }\n      if (user.status?.created_at) {\n        try { last_post_date = new Date(user.status.created_at).toISOString().split('T')[0]; } catch(e) {}\n      }\n    } else if (platform === 'linkedin') {\n      const data = response.data || response;\n      follower_count = data.followerCount ?? data.followers_count ?? data.followersCount ?? null;\n    } else if (platform === 'youtube') {\n      const data = response.data || response;\n      follower_count = data.subscriberCount ?? data.subscriber_count ?? data.statistics?.subscriberCount ?? null;\n      post_count = data.videoCount ?? data.video_count ?? data.statistics?.videoCount ?? null;\n      if (typeof follower_count === 'string') follower_count = parseInt(follower_count, 10);\n      if (typeof post_count === 'string') post_count = parseInt(post_count, 10);\n    }\n    if (follower_count !== null) follower_count = Number(follower_count) || null;\n    if (post_count !== null) post_count = Number(post_count) || null;\n  } catch (e) {\n    fetchStatus = 'error';\n    errorMsg = 'Parse error: ' + e.message;\n  }\n  results.push({ json: { _profile_id: profileId, _company_id: companyId, _platform: platform, _extracted_handle: profileData._extracted_handle, _fetch_status: fetchStatus, _error: errorMsg, _update_payload: { follower_count, post_count, last_post_date, scraped_at: new Date().toISOString() } } });\n}\n\nreturn results;",

  "Extract & Patch Domain": "// runOnceForAllItems — index-paired with Needs Backfill?\nconst upstreamAll = $('Needs Backfill?').all();\nconst inputAll = $input.all();\nconst results = [];\n\n// Hoisted constant\nconst BLOCKED_DOMAINS = ['wixsite.com','wix.com','setmore.com','schedulista.com','glossgenius.com','square.site','genbook.com','jane.app','acuityscheduling.com','mindbodyonline.com','mindbody.io','vagaro.com','fresha.com','schedulicity.com','booksy.com','massagebook.com','noterro.com','clinicsense.com','calendly.com','squarespace.com'];\n\nfor (let i = 0; i < inputAll.length; i++) {\n  const company = upstreamAll[i].json;\n  const response = inputAll[i].json;\n  const places = response.places || [];\n\n  if (places.length === 0) {\n    results.push({ json: { ...company } });\n    continue;\n  }\n\n  const companyName = (company.name || '').toLowerCase().replace(/[^a-z0-9\\s]/g, '');\n  const companyPhone = (company.phone || '').replace(/[^\\d]/g, '');\n\n  let bestMatch = null;\n  let bestScore = 0;\n\n  for (const place of places) {\n    const placeName = ((place.displayName && place.displayName.text) || '').toLowerCase().replace(/[^a-z0-9\\s]/g, '');\n    let score = 0;\n\n    const companyWords = companyName.split(/\\s+/).filter(w => w.length > 2);\n    const placeWords = placeName.split(/\\s+/).filter(w => w.length > 2);\n    const matchingWords = companyWords.filter(w => placeWords.some(pw => pw.includes(w) || w.includes(pw)));\n    score = companyWords.length > 0 ? matchingWords.length / companyWords.length : 0;\n\n    const placePhone = (place.internationalPhoneNumber || place.nationalPhoneNumber || '').replace(/[^\\d]/g, '');\n    if (companyPhone && placePhone && (placePhone.includes(companyPhone.slice(-10)) || companyPhone.includes(placePhone.slice(-10)))) {\n      score += 0.5;\n    }\n\n    if (score > bestScore && score >= 0.4) {\n      bestScore = score;\n      bestMatch = place;\n    }\n  }\n\n  if (!bestMatch) {\n    results.push({ json: { ...company } });\n    continue;\n  }\n\n  const website = bestMatch.websiteUri || '';\n  let domain = null;\n  if (website) {\n    const match = website.match(/^https?:\\/\\/(?:www\\.)?([^\\/]+)/i);\n    if (match) domain = match[1];\n  }\n\n  // Check domain against blocklist\n  let _domain_blocked = false;\n  let _domain_blocked_platform = '';\n  if (domain) {\n    const lowerDomain = domain.toLowerCase();\n    for (const blocked of BLOCKED_DOMAINS) {\n      if (lowerDomain === blocked || lowerDomain.endsWith('.' + blocked)) {\n        _domain_blocked = true;\n        _domain_blocked_platform = blocked;\n        domain = null;\n        break;\n      }\n    }\n  }\n\n  // Merge found data into the company item so downstream nodes see it\n  const updated = { ...company };\n  if (bestMatch.id && !company.google_place_id) updated.google_place_id = bestMatch.id;\n  if (domain) {\n    updated.domain = domain;\n    updated.has_website = true;\n  }\n  if (_domain_blocked) {\n    updated._domain_blocked = true;\n    updated._domain_blocked_platform = _domain_blocked_platform;\n  }\n  if (bestMatch.rating && !company.google_rating) updated.google_rating = bestMatch.rating;\n  if (bestMatch.userRatingCount && !company.google_review_count) updated.google_review_count = bestMatch.userRatingCount;\n\n  // Build Supabase patch payload - only include domain if not blocked\n  const patch = {};\n  if (updated.google_place_id !== company.google_place_id) patch.google_place_id = updated.google_place_id;\n  if (domain) {\n    patch.domain = domain;\n    if (updated.has_website !== company.has_website) patch.has_website = updated.has_website;\n  }\n  if (updated.google_rating !== company.google_rating) patch.google_rating = updated.google_rating;\n  if (updated.google_review_count !== company.google_review_count) patch.google_review_count = updated.google_review_count;\n\n  updated._backfill_patch = Object.keys(patch).length > 0 ? patch : null;\n  updated._backfill_matched = bestMatch.displayName?.text || '';\n  updated._backfill_score = bestScore;\n\n  results.push({ json: updated });\n}\n\nreturn results;"
}