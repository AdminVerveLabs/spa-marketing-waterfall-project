{
  "workflow_name": "Step 4 (isolated) - with Layer 2 Verification",
  "total_nodes": 151,
  "type_counts": {
    "set": 5,
    "code": 72,
    "httpRequest": 36,
    "merge": 2,
    "if": 32,
    "wait": 3,
    "manualTrigger": 1
  },
  "nodes": [
    {
      "name": "When clicking ‘Execute workflow’",
      "id": "ade90cb9-8930-4ca0-bb13-64dd4785518d",
      "type": "manualTrigger",
      "full_type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [
        -1184,
        -16
      ],
      "notes": "",
      "onError": "",
      "mode": "",
      "incoming": [],
      "outgoing": [
        {
          "target": "Metro Config",
          "output_idx": 0,
          "input_idx": 0
        }
      ]
    },
    {
      "name": "Metro Config",
      "id": "a0b81122-bcd5-45d5-8fe6-8d44573dba06",
      "type": "set",
      "full_type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -848,
        -16
      ],
      "notes": "CONFIGURE: Change metro_name, lat/lng, radius, search queries, and yelp_location for each metro.",
      "onError": "",
      "mode": "",
      "incoming": [
        {
          "source": "When clicking ‘Execute workflow’",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Split Search Queries",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "set_assignments": [
        {
          "id": "metro-name",
          "name": "metro_name",
          "value": "Austin, TX",
          "type": "string"
        },
        {
          "id": "metro-lat",
          "name": "latitude",
          "value": "30.2672",
          "type": "string"
        },
        {
          "id": "metro-lng",
          "name": "longitude",
          "value": "-97.7431",
          "type": "string"
        },
        {
          "id": "search-radius",
          "name": "radius_meters",
          "value": "10000",
          "type": "string"
        },
        {
          "id": "search-queries",
          "name": "search_queries",
          "value": "massage therapy,massage clinic,RMT,spa massage,massage therapist",
          "type": "string"
        },
        {
          "id": "metro-location-label",
          "name": "yelp_location",
          "value": "Austin, TX",
          "type": "string"
        }
      ],
      "set_options": {}
    },
    {
      "name": "Split Search Queries",
      "id": "2210a103-e3ea-49ee-b541-d68b7e9a5e34",
      "type": "code",
      "full_type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -624,
        -16
      ],
      "notes": "",
      "onError": "",
      "mode": "",
      "incoming": [
        {
          "source": "Metro Config",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Google Places - Text Search",
          "output_idx": 0,
          "input_idx": 0
        },
        {
          "target": "Start Apify Run",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "jsCode": "const config = $input.first().json;\nconst queries = config.search_queries.split(',').map(q => q.trim());\nreturn queries.map(query => ({\n  json: {\n    query,\n    latitude: config.latitude,\n    longitude: config.longitude,\n    radius_meters: config.radius_meters,\n    metro_name: config.metro_name,\n    yelp_location: config.yelp_location\n  }\n}));",
      "upstream_refs": [],
      "ref_methods": [],
      "code_lines": 12
    },
    {
      "name": "Start Apify Run",
      "id": "33ffe9a4-d680-4bd2-9d45-242130e350f5",
      "type": "httpRequest",
      "full_type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -400,
        80
      ],
      "notes": "Starts the Apify task. Returns run object with data.id for polling.",
      "onError": "continueRegularOutput",
      "mode": "",
      "incoming": [
        {
          "source": "Split Search Queries",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Extract Run ID",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "http_method": "POST",
      "http_url": "=https://api.apify.com/v2/actor-tasks/uplifted_veranda~yelp-scraper-task/runs?token={{ $env.APIFY_API_TOKEN }}",
      "http_sendHeaders": true,
      "http_headers": [
        {
          "name": "Content-Type",
          "value": "application/json"
        }
      ],
      "http_sendBody": true,
      "http_bodyType": "json",
      "http_jsonBody": "={\n  \"searchTerms\": [\"{{ $json.query }}\"],\n  \"locations\": [\"{{ $json.yelp_location }}\"],\n  \"searchLimit\": 5,\n  \"maxImages\": 0,\n  \"reviewLimit\": 0\n}",
      "http_body": "",
      "http_options": {
        "timeout": 30000
      },
      "http_batching": null,
      "http_timeout": 30000,
      "http_sendQuery": false,
      "http_queryParams": []
    },
    {
      "name": "Extract Run ID",
      "id": "c009a50e-d98f-42fb-ad5c-ffe08f1348cc",
      "type": "code",
      "full_type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -176,
        80
      ],
      "notes": "",
      "onError": "",
      "mode": "",
      "incoming": [
        {
          "source": "Start Apify Run",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Wait 30s",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "jsCode": "const response = $input.first().json;\nlet runId = '';\nlet datasetId = '';\n\nif (response.data) {\n  runId = response.data.id || '';\n  datasetId = response.data.defaultDatasetId || '';\n}\n\nif (!runId) {\n  throw new Error('Failed to start Apify run. Response: ' + JSON.stringify(response).substring(0, 500));\n}\n\nreturn [{ json: { runId, datasetId, pollCount: 0 } }];",
      "upstream_refs": [],
      "ref_methods": [],
      "code_lines": 14
    },
    {
      "name": "Wait 30s",
      "id": "87611ab3-5320-4f87-9af6-6acd25fc9fc8",
      "type": "wait",
      "full_type": "n8n-nodes-base.wait",
      "typeVersion": 1.1,
      "position": [
        48,
        80
      ],
      "notes": "",
      "onError": "",
      "mode": "",
      "incoming": [
        {
          "source": "Extract Run ID",
          "output_idx": 0,
          "input_idx": 0
        },
        {
          "source": "Run Succeeded?",
          "output_idx": 1,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Check Run Status",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "wait_amount": 20,
      "wait_unit": ""
    },
    {
      "name": "Check Run Status",
      "id": "df91ec9c-d0c8-4edb-a227-4a62e49e8707",
      "type": "httpRequest",
      "full_type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        272,
        16
      ],
      "notes": "",
      "onError": "continueRegularOutput",
      "mode": "",
      "incoming": [
        {
          "source": "Wait 30s",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Parse Status",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "http_method": "GET",
      "http_url": "=https://api.apify.com/v2/actor-runs/{{ $('Extract Run ID').first().json.runId }}?token={{ $env.APIFY_API_TOKEN }}",
      "http_sendHeaders": false,
      "http_headers": [],
      "http_sendBody": false,
      "http_bodyType": "",
      "http_jsonBody": "",
      "http_body": "",
      "http_options": {
        "timeout": 15000
      },
      "http_batching": null,
      "http_timeout": 15000,
      "http_sendQuery": false,
      "http_queryParams": []
    },
    {
      "name": "Parse Status",
      "id": "984c8d00-213b-48a1-a366-ecad587f54f5",
      "type": "code",
      "full_type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        496,
        16
      ],
      "notes": "",
      "onError": "",
      "mode": "",
      "incoming": [
        {
          "source": "Check Run Status",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Run Succeeded?",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "jsCode": "const response = $input.first().json;\nconst prevData = $('Extract Run ID').first().json;\n\nlet status = 'UNKNOWN';\nlet datasetId = prevData.datasetId || '';\n\n// Single run response\nif (response.data && response.data.status && !response.data.items) {\n  status = response.data.status;\n  if (response.data.defaultDatasetId) datasetId = response.data.defaultDatasetId;\n}\n// List response\nelse if (response.data && response.data.items && response.data.items.length > 0) {\n  status = response.data.items[0].status;\n  if (response.data.items[0].defaultDatasetId) datasetId = response.data.items[0].defaultDatasetId;\n}\n\n// Increment poll count from previous Parse Status if looping, otherwise from Extract Run ID\nlet pollCount = 0;\ntry {\n  pollCount = $('Parse Status').first().json.pollCount || 0;\n} catch(e) {\n  pollCount = prevData.pollCount || 0;\n}\npollCount++;\n\nreturn [{ json: { runId: prevData.runId, datasetId, pollCount, status } }];",
      "upstream_refs": [
        "Parse Status",
        "Extract Run ID"
      ],
      "ref_methods": [
        {
          "node": "Extract Run ID",
          "method": "first"
        },
        {
          "node": "Parse Status",
          "method": "first"
        }
      ],
      "code_lines": 27
    },
    {
      "name": "Run Succeeded?",
      "id": "1a02709f-fc9d-4d1a-8eb3-3852f91501d5",
      "type": "if",
      "full_type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        720,
        80
      ],
      "notes": "",
      "onError": "",
      "mode": "",
      "incoming": [
        {
          "source": "Parse Status",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Fetch Apify Results",
          "output_idx": 0,
          "input_idx": 0
        },
        {
          "target": "Wait 30s",
          "output_idx": 1,
          "input_idx": 0
        }
      ],
      "if_conditions": {
        "options": {
          "caseSensitive": true,
          "leftValue": "",
          "typeValidation": "strict"
        },
        "conditions": [
          {
            "id": "succeeded",
            "leftValue": "={{ $json.status }}",
            "rightValue": "SUCCEEDED",
            "operator": {
              "type": "string",
              "operation": "equals"
            }
          }
        ],
        "combinator": "and"
      },
      "if_options": {}
    },
    {
      "name": "Google Places - Text Search",
      "id": "730b6130-37c2-4200-b102-0e8c3e9c891d",
      "type": "httpRequest",
      "full_type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        944,
        -160
      ],
      "notes": "Google Places API (v1). Needs HTTP Header Auth credential: name='X-Goog-Api-Key', value=your API key.",
      "onError": "",
      "mode": "",
      "incoming": [
        {
          "source": "Split Search Queries",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Normalize Google Results",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "http_method": "POST",
      "http_url": "https://places.googleapis.com/v1/places:searchText",
      "http_sendHeaders": true,
      "http_headers": [
        {
          "name": "X-Goog-FieldMask",
          "value": "places.id,places.displayName,places.formattedAddress,places.nationalPhoneNumber,places.internationalPhoneNumber,places.websiteUri,places.googleMapsUri,places.rating,places.userRatingCount,places.primaryType,places.primaryTypeDisplayName,places.addressComponents,nextPageToken"
        },
        {
          "name": "X-Goog-Api-Key",
          "value": "={{ $env.GOOGLE_PLACES_API_KEY }}"
        }
      ],
      "http_sendBody": true,
      "http_bodyType": "json",
      "http_jsonBody": "={\n  \"textQuery\": \"{{ $json.query }}\",\n  \"locationBias\": {\n    \"circle\": {\n      \"center\": {\n        \"latitude\": {{ $json.latitude }},\n        \"longitude\": {{ $json.longitude }}\n      },\n      \"radius\": {{ $json.radius_meters }}\n    }\n  },\n  \"maxResultCount\": 10\n}",
      "http_body": "",
      "http_options": {},
      "http_batching": null,
      "http_timeout": null,
      "http_sendQuery": false,
      "http_queryParams": []
    },
    {
      "name": "Fetch Apify Results",
      "id": "6be46492-cd6b-4ab3-bb79-3d990eb82988",
      "type": "httpRequest",
      "full_type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        944,
        80
      ],
      "notes": "",
      "onError": "",
      "mode": "",
      "incoming": [
        {
          "source": "Run Succeeded?",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Normalize Yelp Results",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "http_method": "GET",
      "http_url": "=https://api.apify.com/v2/datasets/{{ $json.datasetId }}/items?token={{ $env.APIFY_API_TOKEN }}",
      "http_sendHeaders": false,
      "http_headers": [],
      "http_sendBody": false,
      "http_bodyType": "",
      "http_jsonBody": "",
      "http_body": "",
      "http_options": {
        "timeout": 60000
      },
      "http_batching": null,
      "http_timeout": 60000,
      "http_sendQuery": false,
      "http_queryParams": []
    },
    {
      "name": "Normalize Google Results",
      "id": "ce2cbb27-b415-41b3-a093-6ed18a008655",
      "type": "code",
      "full_type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1168,
        -160
      ],
      "notes": "",
      "onError": "",
      "mode": "",
      "incoming": [
        {
          "source": "Google Places - Text Search",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Merge All Sources",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "jsCode": "const allInputs = JSON.parse(JSON.stringify($input.all().map(i => i.json)));\nconst allPlaces = [];\n\nfor (const input of allInputs) {\n  const places = input.places || [];\n  const q = input.query || '';\n  places.forEach(p => { p._query = q; });\n  allPlaces.push(...places);\n}\n\nconst metro = JSON.parse(JSON.stringify($('Metro Config').first().json)).metro_name;\n\nreturn allPlaces.map(place => {\n  let city = '', state = '', country = '';\n  if (place.addressComponents) {\n    for (const comp of place.addressComponents) {\n      if (comp.types && comp.types.includes('locality')) city = comp.longText || '';\n      if (comp.types && comp.types.includes('administrative_area_level_1')) state = comp.shortText || '';\n      if (comp.types && comp.types.includes('country')) country = comp.shortText || '';\n    }\n  }\n\n  let phone = place.internationalPhoneNumber || place.nationalPhoneNumber || '';\n  let phoneNormalized = phone.replace(/[^\\d+]/g, '');\n  if (phoneNormalized && !phoneNormalized.startsWith('+')) {\n    phoneNormalized = '+1' + phoneNormalized.replace(/^1/, '');\n  }\n\n  const website = place.websiteUri || '';\n  let domain = '';\n  if (website) {\n    const match = website.match(/^https?:\\/\\/(?:www\\.)?([^\\/]+)/i);\n    if (match) domain = match[1];\n  }\n\n  return {\n    json: {\n      name: (place.displayName && place.displayName.text) || '',\n      phone: phoneNormalized,\n      domain: domain,\n      address: place.formattedAddress || '',\n      city, state, country: country || 'US',\n      google_place_id: place.id || '',\n      category: (place.primaryTypeDisplayName && place.primaryTypeDisplayName.text) || place.primaryType || '',\n      google_rating: place.rating || null,\n      google_review_count: place.userRatingCount || 0,\n      has_website: !!website,\n      google_maps_url: place.googleMapsUri || '',\n      source_urls: [{source: 'google_places', url: place.googleMapsUri || '', query_used: place._query || ''}],\n      discovery_metro: metro,\n      discovery_source: 'google_places'\n    }\n  };\n});",
      "upstream_refs": [
        "Metro Config"
      ],
      "ref_methods": [
        {
          "node": "Metro Config",
          "method": "first"
        }
      ],
      "code_lines": 54
    },
    {
      "name": "Normalize Yelp Results",
      "id": "f00aa961-127f-44d3-be9b-bff95186e169",
      "type": "code",
      "full_type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1168,
        80
      ],
      "notes": "After testing, change $('Test Input (Remove After Testing)') to $('Metro Config') and $('Split Search Queries').",
      "onError": "",
      "mode": "",
      "incoming": [
        {
          "source": "Fetch Apify Results",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Merge All Sources",
          "output_idx": 0,
          "input_idx": 1
        }
      ],
      "jsCode": "const metro = $('Metro Config').first().json.metro_name;\nconst query = $('Split Search Queries').first().json.query || '';\nconst results = [];\n\nfor (const item of items) {\n  const biz = item.json;\n  if (!biz.name) continue;\n\n  let phone = (biz.phone || '').replace(/[^\\d+]/g, '');\n  if (phone && !phone.startsWith('+')) {\n    phone = '+1' + phone.replace(/^1/, '');\n  }\n\n  let domain = '';\n  if (biz.website) {\n    try {\n      domain = new URL(biz.website.startsWith('http') ? biz.website : 'https://' + biz.website)\n        .hostname.replace(/^www\\./, '');\n    } catch(e) {}\n  }\n\n  const addr = biz.address || {};\n  const fullAddress = [addr.addressLine1, addr.addressLine2, addr.addressLine3]\n    .filter(Boolean).join(', ');\n\n  results.push({\n    json: {\n      name: biz.name,\n      phone: phone,\n      domain: domain,\n      address: fullAddress,\n      city: addr.city || '',\n      state: addr.regionCode || '',\n      country: addr.country || 'US',\n      google_place_id: '',\n      category: (biz.categories || []).join(', '),\n      google_rating: null,\n      google_review_count: 0,\n      yelp_rating: biz.aggregatedRating || null,\n      yelp_review_count: biz.reviewCount || 0,\n      has_website: !!biz.website,\n      yelp_url: biz.directUrl || '',\n      yelp_is_claimed: biz.claimed || false,\n      yelp_is_advertiser: biz.advertiser || false,\n      source_urls: [{source: 'yelp_apify', url: biz.directUrl || '', query_used: query}],\n      discovery_metro: metro,\n      discovery_source: 'yelp_apify'\n    }\n  });\n}\n\nreturn results.length > 0 ? results : [{ json: { _empty: true } }];",
      "upstream_refs": [
        "Split Search Queries",
        "Metro Config"
      ],
      "ref_methods": [
        {
          "node": "Metro Config",
          "method": "first"
        },
        {
          "node": "Split Search Queries",
          "method": "first"
        }
      ],
      "code_lines": 52
    },
    {
      "name": "Merge All Sources",
      "id": "faed64de-f147-4b08-a334-e051efca3fa3",
      "type": "merge",
      "full_type": "n8n-nodes-base.merge",
      "typeVersion": 3,
      "position": [
        1392,
        -16
      ],
      "notes": "",
      "onError": "",
      "mode": "",
      "incoming": [
        {
          "source": "Normalize Google Results",
          "output_idx": 0,
          "input_idx": 0
        },
        {
          "source": "Normalize Yelp Results",
          "output_idx": 0,
          "input_idx": 1
        }
      ],
      "outgoing": [
        {
          "target": "Deduplicate Records",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "merge_mode": "",
      "merge_options": {}
    },
    {
      "name": "Deduplicate Records",
      "id": "b7179d36-5ffc-439f-b846-5bb143a38078",
      "type": "code",
      "full_type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1616,
        -16
      ],
      "notes": "",
      "onError": "",
      "mode": "",
      "incoming": [
        {
          "source": "Merge All Sources",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Prepare for Supabase",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "jsCode": "const items = $input.all().map(i => i.json);\nconst canonical = [];\nconst phoneIndex = {};\nconst domainIndex = {};\n\nfunction normalizePhone(p) { return (p || '').replace(/[^\\d+]/g, ''); }\nfunction normalizeDomain(d) { return (d || '').toLowerCase().replace(/^www\\./, '').trim(); }\nfunction normalizeName(n) { return (n || '').toLowerCase().replace(/[^a-z0-9\\s]/g, '').trim(); }\nfunction nameSimilarity(a, b) {\n  const setA = new Set(normalizeName(a).split(/\\s+/));\n  const setB = new Set(normalizeName(b).split(/\\s+/));\n  const intersection = new Set([...setA].filter(x => setB.has(x)));\n  const union = new Set([...setA, ...setB]);\n  return union.size === 0 ? 0 : intersection.size / union.size;\n}\n\nfor (const item of items) {\n  const phone = normalizePhone(item.phone);\n  const domain = normalizeDomain(item.domain);\n  const city = (item.city || '').toLowerCase();\n  let matched = false;\n\n  if (phone && phone.length >= 10 && phoneIndex[phone] !== undefined) {\n    const existing = canonical[phoneIndex[phone]];\n    existing.source_urls = [...(existing.source_urls || []), ...(item.source_urls || [])];\n    if (!existing.domain && item.domain) existing.domain = item.domain;\n    if (!existing.google_place_id && item.google_place_id) existing.google_place_id = item.google_place_id;\n    if (!existing.has_website && item.has_website) existing.has_website = item.has_website;\n    if (item.google_rating) existing.google_rating = item.google_rating;\n    if (item.google_review_count) existing.google_review_count = item.google_review_count;\n    if (item.yelp_rating) existing.yelp_rating = item.yelp_rating;\n    if (item.yelp_review_count) existing.yelp_review_count = item.yelp_review_count;\n    if (item.yelp_url) existing.yelp_url = item.yelp_url;\n    matched = true;\n  }\n\n  if (!matched && domain && domainIndex[domain] !== undefined) {\n    const existing = canonical[domainIndex[domain]];\n    existing.source_urls = [...(existing.source_urls || []), ...(item.source_urls || [])];\n    if (!existing.phone && item.phone) existing.phone = item.phone;\n    if (!existing.google_place_id && item.google_place_id) existing.google_place_id = item.google_place_id;\n    if (item.google_rating) existing.google_rating = item.google_rating;\n    if (item.google_review_count) existing.google_review_count = item.google_review_count;\n    if (item.yelp_rating) existing.yelp_rating = item.yelp_rating;\n    if (item.yelp_review_count) existing.yelp_review_count = item.yelp_review_count;\n    if (item.yelp_url) existing.yelp_url = item.yelp_url;\n    matched = true;\n  }\n\n  if (!matched) {\n    let fuzzyMatch = false;\n    for (let i = 0; i < canonical.length; i++) {\n      const existing = canonical[i];\n      if ((existing.city || '').toLowerCase() === city && city !== '') {\n        if (nameSimilarity(existing.name, item.name) >= 0.85) {\n          existing.source_urls = [...(existing.source_urls || []), ...(item.source_urls || [])];\n          existing._fuzzy_match_flag = true;\n          existing._fuzzy_match_names = [...(existing._fuzzy_match_names || [existing.name]), item.name];\n          fuzzyMatch = true;\n          break;\n        }\n      }\n    }\n    if (!fuzzyMatch) {\n      const idx = canonical.length;\n      canonical.push({...item});\n      if (phone && phone.length >= 10) phoneIndex[phone] = idx;\n      if (domain) domainIndex[domain] = idx;\n    }\n  }\n}\n\nconsole.log('Dedup:', items.length, 'raw ->', canonical.length, 'unique,', canonical.filter(c => c._fuzzy_match_flag).length, 'fuzzy flagged');\nreturn canonical.map(item => ({ json: item }));",
      "upstream_refs": [],
      "ref_methods": [],
      "code_lines": 74
    },
    {
      "name": "Prepare for Supabase",
      "id": "977fd0f5-761e-4305-9801-29dc56b91d20",
      "type": "code",
      "full_type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1840,
        -16
      ],
      "notes": "",
      "onError": "",
      "mode": "",
      "incoming": [
        {
          "source": "Deduplicate Records",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Fuzzy Match?",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "jsCode": "const now = new Date().toISOString();\nreturn $input.all().map(item => {\n  const r = item.json;\n  return { json: {\n    name: r.name, phone: r.phone || null, domain: r.domain || null,\n    address: r.address || null, city: r.city || null, state: r.state || null,\n    country: r.country || 'US', google_place_id: r.google_place_id || null,\n    category: r.category || null, has_website: r.has_website || false,\n    has_online_booking: false, booking_platform: null, has_paid_ads: false,\n    on_groupon: false,\n    on_yelp: (r.source_urls || []).some(s => s.source === 'yelp_apify'),\n    google_review_count: r.google_review_count || 0,\n    google_rating: r.google_rating || null,\n    estimated_size: null, source_urls: r.source_urls || [],\n    enrichment_status: r._fuzzy_match_flag ? 'needs_review' : 'discovered',\n    lead_score: 0, discovered_at: now, enriched_at: null,\n    _fuzzy_match_flag: r._fuzzy_match_flag || false\n  }};\n});",
      "upstream_refs": [],
      "ref_methods": [],
      "code_lines": 19
    },
    {
      "name": "Fuzzy Match?",
      "id": "a3fb61b0-59b0-493c-8094-06907e223f61",
      "type": "if",
      "full_type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        2064,
        -16
      ],
      "notes": "",
      "onError": "",
      "mode": "",
      "incoming": [
        {
          "source": "Prepare for Supabase",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Insert Flagged (Needs Review)",
          "output_idx": 0,
          "input_idx": 0
        },
        {
          "target": "Insert to Supabase",
          "output_idx": 1,
          "input_idx": 0
        }
      ],
      "if_conditions": {
        "options": {
          "caseSensitive": true,
          "leftValue": "",
          "typeValidation": "strict",
          "version": 1
        },
        "conditions": [
          {
            "id": "fuzzy-check",
            "leftValue": "={{ $json._fuzzy_match_flag }}",
            "rightValue": true,
            "operator": {
              "type": "boolean",
              "operation": "equals",
              "singleValue": true
            }
          }
        ],
        "combinator": "and"
      },
      "if_options": {}
    },
    {
      "name": "Insert Flagged (Needs Review)",
      "id": "60e2440a-9ea0-4bc9-b6cd-282184cf6ce3",
      "type": "httpRequest",
      "full_type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        2288,
        -112
      ],
      "notes": "Fuzzy-matched records. Status = needs_review for manual dedup.",
      "onError": "",
      "mode": "",
      "incoming": [
        {
          "source": "Fuzzy Match?",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Run Summary",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "http_method": "POST",
      "http_url": "={{ $env.SUPABASE_URL }}/rest/v1/companies?on_conflict=google_place_id",
      "http_sendHeaders": true,
      "http_headers": [
        {
          "name": "apikey",
          "value": "={{ $env.SUPABASE_SERVICE_KEY }}"
        },
        {
          "name": "Authorization",
          "value": "=Bearer {{ $env.SUPABASE_SERVICE_KEY }}"
        },
        {
          "name": "Content-Type",
          "value": "application/json"
        },
        {
          "name": "Prefer",
          "value": "resolution=merge-duplicates"
        }
      ],
      "http_sendBody": true,
      "http_bodyType": "json",
      "http_jsonBody": "={{ JSON.stringify({ name: $json.name, phone: $json.phone, domain: $json.domain, address: $json.address, city: $json.city, state: $json.state, country: $json.country, google_place_id: $json.google_place_id, category: $json.category, has_website: $json.has_website, source_urls: $json.source_urls, enrichment_status: 'needs_review', discovered_at: $json.discovered_at }) }}",
      "http_body": "",
      "http_options": {},
      "http_batching": null,
      "http_timeout": null,
      "http_sendQuery": false,
      "http_queryParams": []
    },
    {
      "name": "Insert to Supabase",
      "id": "50d1e854-7bbf-48b7-b701-0eded1411f84",
      "type": "httpRequest",
      "full_type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        2288,
        80
      ],
      "notes": "Clean records. Uses service_role key (bypasses RLS).",
      "onError": "continueRegularOutput",
      "mode": "",
      "incoming": [
        {
          "source": "Fuzzy Match?",
          "output_idx": 1,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Run Summary",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "http_method": "POST",
      "http_url": "={{ $env.SUPABASE_URL }}/rest/v1/companies?on_conflict=google_place_id",
      "http_sendHeaders": true,
      "http_headers": [
        {
          "name": "apikey",
          "value": "={{ $env.SUPABASE_SERVICE_KEY }}"
        },
        {
          "name": "Authorization",
          "value": "=Bearer {{ $env.SUPABASE_SERVICE_KEY }}"
        },
        {
          "name": "Content-Type",
          "value": "application/json"
        },
        {
          "name": "Prefer",
          "value": "resolution=merge-duplicates"
        }
      ],
      "http_sendBody": true,
      "http_bodyType": "json",
      "http_jsonBody": "={{ JSON.stringify({ name: $json.name, phone: $json.phone, domain: $json.domain, address: $json.address, city: $json.city, state: $json.state, country: $json.country, google_place_id: $json.google_place_id, category: $json.category, has_website: $json.has_website, has_online_booking: $json.has_online_booking, on_groupon: $json.on_groupon, on_yelp: $json.on_yelp, google_review_count: $json.google_review_count, google_rating: $json.google_rating, source_urls: $json.source_urls, enrichment_status: 'discovered', discovered_at: $json.discovered_at }) }}",
      "http_body": "",
      "http_options": {
        "batching": {
          "batch": {}
        }
      },
      "http_batching": {
        "batch": {}
      },
      "http_timeout": null,
      "http_sendQuery": false,
      "http_queryParams": []
    },
    {
      "name": "Run Summary",
      "id": "904634a5-cffe-431f-ab8d-d912d5801553",
      "type": "code",
      "full_type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2512,
        -16
      ],
      "notes": "",
      "onError": "",
      "mode": "",
      "incoming": [
        {
          "source": "Insert to Supabase",
          "output_idx": 0,
          "input_idx": 0
        },
        {
          "source": "Insert Flagged (Needs Review)",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Enrichment Config",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "jsCode": "const allItems = $('Deduplicate Records').all();\nconst metro = $('Metro Config').first().json.metro_name;\nconst fromGoogle = allItems.filter(i => (i.json.source_urls || []).some(s => s.source === 'google_places')).length;\nconst fromYelp = allItems.filter(i => (i.json.source_urls || []).some(s => s.source === 'yelp_apify')).length;\nconst bothSources = allItems.filter(i => { const s = (i.json.source_urls || []).map(x => x.source); return s.includes('google_places') && s.includes('yelp_apify'); }).length;\nconst fuzzyFlagged = allItems.filter(i => i.json._fuzzy_match_flag).length;\n\nconst summary = {\n  metro, run_timestamp: new Date().toISOString(),\n  total_unique_records: allItems.length,\n  found_on_google: fromGoogle, found_on_yelp: fromYelp, found_on_both: bothSources,\n  flagged_for_review: fuzzyFlagged,\n  clean_records: allItems.length - fuzzyFlagged,\n  sources_used: ['google_places', 'yelp_apify']\n};\nconsole.log('=== DISCOVERY RUN SUMMARY ===');\nconsole.log(JSON.stringify(summary, null, 2));\nreturn [{ json: summary }];",
      "upstream_refs": [
        "Metro Config",
        "Deduplicate Records"
      ],
      "ref_methods": [
        {
          "node": "Deduplicate Records",
          "method": "all"
        },
        {
          "node": "Metro Config",
          "method": "first"
        }
      ],
      "code_lines": 18
    },
    {
      "name": "Enrichment Config",
      "id": "54d1fa8d-b26d-42d0-b2f6-d4c22f4ae77f",
      "type": "set",
      "full_type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        2736,
        -16
      ],
      "notes": "CONFIGURE: batch_size = how many companies to process per run. batch_offset = starting offset (for resuming). http_timeout_ms = timeout for website fetches. Set skip flags to 'true' to bypass sub-steps.",
      "onError": "",
      "mode": "",
      "incoming": [
        {
          "source": "Run Summary",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Fetch Batch from Supabase",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "set_assignments": [
        {
          "id": "batch-size",
          "name": "batch_size",
          "value": "100",
          "type": "string"
        },
        {
          "id": "batch-offset",
          "name": "batch_offset",
          "value": "0",
          "type": "string"
        },
        {
          "id": "http-timeout",
          "name": "http_timeout_ms",
          "value": "15000",
          "type": "string"
        },
        {
          "id": "skip-google-details",
          "name": "skip_google_details",
          "value": "false",
          "type": "string"
        },
        {
          "id": "skip-social-discovery",
          "name": "skip_social_discovery",
          "value": "true",
          "type": "string"
        }
      ],
      "set_options": {}
    },
    {
      "name": "Fetch Batch from Supabase",
      "id": "1df7b7f4-5866-4be3-8dd9-f0690b52def7",
      "type": "httpRequest",
      "full_type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        2960,
        -16
      ],
      "notes": "",
      "onError": "",
      "mode": "",
      "incoming": [
        {
          "source": "Enrichment Config",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Parse Batch",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "http_method": "GET",
      "http_url": "={{ $env.SUPABASE_URL }}/rest/v1/companies?enrichment_status=eq.discovered&order=discovered_at.asc&limit={{ $json.batch_size }}&offset={{ $json.batch_offset }}&select=id,name,phone,domain,address,city,state,country,google_place_id,category,has_website,google_review_count,google_rating,source_urls,on_yelp,on_groupon",
      "http_sendHeaders": true,
      "http_headers": [
        {
          "name": "apikey",
          "value": "={{ $env.SUPABASE_SERVICE_KEY }}"
        },
        {
          "name": "Authorization",
          "value": "=Bearer {{ $env.SUPABASE_SERVICE_KEY }}"
        }
      ],
      "http_sendBody": false,
      "http_bodyType": "",
      "http_jsonBody": "",
      "http_body": "",
      "http_options": {
        "timeout": 30000
      },
      "http_batching": null,
      "http_timeout": 30000,
      "http_sendQuery": false,
      "http_queryParams": []
    },
    {
      "name": "Parse Batch",
      "id": "ec61713a-fd89-4810-9ff3-497601e24a3f",
      "type": "code",
      "full_type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3184,
        -16
      ],
      "notes": "",
      "onError": "",
      "mode": "",
      "incoming": [
        {
          "source": "Fetch Batch from Supabase",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Batch Empty?",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "jsCode": "// Supabase HTTP node may return items individually (one per row) or as a single array.\n// Handle both cases.\nconst allInputs = $input.all();\n\nlet companies = [];\n\nif (allInputs.length === 1 && Array.isArray(allInputs[0].json)) {\n  // Single item containing an array\n  companies = allInputs[0].json;\n} else if (allInputs.length === 1 && allInputs[0].json[0]) {\n  // Single item with nested array\n  companies = allInputs[0].json;\n} else {\n  // Multiple items, one company per item (this is what n8n HTTP node does)\n  companies = allInputs.map(i => i.json);\n}\n\nif (!companies || companies.length === 0 || (companies.length === 1 && !companies[0].id)) {\n  return [{ json: { _empty: true, _count: 0, _message: 'No companies to enrich in this batch' } }];\n}\n\nconsole.log(`Batch loaded: ${companies.length} companies to enrich`);\n\nreturn companies.map(c => ({ json: c }));",
      "upstream_refs": [],
      "ref_methods": [],
      "code_lines": 24
    },
    {
      "name": "Batch Empty?",
      "id": "3787c4c4-9c41-4136-8072-b4fbc95c3e59",
      "type": "if",
      "full_type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        3408,
        -16
      ],
      "notes": "",
      "onError": "",
      "mode": "",
      "incoming": [
        {
          "source": "Parse Batch",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "No Records - Done",
          "output_idx": 0,
          "input_idx": 0
        },
        {
          "target": "Needs Backfill?",
          "output_idx": 1,
          "input_idx": 0
        }
      ],
      "if_conditions": {
        "options": {
          "caseSensitive": true,
          "leftValue": "",
          "typeValidation": "loose"
        },
        "conditions": [
          {
            "id": "empty-check",
            "leftValue": "={{ $json._empty }}",
            "rightValue": true,
            "operator": {
              "type": "boolean",
              "operation": "equals",
              "singleValue": true
            }
          }
        ],
        "combinator": "and"
      },
      "if_options": {}
    },
    {
      "name": "No Records - Done",
      "id": "5d72c418-ea8c-4a59-b38a-42bfc0cfacd0",
      "type": "code",
      "full_type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3632,
        -112
      ],
      "notes": "",
      "onError": "",
      "mode": "",
      "incoming": [
        {
          "source": "Batch Empty?",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [],
      "jsCode": "return [{ json: { message: 'No companies with enrichment_status=discovered found. Step 2 complete or no Step 1 data available.', completed_at: new Date().toISOString() } }];",
      "upstream_refs": [],
      "ref_methods": [],
      "code_lines": 1
    },
    {
      "name": "Needs Backfill?",
      "id": "2cb8d359-46de-48d4-a293-c427c2ee14cf",
      "type": "if",
      "full_type": "n8n-nodes-base.if",
      "typeVersion": 2.3,
      "position": [
        3632,
        80
      ],
      "notes": "",
      "onError": "",
      "mode": "",
      "incoming": [
        {
          "source": "Batch Empty?",
          "output_idx": 1,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Google Places Lookup",
          "output_idx": 0,
          "input_idx": 0
        },
        {
          "target": "Merge Backfill",
          "output_idx": 1,
          "input_idx": 1
        }
      ],
      "if_conditions": {
        "options": {
          "caseSensitive": true,
          "leftValue": "",
          "typeValidation": "loose",
          "version": 3
        },
        "conditions": [
          {
            "id": "b807db58-4ea5-4a80-893d-18a9609d454a",
            "leftValue": "={{ $json.domain }}",
            "rightValue": "",
            "operator": {
              "type": "string",
              "operation": "empty",
              "singleValue": true
            }
          },
          {
            "id": "1650bd01-dca9-4d41-932b-501666c3ff50",
            "leftValue": "={{ $json.has_website }}",
            "rightValue": "true",
            "operator": {
              "type": "boolean",
              "operation": "true",
              "singleValue": true
            }
          }
        ],
        "combinator": "and"
      },
      "if_options": {}
    },
    {
      "name": "Google Places Lookup",
      "id": "aea1ae1a-9214-4112-a5ec-2e3855ce4e9f",
      "type": "httpRequest",
      "full_type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [
        3856,
        0
      ],
      "notes": "",
      "onError": "continueRegularOutput",
      "mode": "",
      "incoming": [
        {
          "source": "Needs Backfill?",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Extract & Patch Domain",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "http_method": "POST",
      "http_url": "https://places.googleapis.com/v1/places:searchText",
      "http_sendHeaders": true,
      "http_headers": [
        {
          "name": "X-Goog-FieldMask",
          "value": "places.id,places.displayName,places.nationalPhoneNumber,places.internationalPhoneNumber,places.websiteUri,places.rating,places.userRatingCount"
        },
        {
          "name": "X-Goog-Api-Key",
          "value": "={{ $env.GOOGLE_PLACES_API_KEY }}"
        }
      ],
      "http_sendBody": true,
      "http_bodyType": "json",
      "http_jsonBody": "={\n  \"textQuery\": \"{{ $json.name }} {{ $json.city }} {{ $json.state }}\",\n  \"maxResultCount\": 3\n}",
      "http_body": "",
      "http_options": {
        "batching": {
          "batch": {
            "batchSize": 5
          }
        }
      },
      "http_batching": {
        "batch": {
          "batchSize": 5
        }
      },
      "http_timeout": null,
      "http_sendQuery": false,
      "http_queryParams": []
    },
    {
      "name": "Extract & Patch Domain",
      "id": "10e8341e-4856-400b-994a-ccda048aa054",
      "type": "code",
      "full_type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        4080,
        16
      ],
      "notes": "",
      "onError": "",
      "mode": "runOnceForEachItem",
      "incoming": [
        {
          "source": "Google Places Lookup",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Merge Backfill",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "jsCode": "const company = $('Needs Backfill?').item.json;\nconst response = $input.item.json;\nconst places = response.places || [];\n\nif (places.length === 0) {\n  return { json: { ...company } };\n}\n\nconst companyName = (company.name || '').toLowerCase().replace(/[^a-z0-9\\s]/g, '');\nconst companyPhone = (company.phone || '').replace(/[^\\d]/g, '');\n\nlet bestMatch = null;\nlet bestScore = 0;\n\nfor (const place of places) {\n  const placeName = ((place.displayName && place.displayName.text) || '').toLowerCase().replace(/[^a-z0-9\\s]/g, '');\n  let score = 0;\n\n  const companyWords = companyName.split(/\\s+/).filter(w => w.length > 2);\n  const placeWords = placeName.split(/\\s+/).filter(w => w.length > 2);\n  const matchingWords = companyWords.filter(w => placeWords.some(pw => pw.includes(w) || w.includes(pw)));\n  score = companyWords.length > 0 ? matchingWords.length / companyWords.length : 0;\n\n  const placePhone = (place.internationalPhoneNumber || place.nationalPhoneNumber || '').replace(/[^\\d]/g, '');\n  if (companyPhone && placePhone && (placePhone.includes(companyPhone.slice(-10)) || companyPhone.includes(placePhone.slice(-10)))) {\n    score += 0.5;\n  }\n\n  if (score > bestScore && score >= 0.4) {\n    bestScore = score;\n    bestMatch = place;\n  }\n}\n\nif (!bestMatch) {\n  return { json: { ...company } };\n}\n\nconst website = bestMatch.websiteUri || '';\nlet domain = null;\nif (website) {\n  const match = website.match(/^https?:\\/\\/(?:www\\.)?([^\\/]+)/i);\n  if (match) domain = match[1];\n}\n\n// Merge found data into the company item so downstream nodes see it\nconst updated = { ...company };\nif (bestMatch.id && !company.google_place_id) updated.google_place_id = bestMatch.id;\nif (domain) {\n  updated.domain = domain;\n  updated.has_website = true;\n}\nif (bestMatch.rating && !company.google_rating) updated.google_rating = bestMatch.rating;\nif (bestMatch.userRatingCount && !company.google_review_count) updated.google_review_count = bestMatch.userRatingCount;\n\n// Also build a Supabase patch payload for persistence\nconst patch = {};\nif (updated.google_place_id !== company.google_place_id) patch.google_place_id = updated.google_place_id;\nif (updated.domain !== company.domain) patch.domain = updated.domain;\nif (updated.has_website !== company.has_website) patch.has_website = updated.has_website;\nif (updated.google_rating !== company.google_rating) patch.google_rating = updated.google_rating;\nif (updated.google_review_count !== company.google_review_count) patch.google_review_count = updated.google_review_count;\n\nupdated._backfill_patch = Object.keys(patch).length > 0 ? patch : null;\nupdated._backfill_matched = bestMatch.displayName?.text || '';\nupdated._backfill_score = bestScore;\n\nreturn { json: updated };",
      "upstream_refs": [
        "Needs Backfill?"
      ],
      "ref_methods": [
        {
          "node": "Needs Backfill?",
          "method": "item.json"
        }
      ],
      "code_lines": 68
    },
    {
      "name": "Merge Backfill",
      "id": "4ce8b67b-5241-4ec8-8be6-59c04f25b715",
      "type": "merge",
      "full_type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        4304,
        80
      ],
      "notes": "",
      "onError": "",
      "mode": "",
      "incoming": [
        {
          "source": "Needs Backfill?",
          "output_idx": 1,
          "input_idx": 1
        },
        {
          "source": "Extract & Patch Domain",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Has Website?",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "merge_mode": "",
      "merge_options": {}
    },
    {
      "name": "Has Website?",
      "id": "35de7fc8-4ad1-439b-9e04-86dc071c5a23",
      "type": "if",
      "full_type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        4528,
        80
      ],
      "notes": "",
      "onError": "",
      "mode": "",
      "incoming": [
        {
          "source": "Merge Backfill",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Fetch Website HTML",
          "output_idx": 0,
          "input_idx": 0
        },
        {
          "target": "Skip - No Website",
          "output_idx": 1,
          "input_idx": 0
        }
      ],
      "if_conditions": {
        "options": {
          "caseSensitive": true,
          "leftValue": "",
          "typeValidation": "loose"
        },
        "conditions": [
          {
            "id": "has-domain",
            "leftValue": "={{ $json.has_website }}",
            "rightValue": true,
            "operator": {
              "type": "boolean",
              "operation": "equals",
              "singleValue": true
            }
          }
        ],
        "combinator": "and"
      },
      "if_options": {}
    },
    {
      "name": "Fetch Website HTML",
      "id": "96fc8693-42b1-47cb-96b9-2437457cf208",
      "type": "httpRequest",
      "full_type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        4752,
        -16
      ],
      "notes": "Fetches homepage HTML. On error (timeout, SSL, 403, etc.) continues with error data so the pipeline doesn't break.",
      "onError": "continueRegularOutput",
      "mode": "",
      "incoming": [
        {
          "source": "Has Website?",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Analyze Website HTML",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "http_method": "GET",
      "http_url": "=https://{{ $json.domain }}",
      "http_sendHeaders": true,
      "http_headers": [
        {
          "name": "User-Agent",
          "value": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36"
        },
        {
          "name": "Accept",
          "value": "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8"
        }
      ],
      "http_sendBody": false,
      "http_bodyType": "",
      "http_jsonBody": "",
      "http_body": "",
      "http_options": {
        "redirect": {
          "redirect": {
            "maxRedirects": 5
          }
        },
        "response": {
          "response": {
            "fullResponse": true,
            "responseFormat": "text"
          }
        },
        "timeout": "={{ Number($('Enrichment Config').first().json.http_timeout_ms) }}"
      },
      "http_batching": null,
      "http_timeout": "={{ Number($('Enrichment Config').first().json.http_timeout_ms) }}",
      "http_sendQuery": false,
      "http_queryParams": []
    },
    {
      "name": "Analyze Website HTML",
      "id": "f8073621-1fb3-457a-a51c-39ebc171d9e7",
      "type": "code",
      "full_type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        4976,
        -16
      ],
      "notes": "Detects booking platforms, paid ads scripts, social media links, and estimates team size from website HTML.",
      "onError": "",
      "mode": "runOnceForEachItem",
      "incoming": [
        {
          "source": "Fetch Website HTML",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Merge Website Results",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "jsCode": "const company = $('Has Website?').item.json;\nconst response = $input.item.json;\nconst domain = (company.domain || '').toLowerCase();\n\n// === DOMAIN-BASED BOOKING DETECTION (runs even if fetch fails) ===\nconst bookingSignatures = {\n  'jane_app': ['jane.app', 'janeapp.com'],\n  'acuity': ['acuityscheduling.com', 'squareup.com/appointments', 'app.acuityscheduling.com'],\n  'mindbody': ['mindbodyonline.com', 'clients.mindbodyonline.com', 'mindbody.io', 'healcode.com'],\n  'square': ['square.site', 'squareup.com'],\n  'vagaro': ['vagaro.com'],\n  'fresha': ['fresha.com', 'shedul.com'],\n  'schedulicity': ['schedulicity.com'],\n  'schedulista': ['schedulista.com'],\n  'booksy': ['booksy.com'],\n  'massagebook': ['massagebook.com'],\n  'genbook': ['genbook.com'],\n  'noterro': ['noterro.com'],\n  'clinicsense': ['clinicsense.com'],\n  'wix_bookings': ['wix.com/booking', 'bookings.wixapps.net'],\n  'calendly': ['calendly.com']\n};\n\nlet booking_platform = null;\nlet has_online_booking = false;\n\n// Check domain first — catches cases like xyz.schedulista.com or xyz.janeapp.com\nfor (const [platform, signatures] of Object.entries(bookingSignatures)) {\n  for (const sig of signatures) {\n    if (domain.includes(sig)) {\n      booking_platform = platform;\n      has_online_booking = true;\n      break;\n    }\n  }\n  if (has_online_booking) break;\n}\n\n// Handle fetch errors — still return domain-based findings\nif (response.error || (!response.body && !response.data)) {\n  return {\n    json: {\n      ...company,\n      _website_enrichment: {\n        has_online_booking,\n        booking_platform,\n        has_paid_ads: false,\n        estimated_size: null,\n        social_links_found: [],\n        _website_fetch_status: 'error',\n        _website_error: response.error || 'Empty response'\n      }\n    }\n  };\n}\n\nconst rawHtml = response.body || response.data || '';\nconst html = (typeof rawHtml === 'string' ? rawHtml : '').toLowerCase();\nconst htmlOriginal = typeof rawHtml === 'string' ? rawHtml : '';\n\n// === HTML-BASED BOOKING DETECTION (supplements domain detection) ===\nif (!has_online_booking) {\n  for (const [platform, signatures] of Object.entries(bookingSignatures)) {\n    for (const sig of signatures) {\n      if (html.includes(sig)) {\n        booking_platform = platform;\n        has_online_booking = true;\n        break;\n      }\n    }\n    if (has_online_booking) break;\n  }\n}\n\n// Also check for generic booking button patterns\nif (!has_online_booking) {\n  const bookingPatterns = ['book now', 'book online', 'book appointment', 'schedule now', 'schedule online', 'book a massage', 'online booking'];\n  for (const pattern of bookingPatterns) {\n    if (html.includes(pattern)) {\n      has_online_booking = true;\n      booking_platform = 'unknown';\n      break;\n    }\n  }\n}\n\n// === PAID ADS DETECTION ===\n// Only flag actual advertising/conversion pixels, NOT basic analytics\nconst adSignatures = [\n  // Google Ads (NOT analytics — gtag/js and google-analytics.com are just tracking)\n  'googleadservices.com',\n  'googlesyndication.com', \n  'googleads.g.doubleclick.net',\n  'google_conversion',\n  'conversion_async',\n  'ads/ga-audiences',\n  // Meta/Facebook Ads (fbevents.js + fbq( = Meta Pixel with conversion tracking)\n  'fbevents.js',\n  'fbq(',\n  // LinkedIn Ads\n  'snap.licdn.com',\n  'linkedin.com/insight',\n  // TikTok Ads\n  'analytics.tiktok.com',\n  'tiktok.com/i18n/pixel',\n  // Twitter/X Ads\n  'ads-twitter.com',\n  'static.ads-twitter.com'\n];\n\nlet has_paid_ads = false;\nconst detected_ad_platforms = [];\nfor (const sig of adSignatures) {\n  if (html.includes(sig)) {\n    has_paid_ads = true;\n    detected_ad_platforms.push(sig);\n  }\n}\n\n// === SOCIAL LINKS EXTRACTION ===\nconst socialPatterns = {\n  facebook: /https?:\\/\\/(?:www\\.)?facebook\\.com\\/[a-zA-Z0-9._-]+/gi,\n  instagram: /https?:\\/\\/(?:www\\.)?instagram\\.com\\/[a-zA-Z0-9._-]+/gi,\n  tiktok: /https?:\\/\\/(?:www\\.)?tiktok\\.com\\/@[a-zA-Z0-9._-]+/gi,\n  linkedin: /https?:\\/\\/(?:www\\.)?linkedin\\.com\\/(?:company|in)\\/[a-zA-Z0-9._-]+/gi,\n  x: /https?:\\/\\/(?:www\\.)?(?:twitter\\.com|x\\.com)\\/[a-zA-Z0-9._-]+/gi,\n  youtube: /https?:\\/\\/(?:www\\.)?youtube\\.com\\/(?:c\\/|channel\\/|@)[a-zA-Z0-9._-]+/gi\n};\n\nconst social_links_found = [];\nconst seenPlatforms = new Set();\n\nfor (const [platform, regex] of Object.entries(socialPatterns)) {\n  const matches = htmlOriginal.match(regex) || [];\n  for (const url of matches) {\n    const lowerUrl = url.toLowerCase();\n    if (lowerUrl.includes('/sharer') || lowerUrl.includes('/share') || \n        lowerUrl.includes('/intent') || lowerUrl.includes('/login') ||\n        lowerUrl.includes('/help') || lowerUrl.includes('/about') ||\n        lowerUrl.includes('/policies') || lowerUrl.includes('/privacy')) {\n      continue;\n    }\n    if (!seenPlatforms.has(platform)) {\n      social_links_found.push({ platform, url: url.replace(/\\/+$/, '') });\n      seenPlatforms.add(platform);\n    }\n  }\n}\n\n// === TEAM SIZE ESTIMATION ===\nlet estimated_size = null;\nconst teamPatterns = [\n  /our\\s+team/i, /meet\\s+(?:the\\s+)?team/i, /our\\s+(?:therapists|practitioners|staff|massage\\s+therapists)/i,\n  /meet\\s+(?:our|the)\\s+(?:therapists|practitioners|staff)/i\n];\n\nlet hasTeamPage = false;\nfor (const p of teamPatterns) {\n  if (p.test(htmlOriginal)) {\n    hasTeamPage = true;\n    break;\n  }\n}\n\nif (hasTeamPage) {\n  const namePatterns = htmlOriginal.match(/<h[2-4][^>]*>[^<]{2,40}<\\/h[2-4]>/gi) || [];\n  const staffLinks = htmlOriginal.match(/\\/(?:team|staff|therapist|practitioner)s?\\/[a-z-]+/gi) || [];\n  const memberCount = Math.max(namePatterns.length, staffLinks.length);\n  \n  if (memberCount <= 1) estimated_size = 'solo';\n  else if (memberCount <= 5) estimated_size = 'small';\n  else estimated_size = 'medium';\n} else {\n  const soloSignals = ['sole proprietor', 'solo practice', 'independent massage', \n    'i am a licensed', 'i\\'m a licensed', 'about me', 'my practice', 'my approach',\n    'my services', 'i specialize', 'i provide'];\n  const isSolo = soloSignals.some(s => html.includes(s));\n  if (isSolo) estimated_size = 'solo';\n}\n\nreturn {\n  json: {\n    ...company,\n    _website_enrichment: {\n      has_online_booking,\n      booking_platform,\n      has_paid_ads,\n      estimated_size,\n      social_links_found,\n      _website_fetch_status: 'success'\n    }\n  }\n};",
      "upstream_refs": [
        "Has Website?"
      ],
      "ref_methods": [
        {
          "node": "Has Website?",
          "method": "item.json"
        }
      ],
      "code_lines": 193
    },
    {
      "name": "Skip - No Website",
      "id": "4132b860-779c-490f-9de8-3285e6a63538",
      "type": "code",
      "full_type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        4976,
        176
      ],
      "notes": "",
      "onError": "",
      "mode": "runOnceForEachItem",
      "incoming": [
        {
          "source": "Has Website?",
          "output_idx": 1,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Merge Website Results",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "jsCode": "// For companies without a website, pass through with empty enrichment\n// but still check domain for booking platform signals\nconst item = $input.item.json;\nconst domain = (item.domain || '').toLowerCase();\n\nconst bookingSignatures = {\n  'jane_app': ['jane.app', 'janeapp.com'],\n  'acuity': ['acuityscheduling.com', 'squareup.com/appointments'],\n  'mindbody': ['mindbodyonline.com', 'clients.mindbodyonline.com', 'mindbody.io'],\n  'square': ['square.site', 'squareup.com'],\n  'vagaro': ['vagaro.com'],\n  'fresha': ['fresha.com', 'shedul.com'],\n  'schedulicity': ['schedulicity.com'],\n  'schedulista': ['schedulista.com'],\n  'booksy': ['booksy.com'],\n  'massagebook': ['massagebook.com'],\n  'genbook': ['genbook.com'],\n  'noterro': ['noterro.com'],\n  'clinicsense': ['clinicsense.com'],\n  'wix_bookings': ['wix.com/booking'],\n  'calendly': ['calendly.com']\n};\n\nlet booking_platform = null;\nlet has_online_booking = false;\n\nfor (const [platform, signatures] of Object.entries(bookingSignatures)) {\n  for (const sig of signatures) {\n    if (domain.includes(sig)) {\n      booking_platform = platform;\n      has_online_booking = true;\n      break;\n    }\n  }\n  if (has_online_booking) break;\n}\n\nreturn {\n  json: {\n    ...item,\n    _website_enrichment: {\n      has_online_booking,\n      booking_platform,\n      has_paid_ads: false,\n      estimated_size: null,\n      social_links_found: [],\n      _website_fetch_status: 'skipped_no_website'\n    }\n  }\n};",
      "upstream_refs": [],
      "ref_methods": [],
      "code_lines": 50
    },
    {
      "name": "Merge Website Results",
      "id": "4cca63b6-84fa-471f-a957-24ca66de88cf",
      "type": "code",
      "full_type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        5200,
        80
      ],
      "notes": "",
      "onError": "",
      "mode": "runOnceForEachItem",
      "incoming": [
        {
          "source": "Analyze Website HTML",
          "output_idx": 0,
          "input_idx": 0
        },
        {
          "source": "Skip - No Website",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Has Google Place ID?",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "jsCode": "// Merge website-enriched (from both paths: with website and without)\nconst item = $input.item.json;\nconst enrichment = item._website_enrichment || {};\n// Enrichment Config is a single-item node, .first() is correct here\nconst config = $('Enrichment Config').first().json;\nconst skipGoogleDetails = config.skip_google_details === 'true' || config.skip_google_details === true;\n\n// Prepare the enriched company object\nconst enriched = {\n  id: item.id,\n  name: item.name,\n  phone: item.phone,\n  domain: item.domain,\n  address: item.address,\n  city: item.city,\n  state: item.state,\n  country: item.country,\n  google_place_id: item.google_place_id,\n  category: item.category,\n  has_website: item.has_website,\n  google_review_count: item.google_review_count,\n  google_rating: item.google_rating,\n  source_urls: item.source_urls,\n  on_yelp: item.on_yelp,\n  on_groupon: item.on_groupon,\n\n  // Enriched fields from website analysis\n  has_online_booking: enrichment.has_online_booking || false,\n  booking_platform: enrichment.booking_platform || null,\n  has_paid_ads: enrichment.has_paid_ads || false,\n  estimated_size: enrichment.estimated_size || null,\n\n  // Social links for later processing\n  _social_links_found: enrichment.social_links_found || [],\n  _website_fetch_status: enrichment._website_fetch_status || 'unknown',\n  _website_error: enrichment._website_error || null,\n  _needs_social_discovery: (enrichment.social_links_found || []).length === 0,\n  _skip_google_details: skipGoogleDetails\n};\n\nreturn { json: enriched };",
      "upstream_refs": [
        "Enrichment Config"
      ],
      "ref_methods": [
        {
          "node": "Enrichment Config",
          "method": "first"
        }
      ],
      "code_lines": 41
    },
    {
      "name": "Has Google Place ID?",
      "id": "14faf286-a9b0-4f82-8e8c-6d5c70f48fb3",
      "type": "if",
      "full_type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        5424,
        80
      ],
      "notes": "",
      "onError": "",
      "mode": "",
      "incoming": [
        {
          "source": "Merge Website Results",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Google Places Details",
          "output_idx": 0,
          "input_idx": 0
        },
        {
          "target": "Skip Google Details",
          "output_idx": 1,
          "input_idx": 0
        }
      ],
      "if_conditions": {
        "options": {
          "caseSensitive": true,
          "leftValue": "",
          "typeValidation": "loose"
        },
        "conditions": [
          {
            "id": "has-place-id",
            "leftValue": "={{ $json.google_place_id }}",
            "rightValue": "",
            "operator": {
              "type": "string",
              "operation": "notEquals"
            }
          },
          {
            "id": "not-skipped",
            "leftValue": "={{ $json._skip_google_details }}",
            "rightValue": true,
            "operator": {
              "type": "boolean",
              "operation": "notEquals"
            }
          }
        ],
        "combinator": "and"
      },
      "if_options": {}
    },
    {
      "name": "Google Places Details",
      "id": "6717c6e5-0564-4899-b6c6-e9ddd290559e",
      "type": "httpRequest",
      "full_type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        5648,
        -16
      ],
      "notes": "Fetches ONLY incremental fields not captured in Step 1 Text Search: opening hours, business status, price level, photo count.",
      "onError": "continueRegularOutput",
      "mode": "",
      "incoming": [
        {
          "source": "Has Google Place ID?",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Parse Google Details",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "http_method": "GET",
      "http_url": "=https://places.googleapis.com/v1/places/{{ $json.google_place_id }}",
      "http_sendHeaders": true,
      "http_headers": [
        {
          "name": "X-Goog-FieldMask",
          "value": "currentOpeningHours,regularOpeningHours,types,photos,priceLevel,businessStatus"
        },
        {
          "name": "X-Goog-Api-Key",
          "value": "={{ $env.GOOGLE_PLACES_API_KEY }}"
        }
      ],
      "http_sendBody": false,
      "http_bodyType": "",
      "http_jsonBody": "",
      "http_body": "",
      "http_options": {
        "timeout": 15000
      },
      "http_batching": null,
      "http_timeout": 15000,
      "http_sendQuery": false,
      "http_queryParams": []
    },
    {
      "name": "Skip Google Details",
      "id": "29512238-af71-45a1-8965-58e94e021c20",
      "type": "code",
      "full_type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        5760,
        192
      ],
      "notes": "",
      "onError": "",
      "mode": "runOnceForEachItem",
      "incoming": [
        {
          "source": "Has Google Place ID?",
          "output_idx": 1,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Prepare Company Update",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "jsCode": "// Companies without Google Place ID skip details fetch\nconst company = $input.item.json;\nreturn {\n  json: {\n    ...company,\n    _google_details: {\n      opening_hours: null,\n      business_status: null,\n      photo_count: 0,\n      price_level: null,\n      additional_types: [],\n      _fetch_status: 'skipped'\n    }\n  }\n};",
      "upstream_refs": [],
      "ref_methods": [],
      "code_lines": 15
    },
    {
      "name": "Parse Google Details",
      "id": "6647ac0d-5b45-48b6-9131-44b282df0536",
      "type": "code",
      "full_type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        5872,
        -16
      ],
      "notes": "",
      "onError": "",
      "mode": "runOnceForEachItem",
      "incoming": [
        {
          "source": "Google Places Details",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Prepare Company Update",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "jsCode": "const company = $('Has Google Place ID?').item.json;\nconst details = $input.item.json;\n\n// Extract incremental data from Google Places Details\nlet opening_hours = null;\nlet business_status = null;\nlet photo_count = 0;\nlet price_level = null;\nlet additional_types = [];\n\nif (details && !details.error) {\n  if (details.regularOpeningHours && details.regularOpeningHours.periods) {\n    opening_hours = details.regularOpeningHours;\n  } else if (details.currentOpeningHours && details.currentOpeningHours.periods) {\n    opening_hours = details.currentOpeningHours;\n  }\n  business_status = details.businessStatus || null;\n  if (details.photos && Array.isArray(details.photos)) {\n    photo_count = details.photos.length;\n  }\n  price_level = details.priceLevel || null;\n  if (details.types && Array.isArray(details.types)) {\n    additional_types = details.types;\n  }\n}\n\nreturn {\n  json: {\n    ...company,\n    _google_details: {\n      opening_hours,\n      business_status,\n      photo_count,\n      price_level,\n      additional_types,\n      _fetch_status: details.error ? 'error' : 'success'\n    }\n  }\n};",
      "upstream_refs": [
        "Has Google Place ID?"
      ],
      "ref_methods": [
        {
          "node": "Has Google Place ID?",
          "method": "item.json"
        }
      ],
      "code_lines": 39
    },
    {
      "name": "Prepare Company Update",
      "id": "3b5fc27e-97c5-47b3-8310-6aedf579403f",
      "type": "code",
      "full_type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        6096,
        80
      ],
      "notes": "",
      "onError": "",
      "mode": "runOnceForEachItem",
      "incoming": [
        {
          "source": "Parse Google Details",
          "output_idx": 0,
          "input_idx": 0
        },
        {
          "source": "Skip Google Details",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Update Company in Supabase",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "jsCode": "const item = $input.item.json;\nconst now = new Date().toISOString();\n\n// Build the PATCH payload for Supabase\nconst updatePayload = {\n  has_online_booking: item.has_online_booking || false,\n  booking_platform: item.booking_platform || null,\n  has_paid_ads: item.has_paid_ads || false,\n  estimated_size: item.estimated_size || null,\n  enrichment_status: 'partially_enriched',\n  enriched_at: now\n};\n\n// Include backfill data if present (from Google Places lookup)\nif (item.domain) updatePayload.domain = item.domain;\nif (item.google_place_id) updatePayload.google_place_id = item.google_place_id;\nif (item.has_website) updatePayload.has_website = item.has_website;\nif (item.google_rating) updatePayload.google_rating = item.google_rating;\nif (item.google_review_count) updatePayload.google_review_count = item.google_review_count;\n\nreturn {\n  json: {\n    _company_id: item.id,\n    _update_payload: updatePayload,\n    // Pass through everything for social discovery\n    ...item\n  }\n};",
      "upstream_refs": [],
      "ref_methods": [],
      "code_lines": 28
    },
    {
      "name": "Update Company in Supabase",
      "id": "9b97ccfa-b2b0-4ba3-b39a-4764000b7d3a",
      "type": "httpRequest",
      "full_type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        6320,
        80
      ],
      "notes": "PATCH updates enrichment fields. Batched 10 at a time with 500ms delay to avoid overwhelming Supabase.",
      "onError": "continueRegularOutput",
      "mode": "",
      "incoming": [
        {
          "source": "Prepare Company Update",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Prepare Social Processing",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "http_method": "PATCH",
      "http_url": "={{ $env.SUPABASE_URL }}/rest/v1/companies?id=eq.{{ $json._company_id }}",
      "http_sendHeaders": true,
      "http_headers": [
        {
          "name": "apikey",
          "value": "={{ $env.SUPABASE_SERVICE_KEY }}"
        },
        {
          "name": "Authorization",
          "value": "=Bearer {{ $env.SUPABASE_SERVICE_KEY }}"
        },
        {
          "name": "Content-Type",
          "value": "application/json"
        },
        {
          "name": "Prefer",
          "value": "return=minimal"
        }
      ],
      "http_sendBody": true,
      "http_bodyType": "json",
      "http_jsonBody": "={{ JSON.stringify($json._update_payload) }}",
      "http_body": "",
      "http_options": {
        "batching": {
          "batch": {
            "batchSize": 10,
            "batchInterval": 500
          }
        }
      },
      "http_batching": {
        "batch": {
          "batchSize": 10,
          "batchInterval": 500
        }
      },
      "http_timeout": null,
      "http_sendQuery": false,
      "http_queryParams": []
    },
    {
      "name": "Prepare Social Processing",
      "id": "f17fc381-44bf-45a8-97c4-5a7bffa58763",
      "type": "code",
      "full_type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        6544,
        80
      ],
      "notes": "",
      "onError": "",
      "mode": "runOnceForEachItem",
      "incoming": [
        {
          "source": "Update Company in Supabase",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Has Social Links?",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "jsCode": "// Collect social links found from website analysis per company\n// and determine which companies need Apify social discovery\nconst item = $('Prepare Company Update').item.json;\nconst config = $('Enrichment Config').first().json;\nconst skipSocial = config.skip_social_discovery === 'true' || config.skip_social_discovery === true;\n\nconst socialLinks = item._social_links_found || [];\nconst needsDiscovery = item._needs_social_discovery && !skipSocial;\n\nreturn {\n  json: {\n    company_id: item.id,\n    company_name: item.name,\n    city: item.city,\n    state: item.state,\n    domain: item.domain,\n    social_links_found: socialLinks,\n    needs_social_discovery: needsDiscovery,\n    _skip_social: skipSocial\n  }\n};",
      "upstream_refs": [
        "Prepare Company Update",
        "Enrichment Config"
      ],
      "ref_methods": [
        {
          "node": "Prepare Company Update",
          "method": "item.json"
        },
        {
          "node": "Enrichment Config",
          "method": "first"
        }
      ],
      "code_lines": 21
    },
    {
      "name": "Has Social Links?",
      "id": "6e7ecb26-78a8-4895-b72e-cae1da3a00df",
      "type": "if",
      "full_type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        6768,
        80
      ],
      "notes": "",
      "onError": "",
      "mode": "",
      "incoming": [
        {
          "source": "Prepare Social Processing",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Prepare Social Profiles Insert",
          "output_idx": 0,
          "input_idx": 0
        },
        {
          "target": "Needs Social Discovery?",
          "output_idx": 1,
          "input_idx": 0
        }
      ],
      "if_conditions": {
        "options": {
          "caseSensitive": true,
          "leftValue": "",
          "typeValidation": "loose"
        },
        "conditions": [
          {
            "id": "has-social-links",
            "leftValue": "={{ $json.social_links_found.length }}",
            "rightValue": "0",
            "operator": {
              "type": "number",
              "operation": "gt"
            }
          }
        ],
        "combinator": "and"
      },
      "if_options": {}
    },
    {
      "name": "Needs Social Discovery?",
      "id": "97b32703-20c6-4a13-a6f7-ed2b49a31097",
      "type": "if",
      "full_type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        6992,
        160
      ],
      "notes": "",
      "onError": "",
      "mode": "",
      "incoming": [
        {
          "source": "Has Social Links?",
          "output_idx": 1,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Build Social Discovery Batch",
          "output_idx": 0,
          "input_idx": 0
        },
        {
          "target": "Run Summary1",
          "output_idx": 1,
          "input_idx": 0
        }
      ],
      "if_conditions": {
        "options": {
          "caseSensitive": true,
          "leftValue": "",
          "typeValidation": "loose"
        },
        "conditions": [
          {
            "id": "needs-discovery",
            "leftValue": "={{ $json.needs_social_discovery }}",
            "rightValue": true,
            "operator": {
              "type": "boolean",
              "operation": "equals",
              "singleValue": true
            }
          }
        ],
        "combinator": "and"
      },
      "if_options": {}
    },
    {
      "name": "Build Social Discovery Batch",
      "id": "25e99149-3f48-4929-8367-77d6d519c3f0",
      "type": "code",
      "full_type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        7216,
        352
      ],
      "notes": "",
      "onError": "",
      "mode": "",
      "incoming": [
        {
          "source": "Needs Social Discovery?",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Discovery Queries Exist?",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "jsCode": "// Collect all companies that need social discovery into a single batch for Apify\n// This node collects items from the loop and builds the search queries\nconst items = $input.all();\n\nconst searchQueries = [];\nconst companyMap = {};\n\nfor (const item of items) {\n  const data = item.json;\n  if (!data.company_name || !data.city) continue;\n  \n  const searchTerm = `${data.company_name} ${data.city} ${data.state || ''} massage`.trim();\n  searchQueries.push({\n    company_id: data.company_id,\n    company_name: data.company_name,\n    city: data.city,\n    state: data.state,\n    search_term: searchTerm\n  });\n}\n\nif (searchQueries.length === 0) {\n  return [{ json: { _no_social_discovery_needed: true, _count: 0 } }];\n}\n\nconsole.log(`Social discovery needed for ${searchQueries.length} companies`);\n\nreturn [{\n  json: {\n    _social_discovery_queries: searchQueries,\n    _count: searchQueries.length,\n    _no_social_discovery_needed: false\n  }\n}];",
      "upstream_refs": [],
      "ref_methods": [],
      "code_lines": 34
    },
    {
      "name": "Discovery Queries Exist?",
      "id": "58284816-3efb-4f6e-8a8d-6f3f3265dfbc",
      "type": "if",
      "full_type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        7440,
        352
      ],
      "notes": "",
      "onError": "",
      "mode": "",
      "incoming": [
        {
          "source": "Build Social Discovery Batch",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Prepare FB Search Input",
          "output_idx": 0,
          "input_idx": 0
        },
        {
          "target": "Prepare IG Search Input",
          "output_idx": 0,
          "input_idx": 0
        },
        {
          "target": "Run Summary1",
          "output_idx": 1,
          "input_idx": 0
        }
      ],
      "if_conditions": {
        "options": {
          "caseSensitive": true,
          "leftValue": "",
          "typeValidation": "loose"
        },
        "conditions": [
          {
            "id": "has-queries",
            "leftValue": "={{ $json._no_social_discovery_needed }}",
            "rightValue": true,
            "operator": {
              "type": "boolean",
              "operation": "notEquals"
            }
          }
        ],
        "combinator": "and"
      },
      "if_options": {}
    },
    {
      "name": "Prepare FB Search Input",
      "id": "7b641251-6e69-4b6a-938b-c620cb2b3411",
      "type": "code",
      "full_type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        7664,
        160
      ],
      "notes": "",
      "onError": "",
      "mode": "",
      "incoming": [
        {
          "source": "Discovery Queries Exist?",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Start FB Search Run",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "jsCode": "// Build the Apify Facebook Search Scraper input\n// Actor: apify/facebook-search-scraper\n// Input fields: categories (array of search terms), locations (array), resultsLimit (number)\nconst data = $input.first().json;\nconst queries = data._social_discovery_queries || [];\n\n// Build category search terms: \"CompanyName City\" for each company\nconst categories = queries.map(q => \n  `${q.company_name} ${q.city}`.trim()\n).slice(0, 100);\n\n// Get unique locations in \"City, State\" format\nconst locations = [...new Set(\n  queries.map(q => `${q.city}, ${q.state}`.trim()).filter(l => l !== ',')\n)];\n\nreturn [{\n  json: {\n    _queries: queries,\n    _apify_input: {\n      categories: categories,\n      locations: locations,\n      resultsLimit: 3\n    }\n  }\n}];",
      "upstream_refs": [],
      "ref_methods": [],
      "code_lines": 26
    },
    {
      "name": "Prepare IG Search Input",
      "id": "e66efe26-7960-4cc6-ae76-73360b4877c7",
      "type": "code",
      "full_type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        7664,
        560
      ],
      "notes": "",
      "onError": "",
      "mode": "",
      "incoming": [
        {
          "source": "Discovery Queries Exist?",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Start IG Search Run",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "jsCode": "// Build the Apify Instagram Search Scraper input\n// Actor: apify/instagram-search-scraper\n// Input fields: search (single string), searchType (string), searchLimit (number),\n//               enhanceUserSearchWithFacebookPage (boolean)\n//\n// LIMITATION: IG Search Scraper takes ONE search string per run.\n// Strategy: We search for \"massage therapy [city] [state]\" to find local businesses,\n// then match results back to individual companies.\nconst data = $input.first().json;\nconst queries = data._social_discovery_queries || [];\n\nif (queries.length === 0) {\n  return [{ json: { _queries: queries, _apify_input: {}, _ig_skip: true } }];\n}\n\n// Get the most common city from the batch (they're likely all the same metro)\nconst cityCounts = {};\nfor (const q of queries) {\n  const loc = `${q.city} ${q.state}`.trim();\n  cityCounts[loc] = (cityCounts[loc] || 0) + 1;\n}\nconst primaryCity = Object.entries(cityCounts).sort((a, b) => b[1] - a[1])[0][0];\n\nreturn [{\n  json: {\n    _queries: queries,\n    _apify_input: {\n      search: `massage therapy ${primaryCity}`,\n      searchType: \"user\",\n      searchLimit: Math.min(queries.length * 2, 50),\n      enhanceUserSearchWithFacebookPage: false\n    },\n    _ig_skip: false\n  }\n}];",
      "upstream_refs": [],
      "ref_methods": [],
      "code_lines": 35
    },
    {
      "name": "Start FB Search Run",
      "id": "17bef2d1-a06d-4684-a9ad-2dbb04a60fc1",
      "type": "httpRequest",
      "full_type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        7888,
        160
      ],
      "notes": "Starts the Apify Facebook Search Scraper actor to find Facebook pages for companies without social links.",
      "onError": "continueRegularOutput",
      "mode": "",
      "incoming": [
        {
          "source": "Prepare FB Search Input",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Extract FB Run ID",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "http_method": "POST",
      "http_url": "=https://api.apify.com/v2/actor-tasks/uplifted_veranda~facebook-search-scraper-task/runs?token={{ $env.APIFY_API_TOKEN }}",
      "http_sendHeaders": true,
      "http_headers": [
        {
          "name": "Content-Type",
          "value": "application/json"
        }
      ],
      "http_sendBody": true,
      "http_bodyType": "json",
      "http_jsonBody": "={{ JSON.stringify($json._apify_input) }}",
      "http_body": "",
      "http_options": {
        "timeout": 30000
      },
      "http_batching": null,
      "http_timeout": 30000,
      "http_sendQuery": false,
      "http_queryParams": []
    },
    {
      "name": "Start IG Search Run",
      "id": "49d3af95-5128-486f-8022-a7a4f80c14db",
      "type": "httpRequest",
      "full_type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        7888,
        560
      ],
      "notes": "Starts the Apify Instagram Search Scraper actor to discover Instagram profiles.",
      "onError": "continueRegularOutput",
      "mode": "",
      "incoming": [
        {
          "source": "Prepare IG Search Input",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Extract IG Run ID",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "http_method": "POST",
      "http_url": "=https://api.apify.com/v2/actor-tasks/uplifted_veranda~instagram-search-scraper-task/runs?token={{ $env.APIFY_API_TOKEN }}",
      "http_sendHeaders": true,
      "http_headers": [
        {
          "name": "Content-Type",
          "value": "application/json"
        }
      ],
      "http_sendBody": true,
      "http_bodyType": "json",
      "http_jsonBody": "={{ JSON.stringify($json._apify_input) }}",
      "http_body": "",
      "http_options": {
        "timeout": 30000
      },
      "http_batching": null,
      "http_timeout": 30000,
      "http_sendQuery": false,
      "http_queryParams": []
    },
    {
      "name": "Extract FB Run ID",
      "id": "152148a5-b362-4fe2-8352-b04c1b585da1",
      "type": "code",
      "full_type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        8112,
        160
      ],
      "notes": "",
      "onError": "",
      "mode": "",
      "incoming": [
        {
          "source": "Start FB Search Run",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Wait FB 30s",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "jsCode": "const response = $input.first().json;\nconst queries = $('Prepare FB Search Input').first().json._queries;\nlet runId = '';\nlet datasetId = '';\n\nif (response.data) {\n  runId = response.data.id || '';\n  datasetId = response.data.defaultDatasetId || '';\n}\n\nif (!runId) {\n  console.log('Facebook Search: Failed to start run. Response:', JSON.stringify(response).substring(0, 500));\n  return [{ json: { _fb_search_failed: true, _fb_error: 'Failed to start Apify run', _queries: queries, runId: '', datasetId: '' } }];\n}\n\nreturn [{ json: { runId, datasetId, pollCount: 0, _queries: queries, _fb_search_failed: false } }];",
      "upstream_refs": [
        "Prepare FB Search Input"
      ],
      "ref_methods": [
        {
          "node": "Prepare FB Search Input",
          "method": "first"
        }
      ],
      "code_lines": 16
    },
    {
      "name": "Extract IG Run ID",
      "id": "dc1c5f7d-9c8d-4aa4-bd1d-ef691c52a502",
      "type": "code",
      "full_type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        8112,
        560
      ],
      "notes": "",
      "onError": "",
      "mode": "",
      "incoming": [
        {
          "source": "Start IG Search Run",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Wait IG 30s",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "jsCode": "const response = $input.first().json;\nconst prevInput = $('Prepare IG Search Input').first().json;\nconst queries = prevInput._queries;\n\n// If we skipped IG search\nif (prevInput._ig_skip) {\n  return [{ json: { _ig_search_failed: true, _ig_error: 'No queries - skipped', _queries: queries, runId: '', datasetId: '' } }];\n}\n\nlet runId = '';\nlet datasetId = '';\n\nif (response.data) {\n  runId = response.data.id || '';\n  datasetId = response.data.defaultDatasetId || '';\n}\n\nif (!runId) {\n  console.log('Instagram Search: Failed to start run. Response:', JSON.stringify(response).substring(0, 500));\n  return [{ json: { _ig_search_failed: true, _ig_error: 'Failed to start Apify run', _queries: queries, runId: '', datasetId: '' } }];\n}\n\nreturn [{ json: { runId, datasetId, pollCount: 0, _queries: queries, _ig_search_failed: false } }];",
      "upstream_refs": [
        "Prepare IG Search Input"
      ],
      "ref_methods": [
        {
          "node": "Prepare IG Search Input",
          "method": "first"
        }
      ],
      "code_lines": 23
    },
    {
      "name": "Wait FB 30s",
      "id": "a0d0b945-877d-42a7-8fab-eca127e9c147",
      "type": "wait",
      "full_type": "n8n-nodes-base.wait",
      "typeVersion": 1.1,
      "position": [
        8336,
        160
      ],
      "notes": "",
      "onError": "",
      "mode": "",
      "incoming": [
        {
          "source": "Extract FB Run ID",
          "output_idx": 0,
          "input_idx": 0
        },
        {
          "source": "FB Run Succeeded?",
          "output_idx": 1,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Check FB Run Status",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "wait_amount": 30,
      "wait_unit": ""
    },
    {
      "name": "Wait IG 30s",
      "id": "b37458e1-f239-4bdc-b8c9-5c7bdd0b4c67",
      "type": "wait",
      "full_type": "n8n-nodes-base.wait",
      "typeVersion": 1.1,
      "position": [
        8336,
        560
      ],
      "notes": "",
      "onError": "",
      "mode": "",
      "incoming": [
        {
          "source": "Extract IG Run ID",
          "output_idx": 0,
          "input_idx": 0
        },
        {
          "source": "IG Run Succeeded?",
          "output_idx": 1,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Check IG Run Status",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "wait_amount": 30,
      "wait_unit": ""
    },
    {
      "name": "Check FB Run Status",
      "id": "df0b23b8-9d22-47ca-9fc1-822fd4eae973",
      "type": "httpRequest",
      "full_type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        8560,
        80
      ],
      "notes": "",
      "onError": "",
      "mode": "",
      "incoming": [
        {
          "source": "Wait FB 30s",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Parse FB Status",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "http_method": "GET",
      "http_url": "=https://api.apify.com/v2/actor-runs/{{ $('Extract FB Run ID').first().json.runId }}?token={{ $env.APIFY_API_TOKEN }}",
      "http_sendHeaders": false,
      "http_headers": [],
      "http_sendBody": false,
      "http_bodyType": "",
      "http_jsonBody": "",
      "http_body": "",
      "http_options": {
        "timeout": 15000
      },
      "http_batching": null,
      "http_timeout": 15000,
      "http_sendQuery": false,
      "http_queryParams": []
    },
    {
      "name": "Check IG Run Status",
      "id": "9b8b4707-4e41-4498-864c-54d6675e88ef",
      "type": "httpRequest",
      "full_type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        8560,
        496
      ],
      "notes": "",
      "onError": "",
      "mode": "",
      "incoming": [
        {
          "source": "Wait IG 30s",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Parse IG Status",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "http_method": "GET",
      "http_url": "=https://api.apify.com/v2/actor-runs/{{ $('Extract IG Run ID').first().json.runId }}?token={{ $env.APIFY_API_TOKEN }}",
      "http_sendHeaders": false,
      "http_headers": [],
      "http_sendBody": false,
      "http_bodyType": "",
      "http_jsonBody": "",
      "http_body": "",
      "http_options": {
        "timeout": 15000
      },
      "http_batching": null,
      "http_timeout": 15000,
      "http_sendQuery": false,
      "http_queryParams": []
    },
    {
      "name": "Parse FB Status",
      "id": "20eae18e-ad5c-4e22-b28d-1867e4c9146c",
      "type": "code",
      "full_type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        8784,
        80
      ],
      "notes": "",
      "onError": "",
      "mode": "",
      "incoming": [
        {
          "source": "Check FB Run Status",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "FB Run Succeeded?",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "jsCode": "const response = $input.first().json;\nconst prevData = $('Extract FB Run ID').first().json;\n\nlet status = 'UNKNOWN';\nlet datasetId = prevData.datasetId || '';\n\nif (response.data && response.data.status) {\n  status = response.data.status;\n  if (response.data.defaultDatasetId) datasetId = response.data.defaultDatasetId;\n}\n\nlet pollCount = 0;\ntry {\n  pollCount = $('Parse FB Status').first().json.pollCount || 0;\n} catch(e) {\n  pollCount = prevData.pollCount || 0;\n}\npollCount++;\n\n// Timeout after 20 polls (10 minutes)\nif (pollCount > 20 && status !== 'SUCCEEDED' && status !== 'FAILED') {\n  status = 'TIMED_OUT';\n}\n\nreturn [{ json: { runId: prevData.runId, datasetId, pollCount, status, _queries: prevData._queries } }];",
      "upstream_refs": [
        "Extract FB Run ID",
        "Parse FB Status"
      ],
      "ref_methods": [
        {
          "node": "Extract FB Run ID",
          "method": "first"
        },
        {
          "node": "Parse FB Status",
          "method": "first"
        }
      ],
      "code_lines": 25
    },
    {
      "name": "Parse IG Status",
      "id": "aff1678f-bc7e-4b4b-b2c3-42b8053f9afa",
      "type": "code",
      "full_type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        8784,
        496
      ],
      "notes": "",
      "onError": "",
      "mode": "",
      "incoming": [
        {
          "source": "Check IG Run Status",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "IG Run Succeeded?",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "jsCode": "const response = $input.first().json;\nconst prevData = $('Extract IG Run ID').first().json;\n\nlet status = 'UNKNOWN';\nlet datasetId = prevData.datasetId || '';\n\nif (response.data && response.data.status) {\n  status = response.data.status;\n  if (response.data.defaultDatasetId) datasetId = response.data.defaultDatasetId;\n}\n\nlet pollCount = 0;\ntry {\n  pollCount = $('Parse IG Status').first().json.pollCount || 0;\n} catch(e) {\n  pollCount = prevData.pollCount || 0;\n}\npollCount++;\n\nif (pollCount > 20 && status !== 'SUCCEEDED' && status !== 'FAILED') {\n  status = 'TIMED_OUT';\n}\n\nreturn [{ json: { runId: prevData.runId, datasetId, pollCount, status, _queries: prevData._queries } }];",
      "upstream_refs": [
        "Parse IG Status",
        "Extract IG Run ID"
      ],
      "ref_methods": [
        {
          "node": "Extract IG Run ID",
          "method": "first"
        },
        {
          "node": "Parse IG Status",
          "method": "first"
        }
      ],
      "code_lines": 24
    },
    {
      "name": "FB Run Succeeded?",
      "id": "c06e0c3d-b66f-432f-acbf-7422a881a76f",
      "type": "if",
      "full_type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        9008,
        160
      ],
      "notes": "",
      "onError": "",
      "mode": "",
      "incoming": [
        {
          "source": "Parse FB Status",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Fetch FB Search Results",
          "output_idx": 0,
          "input_idx": 0
        },
        {
          "target": "Wait FB 30s",
          "output_idx": 1,
          "input_idx": 0
        }
      ],
      "if_conditions": {
        "options": {
          "caseSensitive": true,
          "leftValue": "",
          "typeValidation": "loose"
        },
        "conditions": [
          {
            "id": "fb-succeeded",
            "leftValue": "={{ $json.status }}",
            "rightValue": "SUCCEEDED",
            "operator": {
              "type": "string",
              "operation": "equals"
            }
          }
        ],
        "combinator": "and"
      },
      "if_options": {}
    },
    {
      "name": "IG Run Succeeded?",
      "id": "481255bb-e6d5-4ea2-9395-af4e2c3761bd",
      "type": "if",
      "full_type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        9008,
        560
      ],
      "notes": "",
      "onError": "",
      "mode": "",
      "incoming": [
        {
          "source": "Parse IG Status",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Fetch IG Search Results",
          "output_idx": 0,
          "input_idx": 0
        },
        {
          "target": "Wait IG 30s",
          "output_idx": 1,
          "input_idx": 0
        }
      ],
      "if_conditions": {
        "options": {
          "caseSensitive": true,
          "leftValue": "",
          "typeValidation": "loose"
        },
        "conditions": [
          {
            "id": "ig-succeeded",
            "leftValue": "={{ $json.status }}",
            "rightValue": "SUCCEEDED",
            "operator": {
              "type": "string",
              "operation": "equals"
            }
          }
        ],
        "combinator": "and"
      },
      "if_options": {}
    },
    {
      "name": "Fetch FB Search Results",
      "id": "ba4202f9-977e-4d37-beeb-1d9bc7608de7",
      "type": "httpRequest",
      "full_type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        9232,
        160
      ],
      "notes": "",
      "onError": "",
      "mode": "",
      "incoming": [
        {
          "source": "FB Run Succeeded?",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Match FB Results to Companies",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "http_method": "GET",
      "http_url": "=https://api.apify.com/v2/datasets/{{ $json.datasetId }}/items?token={{ $env.APIFY_API_TOKEN }}",
      "http_sendHeaders": false,
      "http_headers": [],
      "http_sendBody": false,
      "http_bodyType": "",
      "http_jsonBody": "",
      "http_body": "",
      "http_options": {
        "timeout": 60000
      },
      "http_batching": null,
      "http_timeout": 60000,
      "http_sendQuery": false,
      "http_queryParams": []
    },
    {
      "name": "Fetch IG Search Results",
      "id": "758fa719-c717-403e-8667-df45c89b9852",
      "type": "httpRequest",
      "full_type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        9232,
        560
      ],
      "notes": "",
      "onError": "",
      "mode": "",
      "incoming": [
        {
          "source": "IG Run Succeeded?",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Match IG Results to Companies",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "http_method": "GET",
      "http_url": "=https://api.apify.com/v2/datasets/{{ $json.datasetId }}/items?token={{ $env.APIFY_API_TOKEN }}",
      "http_sendHeaders": false,
      "http_headers": [],
      "http_sendBody": false,
      "http_bodyType": "",
      "http_jsonBody": "",
      "http_body": "",
      "http_options": {
        "timeout": 60000
      },
      "http_batching": null,
      "http_timeout": 60000,
      "http_sendQuery": false,
      "http_queryParams": []
    },
    {
      "name": "Match FB Results to Companies",
      "id": "15e16620-9338-47e9-be5e-64f690fbb4ab",
      "type": "code",
      "full_type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        9456,
        160
      ],
      "notes": "",
      "onError": "",
      "mode": "",
      "incoming": [
        {
          "source": "Fetch FB Search Results",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "FB Matches Found?",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "jsCode": "// Match Facebook search results back to companies and build social_profiles rows\nconst results = $input.first().json;\nconst queries = $('Extract FB Run ID').first().json._queries || [];\n\n// results should be an array of Facebook page results\nconst fbPages = Array.isArray(results) ? results : [results];\n\nconst socialRows = [];\nconst matchLog = [];\n\nfor (const query of queries) {\n  const companyNameLower = (query.company_name || '').toLowerCase();\n  const cityLower = (query.city || '').toLowerCase();\n\n  let bestMatch = null;\n  let bestScore = 0;\n\n  for (const page of fbPages) {\n    // FB Search Scraper output fields: title, description, url, address, email, \n    // website, phone, likes, checkins, categories, messenger, adStatus\n    const pageName = (page.title || page.name || '').toLowerCase();\n    const pageAddress = (page.address || '').toLowerCase();\n    const pageDescription = (page.description || '').toLowerCase();\n    \n    // Score based on name similarity\n    const companyWords = companyNameLower.split(/\\s+/).filter(w => w.length > 2);\n    const matchingWords = companyWords.filter(w => pageName.includes(w));\n    let score = companyWords.length > 0 ? matchingWords.length / companyWords.length : 0;\n    \n    // Bonus for city match in address or description\n    if (cityLower && (pageAddress.includes(cityLower) || pageDescription.includes(cityLower))) {\n      score += 0.2;\n    }\n    \n    // Bonus for massage/spa/therapy keywords\n    const relevantKeywords = ['massage', 'spa', 'therapy', 'therapist', 'bodywork', 'wellness'];\n    const pageText = `${pageName} ${pageDescription} ${(page.categories || []).join(' ')}`.toLowerCase();\n    if (relevantKeywords.some(kw => pageText.includes(kw))) {\n      score += 0.15;\n    }\n    \n    if (score > bestScore && score >= 0.5) {\n      bestScore = score;\n      bestMatch = page;\n    }\n  }\n\n  if (bestMatch) {\n    const pageUrl = bestMatch.url || bestMatch.facebookUrl || '';\n    if (pageUrl) {\n      socialRows.push({\n        company_id: query.company_id,\n        platform: 'facebook',\n        profile_url: pageUrl,\n        follower_count: bestMatch.likes || bestMatch.followers || null,\n        post_count: null,\n        last_post_date: null,\n        scraped_at: new Date().toISOString()\n      });\n      matchLog.push({ \n        company: query.company_name, \n        matched_to: bestMatch.title || bestMatch.name, \n        score: bestScore,\n        fb_url: pageUrl\n      });\n    }\n  }\n}\n\nconsole.log(`Facebook discovery: ${socialRows.length} matches from ${fbPages.length} results for ${queries.length} queries`);\n\nreturn [{\n  json: {\n    _fb_social_rows: socialRows,\n    _fb_match_count: socialRows.length,\n    _fb_total_results: fbPages.length,\n    _match_log: matchLog\n  }\n}];",
      "upstream_refs": [
        "Extract FB Run ID"
      ],
      "ref_methods": [
        {
          "node": "Extract FB Run ID",
          "method": "first"
        }
      ],
      "code_lines": 79
    },
    {
      "name": "Match IG Results to Companies",
      "id": "f7b92b32-496f-4d9a-a5c5-1d20e7e75751",
      "type": "code",
      "full_type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        9456,
        560
      ],
      "notes": "",
      "onError": "",
      "mode": "",
      "incoming": [
        {
          "source": "Fetch IG Search Results",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "IG Matches Found?",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "jsCode": "// Match Instagram search results back to companies\nconst results = $input.first().json;\nconst queries = $('Extract IG Run ID').first().json._queries || [];\n\n// IG Search Scraper returns profiles with fields like:\n// username, fullName, biography, followersCount, followsCount, \n// postsCount, isBusinessAccount, profilePicUrl, externalUrl, etc.\nconst igProfiles = Array.isArray(results) ? results : [results];\n\nconst socialRows = [];\nconst matchLog = [];\n\nfor (const query of queries) {\n  const companyNameLower = (query.company_name || '').toLowerCase().replace(/[^a-z0-9\\s]/g, '');\n  const cityLower = (query.city || '').toLowerCase();\n\n  let bestMatch = null;\n  let bestScore = 0;\n\n  for (const profile of igProfiles) {\n    const profileName = (profile.fullName || profile.name || '').toLowerCase().replace(/[^a-z0-9\\s]/g, '');\n    const profileBio = (profile.biography || profile.bio || '').toLowerCase();\n    const username = (profile.username || '').toLowerCase();\n    \n    // Score based on name similarity\n    const companyWords = companyNameLower.split(/\\s+/).filter(w => w.length > 2);\n    const matchingWords = companyWords.filter(w => \n      profileName.includes(w) || username.includes(w)\n    );\n    let score = companyWords.length > 0 ? matchingWords.length / companyWords.length : 0;\n    \n    // Bonus for city mention in bio\n    if (cityLower && profileBio.includes(cityLower)) score += 0.2;\n    \n    // Bonus for massage/spa/therapy keywords in bio or name\n    const relevantKeywords = ['massage', 'spa', 'therapy', 'therapist', 'bodywork', 'wellness', 'rmt'];\n    if (relevantKeywords.some(kw => profileBio.includes(kw) || profileName.includes(kw))) score += 0.15;\n    \n    // Bonus for business account\n    const isBusinessAccount = profile.isBusinessAccount || profile.isBusiness || false;\n    if (isBusinessAccount) score += 0.1;\n    \n    if (score > bestScore && score >= 0.5) {\n      bestScore = score;\n      bestMatch = profile;\n    }\n  }\n\n  if (bestMatch) {\n    const profileUrl = bestMatch.url || bestMatch.profileUrl || \n      (bestMatch.username ? `https://www.instagram.com/${bestMatch.username}` : '');\n    \n    if (profileUrl) {\n      socialRows.push({\n        company_id: query.company_id,\n        platform: 'instagram',\n        profile_url: profileUrl,\n        follower_count: bestMatch.followersCount || bestMatch.followers || null,\n        post_count: bestMatch.postsCount || bestMatch.posts || null,\n        last_post_date: null,\n        scraped_at: new Date().toISOString()\n      });\n      matchLog.push({ \n        company: query.company_name, \n        matched_to: bestMatch.username || bestMatch.fullName, \n        score: bestScore \n      });\n    }\n  }\n}\n\nconsole.log(`Instagram discovery: ${socialRows.length} matches from ${igProfiles.length} results for ${queries.length} queries`);\n\nreturn [{\n  json: {\n    _ig_social_rows: socialRows,\n    _ig_match_count: socialRows.length,\n    _ig_total_results: igProfiles.length,\n    _match_log: matchLog\n  }\n}];",
      "upstream_refs": [
        "Extract IG Run ID"
      ],
      "ref_methods": [
        {
          "node": "Extract IG Run ID",
          "method": "first"
        }
      ],
      "code_lines": 81
    },
    {
      "name": "Prepare Social Profiles Insert",
      "id": "e20e550b-ceca-44e3-a711-6df8570fc40c",
      "type": "code",
      "full_type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        9680,
        -208
      ],
      "notes": "",
      "onError": "",
      "mode": "runOnceForEachItem",
      "incoming": [
        {
          "source": "Has Social Links?",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Insert Social Profiles",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "jsCode": "// Insert social profiles found from website HTML into Supabase social_profiles table\nconst item = $input.item.json;\nconst links = item.social_links_found || [];\n\nif (links.length === 0) {\n  return { json: { _social_inserts: 0, company_id: item.company_id } };\n}\n\n// Build an array of social_profiles rows\nconst rows = links.map(link => ({\n  company_id: item.company_id,\n  platform: link.platform,\n  profile_url: link.url,\n  follower_count: null,\n  post_count: null,\n  last_post_date: null,\n  scraped_at: new Date().toISOString()\n}));\n\nreturn {\n  json: {\n    _social_rows: rows,\n    _social_inserts: rows.length,\n    company_id: item.company_id,\n    company_name: item.company_name,\n    city: item.city,\n    state: item.state,\n    needs_social_discovery: false\n  }\n};",
      "upstream_refs": [],
      "ref_methods": [],
      "code_lines": 30
    },
    {
      "name": "FB Matches Found?",
      "id": "9842146d-9b9b-487d-b4d5-4d7ea725847d",
      "type": "if",
      "full_type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        9680,
        160
      ],
      "notes": "",
      "onError": "",
      "mode": "",
      "incoming": [
        {
          "source": "Match FB Results to Companies",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Insert FB Social Profiles",
          "output_idx": 0,
          "input_idx": 0
        },
        {
          "target": "Run Summary1",
          "output_idx": 1,
          "input_idx": 0
        }
      ],
      "if_conditions": {
        "options": {
          "caseSensitive": true,
          "leftValue": "",
          "typeValidation": "loose"
        },
        "conditions": [
          {
            "id": "has-fb-results",
            "leftValue": "={{ $json._fb_match_count }}",
            "rightValue": "0",
            "operator": {
              "type": "number",
              "operation": "gt"
            }
          }
        ],
        "combinator": "and"
      },
      "if_options": {}
    },
    {
      "name": "IG Matches Found?",
      "id": "bf0ceda0-9949-4350-b7ff-3f72b8ae0146",
      "type": "if",
      "full_type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        9680,
        560
      ],
      "notes": "",
      "onError": "",
      "mode": "",
      "incoming": [
        {
          "source": "Match IG Results to Companies",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Insert IG Social Profiles",
          "output_idx": 0,
          "input_idx": 0
        },
        {
          "target": "Run Summary1",
          "output_idx": 1,
          "input_idx": 0
        }
      ],
      "if_conditions": {
        "options": {
          "caseSensitive": true,
          "leftValue": "",
          "typeValidation": "loose"
        },
        "conditions": [
          {
            "id": "has-ig-results",
            "leftValue": "={{ $json._ig_match_count }}",
            "rightValue": "0",
            "operator": {
              "type": "number",
              "operation": "gt"
            }
          }
        ],
        "combinator": "and"
      },
      "if_options": {}
    },
    {
      "name": "Insert Social Profiles",
      "id": "7b30136a-98cb-40ed-882d-0cea80678bdb",
      "type": "httpRequest",
      "full_type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        9904,
        -208
      ],
      "notes": "Inserts social profiles found from website HTML. Uses merge-duplicates to handle re-runs gracefully.",
      "onError": "continueRegularOutput",
      "mode": "",
      "incoming": [
        {
          "source": "Prepare Social Profiles Insert",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Run Summary1",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "http_method": "POST",
      "http_url": "={{ $env.SUPABASE_URL }}/rest/v1/social_profiles",
      "http_sendHeaders": true,
      "http_headers": [
        {
          "name": "apikey",
          "value": "={{ $env.SUPABASE_SERVICE_KEY }}"
        },
        {
          "name": "Authorization",
          "value": "=Bearer {{ $env.SUPABASE_SERVICE_KEY }}"
        },
        {
          "name": "Content-Type",
          "value": "application/json"
        },
        {
          "name": "Prefer",
          "value": "resolution=merge-duplicates,return=minimal"
        }
      ],
      "http_sendBody": true,
      "http_bodyType": "json",
      "http_jsonBody": "={{ JSON.stringify($json._social_rows) }}",
      "http_body": "",
      "http_options": {},
      "http_batching": null,
      "http_timeout": null,
      "http_sendQuery": false,
      "http_queryParams": []
    },
    {
      "name": "Insert FB Social Profiles",
      "id": "7bc9a0bd-2451-4798-9b92-2cf0c0854c73",
      "type": "httpRequest",
      "full_type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        9904,
        80
      ],
      "notes": "",
      "onError": "continueRegularOutput",
      "mode": "",
      "incoming": [
        {
          "source": "FB Matches Found?",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Run Summary1",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "http_method": "POST",
      "http_url": "={{ $env.SUPABASE_URL }}/rest/v1/social_profiles",
      "http_sendHeaders": true,
      "http_headers": [
        {
          "name": "apikey",
          "value": "={{ $env.SUPABASE_SERVICE_KEY }}"
        },
        {
          "name": "Authorization",
          "value": "=Bearer {{ $env.SUPABASE_SERVICE_KEY }}"
        },
        {
          "name": "Content-Type",
          "value": "application/json"
        },
        {
          "name": "Prefer",
          "value": "resolution=merge-duplicates,return=minimal"
        }
      ],
      "http_sendBody": true,
      "http_bodyType": "json",
      "http_jsonBody": "={{ JSON.stringify($json._fb_social_rows) }}",
      "http_body": "",
      "http_options": {},
      "http_batching": null,
      "http_timeout": null,
      "http_sendQuery": false,
      "http_queryParams": []
    },
    {
      "name": "Insert IG Social Profiles",
      "id": "d88536f0-ec38-472e-9d2f-e270b5943133",
      "type": "httpRequest",
      "full_type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        9904,
        640
      ],
      "notes": "",
      "onError": "continueRegularOutput",
      "mode": "",
      "incoming": [
        {
          "source": "IG Matches Found?",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Run Summary1",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "http_method": "POST",
      "http_url": "={{ $env.SUPABASE_URL }}/rest/v1/social_profiles",
      "http_sendHeaders": true,
      "http_headers": [
        {
          "name": "apikey",
          "value": "={{ $env.SUPABASE_SERVICE_KEY }}"
        },
        {
          "name": "Authorization",
          "value": "=Bearer {{ $env.SUPABASE_SERVICE_KEY }}"
        },
        {
          "name": "Content-Type",
          "value": "application/json"
        },
        {
          "name": "Prefer",
          "value": "resolution=merge-duplicates,return=minimal"
        }
      ],
      "http_sendBody": true,
      "http_bodyType": "json",
      "http_jsonBody": "={{ JSON.stringify($json._ig_social_rows) }}",
      "http_body": "",
      "http_options": {},
      "http_batching": null,
      "http_timeout": null,
      "http_sendQuery": false,
      "http_queryParams": []
    },
    {
      "name": "Run Summary1",
      "id": "46071282-354b-4219-9f62-61cdb9ce9704",
      "type": "code",
      "full_type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        10128,
        224
      ],
      "notes": "Final summary of the enrichment batch. Shows stats for websites analyzed, booking/ads detected, social profiles found. Provides next_offset for continuing with next batch.",
      "onError": "",
      "mode": "",
      "incoming": [
        {
          "source": "Insert Social Profiles",
          "output_idx": 0,
          "input_idx": 0
        },
        {
          "source": "Needs Social Discovery?",
          "output_idx": 1,
          "input_idx": 0
        },
        {
          "source": "Discovery Queries Exist?",
          "output_idx": 1,
          "input_idx": 0
        },
        {
          "source": "FB Matches Found?",
          "output_idx": 1,
          "input_idx": 0
        },
        {
          "source": "Insert FB Social Profiles",
          "output_idx": 0,
          "input_idx": 0
        },
        {
          "source": "IG Matches Found?",
          "output_idx": 1,
          "input_idx": 0
        },
        {
          "source": "Insert IG Social Profiles",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Bridge to 3b",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "jsCode": "// Final summary of the enrichment batch run\nconst config = $('Enrichment Config').first().json;\n\n// Collect stats from various paths\nlet companiesProcessed = 0;\nlet websitesFetched = 0;\nlet websiteErrors = 0;\nlet bookingDetected = 0;\nlet paidAdsDetected = 0;\nlet socialFromWebsite = 0;\nlet fbDiscovered = 0;\nlet igDiscovered = 0;\n\ntry {\n  const batchItems = $('Parse Batch').all();\n  companiesProcessed = batchItems.filter(i => !i.json._empty).length;\n} catch(e) {}\n\ntry {\n  const websiteItems = $('Analyze Website HTML').all();\n  for (const item of websiteItems) {\n    const enrichment = item.json._website_enrichment || {};\n    if (enrichment._website_fetch_status === 'success') websitesFetched++;\n    if (enrichment._website_fetch_status === 'error') websiteErrors++;\n    if (enrichment.has_online_booking) bookingDetected++;\n    if (enrichment.has_paid_ads) paidAdsDetected++;\n    socialFromWebsite += (enrichment.social_links_found || []).length;\n  }\n} catch(e) {}\n\ntry {\n  const fbResults = $('Match FB Results to Companies').first().json;\n  fbDiscovered = fbResults._fb_match_count || 0;\n} catch(e) {}\n\ntry {\n  const igResults = $('Match IG Results to Companies').first().json;\n  igDiscovered = igResults._ig_match_count || 0;\n} catch(e) {}\n\nconst summary = {\n  run_completed_at: new Date().toISOString(),\n  batch_size: config.batch_size,\n  batch_offset: config.batch_offset,\n  companies_processed: companiesProcessed,\n  websites_fetched_successfully: websitesFetched,\n  website_fetch_errors: websiteErrors,\n  booking_platforms_detected: bookingDetected,\n  paid_ads_detected: paidAdsDetected,\n  social_links_from_websites: socialFromWebsite,\n  facebook_pages_discovered: fbDiscovered,\n  instagram_profiles_discovered: igDiscovered,\n  total_social_profiles_created: socialFromWebsite + fbDiscovered + igDiscovered,\n  next_offset: Number(config.batch_offset) + Number(config.batch_size),\n  message: `Enriched ${companiesProcessed} companies. Update batch_offset to ${Number(config.batch_offset) + Number(config.batch_size)} for next run.`\n};\n\nconsole.log('=== ENRICHMENT RUN SUMMARY ===');\nconsole.log(JSON.stringify(summary, null, 2));\n\nreturn [{ json: summary }];",
      "upstream_refs": [
        "Match FB Results to Companies",
        "Parse Batch",
        "Enrichment Config",
        "Analyze Website HTML",
        "Match IG Results to Companies"
      ],
      "ref_methods": [
        {
          "node": "Enrichment Config",
          "method": "first"
        },
        {
          "node": "Parse Batch",
          "method": "all"
        },
        {
          "node": "Analyze Website HTML",
          "method": "all"
        },
        {
          "node": "Match FB Results to Companies",
          "method": "first"
        },
        {
          "node": "Match IG Results to Companies",
          "method": "first"
        }
      ],
      "code_lines": 61
    },
    {
      "name": "Bridge to 3b",
      "id": "2a665506-3509-4c42-a017-2d6b0820960d",
      "type": "code",
      "full_type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        10336,
        224
      ],
      "notes": "",
      "onError": "",
      "mode": "",
      "incoming": [
        {
          "source": "Run Summary1",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Step 3b Config",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "jsCode": "// Collapse all input items into a single trigger item for the next step\nreturn [{ json: { _trigger: 'continue', _timestamp: new Date().toISOString() } }];",
      "upstream_refs": [],
      "ref_methods": [],
      "code_lines": 2
    },
    {
      "name": "Step 3b Config",
      "id": "752befe7-4985-41af-aa6b-c59a10c6d8be",
      "type": "set",
      "full_type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        10560,
        224
      ],
      "notes": "CONFIGURE: batch_size = how many social profiles to process. Set skip_<platform> to 'true' to skip that platform.",
      "onError": "",
      "mode": "",
      "incoming": [
        {
          "source": "Bridge to 3b",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Fetch Unenriched Social Profiles",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "set_assignments": [
        {
          "id": "batch-size",
          "name": "batch_size",
          "value": "100",
          "type": "string"
        },
        {
          "id": "batch-offset",
          "name": "batch_offset",
          "value": "0",
          "type": "string"
        },
        {
          "id": "skip-instagram",
          "name": "skip_instagram",
          "value": "false",
          "type": "string"
        },
        {
          "id": "skip-facebook",
          "name": "skip_facebook",
          "value": "false",
          "type": "string"
        },
        {
          "id": "skip-tiktok",
          "name": "skip_tiktok",
          "value": "false",
          "type": "string"
        },
        {
          "id": "skip-twitter",
          "name": "skip_twitter",
          "value": "false",
          "type": "string"
        },
        {
          "id": "skip-linkedin",
          "name": "skip_linkedin",
          "value": "false",
          "type": "string"
        },
        {
          "id": "skip-youtube",
          "name": "skip_youtube",
          "value": "false",
          "type": "string"
        }
      ],
      "set_options": {}
    },
    {
      "name": "Fetch Unenriched Social Profiles",
      "id": "e93ab76e-60c6-4cc0-a18d-e2ec7979a125",
      "type": "httpRequest",
      "full_type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        10784,
        224
      ],
      "notes": "Fetches social_profiles rows where follower_count is NULL (not yet enriched by SociaVault).",
      "onError": "",
      "mode": "",
      "incoming": [
        {
          "source": "Step 3b Config",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Parse Batch1",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "http_method": "GET",
      "http_url": "={{ $env.SUPABASE_URL }}/rest/v1/social_profiles?follower_count=is.null&order=scraped_at.asc&limit={{ $json.batch_size }}&offset={{ $json.batch_offset }}&select=id,company_id,platform,profile_url,follower_count,post_count,last_post_date,scraped_at",
      "http_sendHeaders": true,
      "http_headers": [
        {
          "name": "apikey",
          "value": "={{ $env.SUPABASE_SERVICE_KEY }}"
        },
        {
          "name": "Authorization",
          "value": "=Bearer {{ $env.SUPABASE_SERVICE_KEY }}"
        }
      ],
      "http_sendBody": false,
      "http_bodyType": "",
      "http_jsonBody": "",
      "http_body": "",
      "http_options": {
        "timeout": 30000
      },
      "http_batching": null,
      "http_timeout": 30000,
      "http_sendQuery": false,
      "http_queryParams": []
    },
    {
      "name": "Parse Batch1",
      "id": "20ccd9c2-acbb-4327-a9de-bbc1e979f112",
      "type": "code",
      "full_type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        11008,
        224
      ],
      "notes": "",
      "onError": "",
      "mode": "",
      "incoming": [
        {
          "source": "Fetch Unenriched Social Profiles",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Batch Empty?1",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "jsCode": "const allInputs = $input.all();\nlet profiles = [];\n\nif (allInputs.length === 1 && Array.isArray(allInputs[0].json)) {\n  profiles = allInputs[0].json;\n} else {\n  profiles = allInputs.map(i => i.json);\n}\n\nif (!profiles || profiles.length === 0 || (profiles.length === 1 && !profiles[0].id)) {\n  return [{ json: { _empty: true, _count: 0, _message: 'No unenriched social profiles found' } }];\n}\n\nconsole.log('Batch loaded: ' + profiles.length + ' social profiles to enrich');\nreturn profiles.map(p => ({ json: p }));",
      "upstream_refs": [],
      "ref_methods": [],
      "code_lines": 15
    },
    {
      "name": "Batch Empty?1",
      "id": "41fec4aa-25c3-4541-b234-884eac0cf93a",
      "type": "if",
      "full_type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        11232,
        224
      ],
      "notes": "",
      "onError": "",
      "mode": "",
      "incoming": [
        {
          "source": "Parse Batch1",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "No Records - Done1",
          "output_idx": 0,
          "input_idx": 0
        },
        {
          "target": "Build SociaVault Request",
          "output_idx": 1,
          "input_idx": 0
        }
      ],
      "if_conditions": {
        "options": {
          "caseSensitive": true,
          "leftValue": "",
          "typeValidation": "loose"
        },
        "conditions": [
          {
            "id": "empty-check",
            "leftValue": "={{ $json._empty }}",
            "rightValue": true,
            "operator": {
              "type": "boolean",
              "operation": "equals",
              "singleValue": true
            }
          }
        ],
        "combinator": "and"
      },
      "if_options": {}
    },
    {
      "name": "No Records - Done1",
      "id": "bdc6ecee-4e9a-4fff-9f9b-d3dfb28f9234",
      "type": "code",
      "full_type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        11456,
        128
      ],
      "notes": "",
      "onError": "",
      "mode": "",
      "incoming": [
        {
          "source": "Batch Empty?1",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [],
      "jsCode": "return [{ json: { message: 'No unenriched social profiles found. Step 3b complete.', completed_at: new Date().toISOString() } }];",
      "upstream_refs": [],
      "ref_methods": [],
      "code_lines": 1
    },
    {
      "name": "Build SociaVault Request",
      "id": "943aee3c-3d66-412f-aad3-e2308cab8976",
      "type": "code",
      "full_type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        11456,
        320
      ],
      "notes": "Extracts username/handle from profile_url, builds SociaVault API URL per platform. Skips unparseable profiles.",
      "onError": "",
      "mode": "runOnceForEachItem",
      "incoming": [
        {
          "source": "Batch Empty?1",
          "output_idx": 1,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Should Enrich?",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "jsCode": "const profile = $input.item.json;\nconst config = $('Step 3b Config').first().json;\nconst platform = (profile.platform || '').toLowerCase();\nconst url = (profile.profile_url || '').trim();\nconst skipMap = {\n  instagram: config.skip_instagram,\n  facebook: config.skip_facebook,\n  tiktok: config.skip_tiktok,\n  x: config.skip_twitter,\n  twitter: config.skip_twitter,\n  linkedin: config.skip_linkedin,\n  youtube: config.skip_youtube\n};\nconst shouldSkip = skipMap[platform] === 'true' || skipMap[platform] === true;\nif (shouldSkip) {\n  return { json: { ...profile, _skip: true, _skip_reason: `Platform ${platform} disabled`, _sociavault_url: '', _extracted_handle: '' } };\n}\nlet handle = '';\ntry {\n  if (platform === 'instagram') {\n    const match = url.match(/instagram\\.com\\/([a-zA-Z0-9._]+)/i);\n    if (match) handle = match[1];\n  } else if (platform === 'facebook') {\n    const profileIdMatch = url.match(/profile\\.php\\?id=(\\d+)/);\n    if (profileIdMatch) {\n      handle = profileIdMatch[1];\n    } else {\n      const match = url.match(/facebook\\.com\\/([a-zA-Z0-9._-]+)/i);\n      if (match) handle = match[1];\n    }\n  } else if (platform === 'tiktok') {\n    const match = url.match(/tiktok\\.com\\/@([a-zA-Z0-9._-]+)/i);\n    if (match) handle = match[1];\n  } else if (platform === 'x' || platform === 'twitter') {\n    const match = url.match(/(?:twitter|x)\\.com\\/([a-zA-Z0-9_]+)/i);\n    if (match) handle = match[1];\n  } else if (platform === 'linkedin') {\n    const companyMatch = url.match(/linkedin\\.com\\/company\\/([a-zA-Z0-9._-]+)/i);\n    const personMatch = url.match(/linkedin\\.com\\/in\\/([a-zA-Z0-9._-]+)/i);\n    handle = companyMatch ? companyMatch[1] : (personMatch ? personMatch[1] : '');\n  } else if (platform === 'youtube') {\n    const handleMatch = url.match(/youtube\\.com\\/@([a-zA-Z0-9._-]+)/i);\n    const channelMatch = url.match(/youtube\\.com\\/channel\\/([a-zA-Z0-9_-]+)/i);\n    const cMatch = url.match(/youtube\\.com\\/c\\/([a-zA-Z0-9._-]+)/i);\n    handle = handleMatch ? handleMatch[1] : (channelMatch ? channelMatch[1] : (cMatch ? cMatch[1] : ''));\n  }\n} catch (e) {}\nconst invalidHandles = [\n  'sharer', 'share', 'intent', 'login', 'help', 'about', 'policies', 'privacy',\n  'hashtag', 'explore', 'watch', 'results', 'search',\n  // Facebook non-profile paths (tracking pixels, SDK, plugins, etc.)\n  'tr', 'flx', 'plugins', 'dialog', 'ajax', 'ads', 'business', 'events',\n  'groups', 'marketplace', 'gaming', 'watch', 'reels', 'stories'\n];\nif (invalidHandles.includes(handle.toLowerCase())) handle = '';\nif (!handle) {\n  return { json: { ...profile, _skip: true, _skip_reason: `Could not extract handle from URL: ${url}`, _sociavault_url: '', _extracted_handle: '' } };\n}\nlet sociavaultUrl = '';\nconst baseUrl = 'https://api.sociavault.com/v1/scrape';\nif (platform === 'instagram') {\n  sociavaultUrl = `${baseUrl}/instagram/profile?handle=${encodeURIComponent(handle)}`;\n} else if (platform === 'facebook') {\n  // Facebook endpoint requires the full profile URL with https://\n  let fbUrl = url;\n  if (!fbUrl.startsWith('http')) {\n    fbUrl = 'https://' + fbUrl;\n  }\n  // Ensure https (not http)\n  fbUrl = fbUrl.replace(/^http:\\/\\//, 'https://');\n  sociavaultUrl = `${baseUrl}/facebook/profile?url=${encodeURIComponent(fbUrl)}`;\n} else if (platform === 'tiktok') {\n  sociavaultUrl = `${baseUrl}/tiktok/profile?handle=${encodeURIComponent(handle)}`;\n} else if (platform === 'x' || platform === 'twitter') {\n  sociavaultUrl = `${baseUrl}/twitter/profile?handle=${encodeURIComponent(handle)}`;\n} else if (platform === 'linkedin') {\n  const isCompany = url.includes('/company/');\n  sociavaultUrl = isCompany\n    ? `${baseUrl}/linkedin/company?username=${encodeURIComponent(handle)}`\n    : `${baseUrl}/linkedin/profile?username=${encodeURIComponent(handle)}`;\n} else if (platform === 'youtube') {\n  const isChannelId = handle.startsWith('UC');\n  sociavaultUrl = isChannelId\n    ? `${baseUrl}/youtube/channel?channel_id=${encodeURIComponent(handle)}`\n    : `${baseUrl}/youtube/channel?handle=${encodeURIComponent(handle)}`;\n}\nif (!sociavaultUrl) {\n  return { json: { ...profile, _skip: true, _skip_reason: `Unsupported platform: ${platform}`, _sociavault_url: '', _extracted_handle: handle } };\n}\nreturn { json: { ...profile, _skip: false, _skip_reason: null, _sociavault_url: sociavaultUrl, _extracted_handle: handle, _platform: platform } };",
      "upstream_refs": [
        "Step 3b Config"
      ],
      "ref_methods": [
        {
          "node": "Step 3b Config",
          "method": "first"
        }
      ],
      "code_lines": 90
    },
    {
      "name": "Should Enrich?",
      "id": "014949d1-83f2-4a75-bd76-05ef6d6037fc",
      "type": "if",
      "full_type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        11680,
        320
      ],
      "notes": "",
      "onError": "",
      "mode": "",
      "incoming": [
        {
          "source": "Build SociaVault Request",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Call SociaVault API",
          "output_idx": 0,
          "input_idx": 0
        },
        {
          "target": "Run Summary2",
          "output_idx": 1,
          "input_idx": 0
        }
      ],
      "if_conditions": {
        "options": {
          "caseSensitive": true,
          "leftValue": "",
          "typeValidation": "loose"
        },
        "conditions": [
          {
            "id": "should-skip",
            "leftValue": "={{ $json._skip }}",
            "rightValue": true,
            "operator": {
              "type": "boolean",
              "operation": "notEquals"
            }
          }
        ],
        "combinator": "and"
      },
      "if_options": {}
    },
    {
      "name": "Call SociaVault API",
      "id": "2189cd6e-39b9-44c6-8678-c9166f7e3eff",
      "type": "httpRequest",
      "full_type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        11904,
        256
      ],
      "notes": "Calls SociaVault profile endpoint. Batched 5 at a time with 2s delay. On error, continues.",
      "onError": "continueRegularOutput",
      "mode": "",
      "incoming": [
        {
          "source": "Should Enrich?",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Parse SociaVault Response",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "http_method": "GET",
      "http_url": "={{ $json._sociavault_url }}",
      "http_sendHeaders": true,
      "http_headers": [
        {
          "name": "X-API-Key",
          "value": "={{ $env.SOCIAVAULT_API_KEY }}"
        }
      ],
      "http_sendBody": false,
      "http_bodyType": "",
      "http_jsonBody": "",
      "http_body": "",
      "http_options": {
        "batching": {
          "batch": {
            "batchSize": 5,
            "batchInterval": 2000
          }
        },
        "timeout": 30000
      },
      "http_batching": {
        "batch": {
          "batchSize": 5,
          "batchInterval": 2000
        }
      },
      "http_timeout": 30000,
      "http_sendQuery": false,
      "http_queryParams": []
    },
    {
      "name": "Parse SociaVault Response",
      "id": "646f8e9a-ce35-4835-bf95-f2218ee85cd5",
      "type": "code",
      "full_type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        12128,
        256
      ],
      "notes": "Extracts follower_count, post_count, last_post_date from SociaVault response per platform.",
      "onError": "",
      "mode": "runOnceForEachItem",
      "incoming": [
        {
          "source": "Call SociaVault API",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Update Social Profile in Supabase",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "jsCode": "const response = $input.item.json;\nconst profileData = $('Should Enrich?').item.json;\nconst platform = profileData._platform;\nconst profileId = profileData.id;\nconst companyId = profileData.company_id;\nlet follower_count = null;\nlet post_count = null;\nlet last_post_date = null;\nlet fetchStatus = 'success';\nlet errorMsg = null;\ntry {\n  if (response.error || response.status === 'error' || response.success === false) {\n    fetchStatus = 'error';\n    errorMsg = response.error || response.message || 'API returned error';\n  } else if (platform === 'instagram') {\n    // SociaVault returns: { success, data: { success, data: { user: { ... } } } }\n    const user = response.data?.data?.user || response.data?.user || response.user || response.data || {};\n    follower_count = user.edge_followed_by?.count ?? user.follower_count ?? user.followers_count ?? null;\n    post_count = user.edge_owner_to_timeline_media?.count ?? user.media_count ?? null;\n    const edges = user.edge_owner_to_timeline_media?.edges || [];\n    // edges may be an object with numeric keys instead of an array\n    const edgeArray = Array.isArray(edges) ? edges : Object.values(edges);\n    if (edgeArray.length > 0) {\n      const firstPost = edgeArray[0]?.node || edgeArray[0] || {};\n      if (firstPost.taken_at) {\n        last_post_date = new Date(firstPost.taken_at * 1000).toISOString().split('T')[0];\n      }\n    }\n  } else if (platform === 'facebook') {\n    // SociaVault returns: { success, data: { success, name, followerCount, likeCount, ... } }\n    const data = response.data || response;\n    follower_count = data.followerCount ?? data.follower_count ?? data.followers_count ?? data.likes ?? data.likeCount ?? data.fan_count ?? null;\n    post_count = data.posts_count ?? data.postCount ?? null;\n  } else if (platform === 'tiktok') {\n    const stats = response.data?.userInfo?.stats || response.data?.stats || {};\n    const user = response.data?.userInfo?.user || response.data?.user || response.data || response;\n    follower_count = stats.followerCount ?? user.followerCount ?? user.followers_count ?? null;\n    post_count = stats.videoCount ?? user.videoCount ?? null;\n  } else if (platform === 'x' || platform === 'twitter') {\n    // SociaVault returns: { success, data: { success, __typename: \"User\", legacy: { followers_count, statuses_count, ... }, ... } }\n    const data = response.data || {};\n    const legacy = data.legacy || {};\n    const user = data.user || data;\n    follower_count = legacy.followers_count ?? legacy.normal_followers_count ?? user.followers_count ?? user.followerCount ?? user.public_metrics?.followers_count ?? null;\n    post_count = legacy.statuses_count ?? user.statuses_count ?? user.tweet_count ?? user.public_metrics?.tweet_count ?? null;\n    // Check for \"account doesn't exist\" responses\n    if (data.message === \"Account doesn't exist\" || data.userId === null && data.handle) {\n      fetchStatus = 'not_found';\n      errorMsg = `Account @${data.handle} does not exist`;\n      follower_count = null;\n      post_count = null;\n    }\n    if (user.status?.created_at) {\n      try { last_post_date = new Date(user.status.created_at).toISOString().split('T')[0]; } catch(e) {}\n    }\n  } else if (platform === 'linkedin') {\n    const data = response.data || response;\n    follower_count = data.followerCount ?? data.followers_count ?? data.followersCount ?? null;\n  } else if (platform === 'youtube') {\n    const data = response.data || response;\n    follower_count = data.subscriberCount ?? data.subscriber_count ?? data.statistics?.subscriberCount ?? null;\n    post_count = data.videoCount ?? data.video_count ?? data.statistics?.videoCount ?? null;\n    if (typeof follower_count === 'string') follower_count = parseInt(follower_count, 10);\n    if (typeof post_count === 'string') post_count = parseInt(post_count, 10);\n  }\n  if (follower_count !== null) follower_count = Number(follower_count) || null;\n  if (post_count !== null) post_count = Number(post_count) || null;\n} catch (e) {\n  fetchStatus = 'error';\n  errorMsg = 'Parse error: ' + e.message;\n}\nreturn { json: { _profile_id: profileId, _company_id: companyId, _platform: platform, _extracted_handle: profileData._extracted_handle, _fetch_status: fetchStatus, _error: errorMsg, _update_payload: { follower_count, post_count, last_post_date, scraped_at: new Date().toISOString() } } };",
      "upstream_refs": [
        "Should Enrich?"
      ],
      "ref_methods": [
        {
          "node": "Should Enrich?",
          "method": "item.json"
        }
      ],
      "code_lines": 72
    },
    {
      "name": "Update Social Profile in Supabase",
      "id": "96c76dab-99a8-4c5f-9a3a-7776ec79fe78",
      "type": "httpRequest",
      "full_type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        12352,
        256
      ],
      "notes": "PATCH updates social_profiles row. Batched 10 at a time with 500ms delay.",
      "onError": "continueRegularOutput",
      "mode": "",
      "incoming": [
        {
          "source": "Parse SociaVault Response",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Run Summary2",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "http_method": "PATCH",
      "http_url": "={{ $env.SUPABASE_URL }}/rest/v1/social_profiles?id=eq.{{ $json._profile_id }}",
      "http_sendHeaders": true,
      "http_headers": [
        {
          "name": "apikey",
          "value": "={{ $env.SUPABASE_SERVICE_KEY }}"
        },
        {
          "name": "Authorization",
          "value": "=Bearer {{ $env.SUPABASE_SERVICE_KEY }}"
        },
        {
          "name": "Content-Type",
          "value": "application/json"
        },
        {
          "name": "Prefer",
          "value": "return=minimal"
        }
      ],
      "http_sendBody": true,
      "http_bodyType": "json",
      "http_jsonBody": "={{ JSON.stringify($json._update_payload) }}",
      "http_body": "",
      "http_options": {
        "batching": {
          "batch": {
            "batchSize": 10,
            "batchInterval": 500
          }
        }
      },
      "http_batching": {
        "batch": {
          "batchSize": 10,
          "batchInterval": 500
        }
      },
      "http_timeout": null,
      "http_sendQuery": false,
      "http_queryParams": []
    },
    {
      "name": "Run Summary2",
      "id": "88b637d0-c76a-4b24-9c4f-f734f76451fb",
      "type": "code",
      "full_type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        12576,
        336
      ],
      "notes": "Final summary with per-platform breakdown.",
      "onError": "",
      "mode": "",
      "incoming": [
        {
          "source": "Should Enrich?",
          "output_idx": 1,
          "input_idx": 0
        },
        {
          "source": "Update Social Profile in Supabase",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Bridge to 3a",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "jsCode": "const config = $('Step 3b Config').first().json;\nlet totalProcessed = 0, enriched = 0, errors = 0, skipped = 0;\nconst platformCounts = {};\nconst errorDetails = [];\n\ntry {\n  const allItems = $('Build SociaVault Request').all();\n  totalProcessed = allItems.length;\n  skipped = allItems.filter(i => i.json._skip === true).length;\n} catch(e) {}\n\ntry {\n  const results = $('Parse SociaVault Response').all();\n  for (const item of results) {\n    const data = item.json;\n    const platform = data._platform || 'unknown';\n    if (!platformCounts[platform]) platformCounts[platform] = { success: 0, error: 0 };\n    if (data._fetch_status === 'error') {\n      errors++;\n      platformCounts[platform].error++;\n      errorDetails.push({ handle: data._extracted_handle, platform: data._platform, error: data._error });\n    } else {\n      enriched++;\n      platformCounts[platform].success++;\n    }\n  }\n} catch(e) {}\n\nconst summary = {\n  run_completed_at: new Date().toISOString(),\n  batch_size: config.batch_size,\n  batch_offset: config.batch_offset,\n  total_profiles_in_batch: totalProcessed,\n  skipped, enriched, errors,\n  platform_breakdown: platformCounts,\n  error_details: errorDetails.slice(0, 10),\n  next_offset: Number(config.batch_offset) + Number(config.batch_size),\n  message: `Enriched ${enriched} social profiles (${errors} errors, ${skipped} skipped).`\n};\n\nconsole.log('=== STEP 3b: SOCIAL ENRICHMENT SUMMARY ===');\nconsole.log(JSON.stringify(summary, null, 2));\nreturn [{ json: summary }];",
      "upstream_refs": [
        "Parse SociaVault Response",
        "Build SociaVault Request",
        "Step 3b Config"
      ],
      "ref_methods": [
        {
          "node": "Step 3b Config",
          "method": "first"
        },
        {
          "node": "Build SociaVault Request",
          "method": "all"
        },
        {
          "node": "Parse SociaVault Response",
          "method": "all"
        }
      ],
      "code_lines": 43
    },
    {
      "name": "Bridge to 3a",
      "id": "b46e61e0-07d7-4a2c-90fb-891bdd0c631a",
      "type": "code",
      "full_type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        12784,
        336
      ],
      "notes": "",
      "onError": "",
      "mode": "",
      "incoming": [
        {
          "source": "Run Summary2",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Step 3a Config",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "jsCode": "// Collapse all input items into a single trigger item for the next step\nreturn [{ json: { _trigger: 'continue', _timestamp: new Date().toISOString() } }];",
      "upstream_refs": [],
      "ref_methods": [],
      "code_lines": 2
    },
    {
      "name": "Step 3a Config",
      "id": "5514320f-6f5b-4f5b-8c91-4aa237e32dcb",
      "type": "set",
      "full_type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        13104,
        320
      ],
      "notes": "CONFIGURE: batch_size = companies per run. skip_apollo/skip_website_scrape to bypass sub-steps. apollo_enrich_enabled = set false to save credits (search only, no enrich).",
      "onError": "",
      "mode": "",
      "incoming": [
        {
          "source": "Bridge to 3a",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Fetch Companies",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "set_assignments": [
        {
          "id": "batch-size",
          "name": "batch_size",
          "value": "50",
          "type": "string"
        },
        {
          "id": "batch-offset",
          "name": "batch_offset",
          "value": "0",
          "type": "string"
        },
        {
          "id": "skip-apollo",
          "name": "skip_apollo",
          "value": "false",
          "type": "string"
        },
        {
          "id": "skip-website-scrape",
          "name": "skip_website_scrape",
          "value": "false",
          "type": "string"
        },
        {
          "id": "apollo-enrich-enabled",
          "name": "apollo_enrich_enabled",
          "value": "true",
          "type": "string"
        }
      ],
      "set_options": {}
    },
    {
      "name": "Fetch Companies",
      "id": "db34216e-3683-434e-b7d5-8482ba771481",
      "type": "httpRequest",
      "full_type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        13328,
        320
      ],
      "notes": "",
      "onError": "",
      "mode": "",
      "incoming": [
        {
          "source": "Step 3a Config",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Fetch Existing Contacts",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "http_method": "GET",
      "http_url": "={{ $env.SUPABASE_URL }}/rest/v1/companies?enrichment_status=in.(partially_enriched,fully_enriched)&order=lead_score.desc,discovered_at.asc&limit={{ $json.batch_size }}&offset={{ $json.batch_offset }}&select=id,name,phone,domain,address,city,state,country,google_place_id,category,estimated_size,has_website,google_review_count,google_rating",
      "http_sendHeaders": true,
      "http_headers": [
        {
          "name": "apikey",
          "value": "={{ $env.SUPABASE_SERVICE_KEY }}"
        },
        {
          "name": "Authorization",
          "value": "=Bearer {{ $env.SUPABASE_SERVICE_KEY }}"
        }
      ],
      "http_sendBody": false,
      "http_bodyType": "",
      "http_jsonBody": "",
      "http_body": "",
      "http_options": {
        "timeout": 30000
      },
      "http_batching": null,
      "http_timeout": 30000,
      "http_sendQuery": false,
      "http_queryParams": []
    },
    {
      "name": "Fetch Existing Contacts",
      "id": "1f266183-5f4e-4a95-82ae-c18850a4dd6a",
      "type": "httpRequest",
      "full_type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        13552,
        320
      ],
      "notes": "",
      "onError": "continueRegularOutput",
      "mode": "",
      "incoming": [
        {
          "source": "Fetch Companies",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Filter & Parse Batch",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "http_method": "GET",
      "http_url": "={{ $env.SUPABASE_URL }}/rest/v1/contacts?select=company_id",
      "http_sendHeaders": true,
      "http_headers": [
        {
          "name": "apikey",
          "value": "={{ $env.SUPABASE_SERVICE_KEY }}"
        },
        {
          "name": "Authorization",
          "value": "=Bearer {{ $env.SUPABASE_SERVICE_KEY }}"
        }
      ],
      "http_sendBody": false,
      "http_bodyType": "",
      "http_jsonBody": "",
      "http_body": "",
      "http_options": {
        "timeout": 30000
      },
      "http_batching": null,
      "http_timeout": 30000,
      "http_sendQuery": false,
      "http_queryParams": []
    },
    {
      "name": "Filter & Parse Batch",
      "id": "989ee9a3-2aa5-4fa6-ba7d-c02754733bb7",
      "type": "code",
      "full_type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        13776,
        320
      ],
      "notes": "",
      "onError": "",
      "mode": "",
      "incoming": [
        {
          "source": "Fetch Existing Contacts",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Batch Empty?2",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "jsCode": "// Get companies from upstream Fetch Companies node\nconst companyItems = $('Fetch Companies').all();\nlet companies = [];\nif (companyItems.length === 1 && Array.isArray(companyItems[0].json)) {\n  companies = companyItems[0].json;\n} else {\n  companies = companyItems.map(i => i.json);\n}\n\n// Get existing contact company_ids\nconst contactItems = $input.all();\nlet existingIds = new Set();\nfor (const item of contactItems) {\n  if (item.json && item.json.company_id) {\n    existingIds.add(item.json.company_id);\n  }\n  // Handle array response\n  if (Array.isArray(item.json)) {\n    for (const row of item.json) {\n      if (row.company_id) existingIds.add(row.company_id);\n    }\n  }\n}\n\n// Filter out companies that already have contacts\nconst filtered = companies.filter(c => c.id && !existingIds.has(c.id));\n\nconsole.log(`Companies: ${companies.length} total, ${existingIds.size} already have contacts, ${filtered.length} need people discovery`);\n\nif (filtered.length === 0) {\n  return [{ json: { _empty: true, _count: 0, _message: 'All companies already have contacts or no companies to process' } }];\n}\n\nreturn filtered.map(c => ({ json: c }));",
      "upstream_refs": [
        "Fetch Companies"
      ],
      "ref_methods": [
        {
          "node": "Fetch Companies",
          "method": "all"
        }
      ],
      "code_lines": 34
    },
    {
      "name": "Batch Empty?2",
      "id": "1af71400-26c5-45ac-8d72-d6b325fef533",
      "type": "if",
      "full_type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        14000,
        320
      ],
      "notes": "",
      "onError": "",
      "mode": "",
      "incoming": [
        {
          "source": "Filter & Parse Batch",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "No Records - Done2",
          "output_idx": 0,
          "input_idx": 0
        },
        {
          "target": "Solo Practitioner Check",
          "output_idx": 1,
          "input_idx": 0
        }
      ],
      "if_conditions": {
        "options": {
          "caseSensitive": true,
          "leftValue": "",
          "typeValidation": "loose"
        },
        "conditions": [
          {
            "id": "empty-check",
            "leftValue": "={{ $json._empty }}",
            "rightValue": true,
            "operator": {
              "type": "boolean",
              "operation": "equals",
              "singleValue": true
            }
          }
        ],
        "combinator": "and"
      },
      "if_options": {}
    },
    {
      "name": "No Records - Done2",
      "id": "32ffc287-be9b-48e8-8e75-cde2c7c77f08",
      "type": "code",
      "full_type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        14224,
        224
      ],
      "notes": "",
      "onError": "",
      "mode": "",
      "incoming": [
        {
          "source": "Batch Empty?2",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [],
      "jsCode": "return [{ json: { message: 'No companies need people discovery. All already have contacts or no partially/fully enriched companies found.', completed_at: new Date().toISOString() } }];",
      "upstream_refs": [],
      "ref_methods": [],
      "code_lines": 1
    },
    {
      "name": "Solo Practitioner Check",
      "id": "38d393bc-b961-4eb2-849f-f0c190ce4c59",
      "type": "code",
      "full_type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        14224,
        416
      ],
      "notes": "Detects solo practitioners from estimated_size='solo' or business name patterns. Extracts first/last name from business name to avoid wasting API credits.",
      "onError": "",
      "mode": "runOnceForEachItem",
      "incoming": [
        {
          "source": "Batch Empty?2",
          "output_idx": 1,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Is Solo?",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "jsCode": "const item = $input.item.json;\nconst name = (item.name || '').trim();\nconst estimatedSize = item.estimated_size;\n\nlet isSolo = false;\nlet firstName = null;\nlet lastName = null;\n\n// Common first names for validation (covers ~90% of US population)\nconst commonFirstNames = new Set([\n  'aaron','abby','abigail','adam','adrian','adriana','aiden','aimee','alana','albert',\n  'alec','alexa','alexander','alexandra','alexis','alice','alicia','alina','alison','allison',\n  'alyssa','amanda','amber','amelia','amy','ana','andrea','andrew','angela','angelica',\n  'angie','anita','ann','anna','anne','annie','anthony','april','aria','ariana',\n  'ashley','audrey','austin','autumn','ava','avery','bailey','barbara','beatrice','becky',\n  'bella','ben','benjamin','beth','bethany','betty','beverly','bianca','blake','bonnie',\n  'brad','bradley','brandi','brandon','brandy','breanna','brenda','brent','brett','brian',\n  'briana','brianna','bridget','brittany','brittney','brooke','bruce','bryan','caitlin','caleb',\n  'cameron','camila','candace','cara','carina','carl','carla','carlos','carly','carmen',\n  'carol','carolina','caroline','carolyn','carrie','casey','cassandra','cassidy','catherine','cathy',\n  'cecilia','celeste','celia','chad','charlene','charles','charlie','charlotte','chase','chelsea',\n  'cheryl','chloe','chris','christa','christian','christina','christine','christopher','cindy','claire',\n  'clara','claudia','cody','colleen','connor','constance','corey','corinne','courtney','craig',\n  'crystal','cynthia','daisy','dale','dana','daniel','daniela','danielle','daphne','darlene',\n  'darren','dave','david','dawn','dean','deanna','debbie','deborah','debra','denise',\n  'derek','desiree','destiny','diana','diane','dianne','dolores','dominic','donna','doris',\n  'dorothy','douglas','drew','dustin','dylan','eddie','edith','edward','eileen','elaine',\n  'elena','elisa','elizabeth','ella','ellen','ellie','emily','emma','eric','erica',\n  'erika','erin','ernest','esther','ethan','eugene','eva','evan','evelyn','faith',\n  'faye','felicia','fiona','florence','frances','frank','gabriel','gabriela','gabriella','gabrielle',\n  'gail','gary','gavin','genevieve','george','georgia','gerald','gina','giselle','gladys',\n  'glen','glenn','gloria','grace','grant','greg','gregory','gretchen','hailey','haley',\n  'hannah','harold','harriet','harry','hayden','hazel','heather','heidi','helen','henry',\n  'hillary','holly','hope','howard','hunter','ian','irene','iris','isaac','isabel',\n  'isabella','ivy','jack','jackie','jackson','jacob','jacqueline','jade','jaime','jake',\n  'james','jamie','jan','jane','janet','janice','jared','jasmine','jason','jay',\n  'jean','jeanette','jeanne','jeff','jeffrey','jenna','jennifer','jenny','jeremy','jerry',\n  'jesse','jessica','jill','jillian','jim','jimmy','jo','joan','joann','joanna',\n  'joanne','jocelyn','jodi','jody','joe','joel','johanna','john','johnny','jolene',\n  'jon','jonathan','jordan','jorge','jose','joseph','josephine','josh','joshua','joy',\n  'joyce','juan','judith','judy','julia','julian','juliana','julie','june','justin',\n  'kaitlyn','kara','karen','karina','karl','kate','katelyn','katherine','kathleen','kathryn',\n  'kathy','katie','katrina','kay','kayla','keith','kelley','kelli','kelly','kelsey',\n  'ken','kendra','kenneth','kenny','kerry','kevin','kim','kimberly','kirsten','krista',\n  'kristen','kristin','kristina','kristy','kyle','kylie','lacey','lana','lance','larry',\n  'laura','lauren','laurie','leah','lee','leigh','lena','leo','leon','leslie',\n  'lexy','liam','lillian','lily','linda','lindsay','lindsey','lisa','logan','lois',\n  'lora','lorena','lori','lorraine','louis','louise','lucia','luis','luke','lydia',\n  'lynn','mackenzie','madeline','madison','maggie','malik','mallory','mandy','marc','marcia',\n  'marco','marcus','margaret','maria','mariah','marie','marilyn','marina','mario','marisa',\n  'marissa','mark','marlene','marsha','martha','martin','mary','mason','matt','matthew',\n  'maureen','max','maya','megan','meghan','melanie','melinda','melissa','melody','meredith',\n  'mia','michael','michele','michelle','miguel','mike','mildred','mindy','miranda','misty',\n  'mitchell','molly','monica','monique','morgan','mya','nadia','nancy','naomi','natalia',\n  'natalie','natasha','nathan','nathaniel','neil','nelson','nicholas','nicole','nina','noah',\n  'noel','nora','norma','olivia','owen','paige','pam','pamela','patricia','patrick',\n  'patty','paul','paula','pauline','peggy','penny','peter','philip','phyllis','priscilla',\n  'rachel','ralph','ramona','randall','randy','ray','raymond','rebecca','regina','renee',\n  'rhonda','ricardo','richard','rick','ricky','riley','rita','rob','robert','roberta',\n  'robin','rochelle','rodney','roger','ronald','rosa','rosalie','rose','rosemary','roxanne',\n  'ruby','russell','ruth','ryan','sabrina','sally','samantha','samuel','sandra','sandy',\n  'sara','sarah','savannah','scott','sean','selena','serena','seth','shana','shane',\n  'shannon','sharon','shawn','sheila','shelby','shelley','shelly','sheri','sherri','sherry',\n  'shirley','sierra','silvia','simone','sofia','sonia','sonya','sophia','stacey','stacy',\n  'stella','stephanie','stephen','steve','steven','sue','summer','susan','suzanne','sydney',\n  'sylvia','tabitha','tamara','tammy','tanya','tara','tatiana','taylor','teresa','terri',\n  'terry','tess','tessa','theresa','thomas','tiffany','tim','timothy','tina','tito',\n  'todd','tom','tommy','toni','tony','tonya','tracey','traci','tracy','travis',\n  'tricia','trisha','troy','tyler','valerie','vanessa','vera','veronica','vicki','vicky',\n  'victoria','vincent','violet','virginia','vivian','wade','walter','wanda','warren','wayne',\n  'wendy','wesley','whitney','william','willie','wilma','xavier','yolanda','yvette','yvonne',\n  'zachary','zoe'\n]);\n\nfunction isLikelyFirstName(word) {\n  return commonFirstNames.has(word.toLowerCase());\n}\n\n// Pattern 1: \"by Name\" pattern - \"Bodywork by Benna\", \"Massage by Celeste\"\nconst byPattern = name.match(/\\bby\\s+([A-Z][a-z]+)(?:\\s+([A-Z][a-z]+))?/i);\nif (byPattern) {\n  const candidate = byPattern[1];\n  if (isLikelyFirstName(candidate) || estimatedSize === 'solo') {\n    isSolo = true;\n    firstName = candidate;\n    lastName = byPattern[2] || null;\n  }\n}\n\n// Pattern 2: \"with Name\" pattern - \"inTouch with Nadine\"\nif (!firstName) {\n  const withPattern = name.match(/\\bwith\\s+([A-Z][a-z]+)(?:\\s+([A-Z][a-z]+))?/i);\n  if (withPattern) {\n    const candidate = withPattern[1];\n    if (isLikelyFirstName(candidate) || estimatedSize === 'solo') {\n      isSolo = true;\n      firstName = candidate;\n      lastName = withPattern[2] || null;\n    }\n  }\n}\n\n// Pattern 3: Possessive - \"Lexy's Massage\", \"Martha's Healing Hands\"\nif (!firstName) {\n  const possessiveMatch = name.match(/^([A-Z][a-z]+)'s\\s+/i);\n  if (possessiveMatch && isLikelyFirstName(possessiveMatch[1])) {\n    isSolo = true;\n    firstName = possessiveMatch[1];\n  }\n}\n\n// Pattern 4: \"FirstName LastName, LMT/CMT/RMT\" or \"FirstName LastName Massage Therapy\"\nif (!firstName) {\n  const nameFirst = name.match(/^([A-Z][a-z]+)\\s+([A-Z][a-z]+)(?:\\s*[,|]\\s*|\\s+)(?:LMT|CMT|RMT|Licensed|Massage|Bodywork|Therapeutic|Wellness)/i);\n  if (nameFirst) {\n    const fn = nameFirst[1];\n    const ln = nameFirst[2];\n    if (isLikelyFirstName(fn) && !commonFirstNames.has(ln.toLowerCase())) {\n      // First word is a real name, second word is likely a last name (not another first name used as brand)\n      isSolo = true;\n      firstName = fn;\n      lastName = ln;\n    }\n  }\n}\n\n// Pattern 5: \"FirstName LastName's Massage/Spa\"\nif (!firstName) {\n  const possessiveFullName = name.match(/^([A-Z][a-z]+)\\s+([A-Z][a-z]+)'s\\s+(?:Massage|Bodywork|Wellness|Spa|Healing)/i);\n  if (possessiveFullName && isLikelyFirstName(possessiveFullName[1])) {\n    isSolo = true;\n    firstName = possessiveFullName[1];\n    lastName = possessiveFullName[2];\n  }\n}\n\n// Pattern 6: Three-part name with title - \"Kristy Adele Lloyd, LMT\"\nif (!firstName) {\n  const threePartName = name.match(/^([A-Z][a-z]+)\\s+([A-Z][a-z]+)\\s+([A-Z][a-z]+),?\\s+(?:LMT|CMT|RMT|Licensed)/i);\n  if (threePartName && isLikelyFirstName(threePartName[1])) {\n    isSolo = true;\n    firstName = threePartName[1];\n    lastName = threePartName[3]; // Skip middle name, use last\n  }\n}\n\n// Pattern 7: Name embedded after comma - \"Mobile Massage Austin, Gina Bongiorno, LMT\"\nif (!firstName) {\n  const commaNameMatch = name.match(/,\\s*([A-Z][a-z]+)\\s+([A-Z][a-z]+)(?:\\s*,?\\s*(?:LMT|CMT|RMT|Licensed))?/i);\n  if (commaNameMatch && isLikelyFirstName(commaNameMatch[1])) {\n    isSolo = true;\n    firstName = commaNameMatch[1];\n    lastName = commaNameMatch[2];\n  }\n}\n\n// If estimated_size is solo but no name extracted, still flag as solo\nif (estimatedSize === 'solo' && !isSolo) {\n  isSolo = true;\n}\n\n// Reject if extracted first name matches the company's city (e.g. \"Austin\" in Austin, TX)\nif (firstName && item.city && firstName.toLowerCase() === item.city.toLowerCase()) {\n  firstName = null;\n  lastName = null;\n  // Don't unflag isSolo — it might still be solo, just can't extract the name\n}\n\nreturn {\n  json: {\n    ...item,\n    _is_solo: isSolo,\n    _solo_first_name: firstName,\n    _solo_last_name: lastName\n  }\n};",
      "upstream_refs": [],
      "ref_methods": [],
      "code_lines": 176
    },
    {
      "name": "Is Solo?",
      "id": "452e170e-02b9-4e19-860b-fc4448394b72",
      "type": "if",
      "full_type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        14528,
        304
      ],
      "notes": "",
      "onError": "",
      "mode": "",
      "incoming": [
        {
          "source": "Solo Practitioner Check",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Prepare Solo Contact",
          "output_idx": 0,
          "input_idx": 0
        },
        {
          "target": "Has Domain & Apollo?",
          "output_idx": 1,
          "input_idx": 0
        }
      ],
      "if_conditions": {
        "options": {
          "caseSensitive": true,
          "leftValue": "",
          "typeValidation": "loose"
        },
        "conditions": [
          {
            "id": "is-solo",
            "leftValue": "={{ $json._is_solo }}",
            "rightValue": true,
            "operator": {
              "type": "boolean",
              "operation": "equals",
              "singleValue": true
            }
          }
        ],
        "combinator": "and"
      },
      "if_options": {}
    },
    {
      "name": "Has Domain & Apollo?",
      "id": "0723f2f9-5176-43a0-bc31-29bbc4b47717",
      "type": "if",
      "full_type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        14752,
        400
      ],
      "notes": "Routes to Apollo search if company has a domain AND apollo is not skipped. Otherwise goes to website scrape fallback.",
      "onError": "",
      "mode": "",
      "incoming": [
        {
          "source": "Is Solo?",
          "output_idx": 1,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Apollo People Search",
          "output_idx": 0,
          "input_idx": 0
        },
        {
          "target": "No Domain Fallback",
          "output_idx": 1,
          "input_idx": 0
        }
      ],
      "if_conditions": {
        "options": {
          "caseSensitive": true,
          "leftValue": "",
          "typeValidation": "loose"
        },
        "conditions": [
          {
            "id": "has-domain",
            "leftValue": "={{ $json.domain }}",
            "rightValue": "",
            "operator": {
              "type": "string",
              "operation": "notEquals"
            }
          },
          {
            "id": "not-skip-apollo",
            "leftValue": "={{ $('Step 3a Config').first().json.skip_apollo }}",
            "rightValue": "true",
            "operator": {
              "type": "string",
              "operation": "notEquals"
            }
          }
        ],
        "combinator": "and"
      },
      "if_options": {}
    },
    {
      "name": "Apollo People Search",
      "id": "952338c4-dc81-42b4-8848-9915039d48dc",
      "type": "httpRequest",
      "full_type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        14960,
        288
      ],
      "notes": "FREE - does not consume credits. Searches for people at the company's domain. Returns person IDs with obfuscated last names.",
      "onError": "continueRegularOutput",
      "mode": "",
      "incoming": [
        {
          "source": "Has Domain & Apollo?",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Parse Apollo Search",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "http_method": "POST",
      "http_url": "https://api.apollo.io/api/v1/mixed_people/api_search",
      "http_sendHeaders": true,
      "http_headers": [
        {
          "name": "Content-Type",
          "value": "application/json"
        },
        {
          "name": "Cache-Control",
          "value": "no-cache"
        },
        {
          "name": "X-Api-Key",
          "value": "={{ $env.APOLLO_API_KEY }}"
        }
      ],
      "http_sendBody": true,
      "http_bodyType": "json",
      "http_jsonBody": "={\n  \"q_organization_domains\": \"{{ $json.domain }}\",\n  \"person_titles\": [\"owner\", \"founder\", \"ceo\", \"proprietor\", \"director\", \"manager\", \"massage therapist\", \"licensed massage therapist\"],\n  \"per_page\": 5\n}",
      "http_body": "",
      "http_options": {
        "timeout": 15000
      },
      "http_batching": null,
      "http_timeout": 15000,
      "http_sendQuery": false,
      "http_queryParams": []
    },
    {
      "name": "Parse Apollo Search",
      "id": "7b51328c-b140-4cd0-b97d-3454a9ff0013",
      "type": "code",
      "full_type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        15152,
        240
      ],
      "notes": "",
      "onError": "",
      "mode": "runOnceForEachItem",
      "incoming": [
        {
          "source": "Apollo People Search",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Apollo Found People?",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "jsCode": "const company = $('Solo Practitioner Check').item.json;\nconst response = $input.item.json;\nconst people = response.people || [];\n\nif (!people || people.length === 0) {\n  return {\n    json: {\n      ...company,\n      _apollo_found: false,\n      _apollo_person_id: null,\n      _apollo_person_count: 0\n    }\n  };\n}\n\n// Score people by role relevance - prefer owners/founders\nconst ownerKeywords = ['owner', 'founder', 'ceo', 'proprietor', 'principal', 'co-founder'];\nconst managerKeywords = ['manager', 'director', 'general manager', 'gm', 'head'];\nconst practitionerKeywords = ['massage', 'therapist', 'lmt', 'cmt', 'rmt', 'bodywork', 'esthetician'];\n\nlet bestPerson = null;\nlet bestScore = -1;\n\nfor (const person of people) {\n  const title = (person.title || '').toLowerCase();\n  let score = 0;\n\n  if (ownerKeywords.some(k => title.includes(k))) score = 10;\n  else if (managerKeywords.some(k => title.includes(k))) score = 5;\n  else if (practitionerKeywords.some(k => title.includes(k))) score = 3;\n  else score = 1;\n\n  // Bonus for having email available\n  if (person.has_email === true || person.has_email === 'true') score += 1;\n\n  if (score > bestScore) {\n    bestScore = score;\n    bestPerson = person;\n  }\n}\n\nconsole.log(`Apollo search for ${company.domain}: ${people.length} people found. Best: ${bestPerson.first_name} (${bestPerson.title || 'no title'}, score ${bestScore})`);\n\nreturn {\n  json: {\n    ...company,\n    _apollo_found: true,\n    _apollo_person_id: bestPerson.id,\n    _apollo_first_name: bestPerson.first_name,\n    _apollo_last_name_obfuscated: bestPerson.last_name_obfuscated || null,\n    _apollo_title: bestPerson.title || null,\n    _apollo_person_count: people.length\n  }\n};",
      "upstream_refs": [
        "Solo Practitioner Check"
      ],
      "ref_methods": [
        {
          "node": "Solo Practitioner Check",
          "method": "item.json"
        }
      ],
      "code_lines": 54
    },
    {
      "name": "Apollo Found People?",
      "id": "2c2cd5da-3c76-449c-9be1-a91b476657dd",
      "type": "if",
      "full_type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        15376,
        240
      ],
      "notes": "",
      "onError": "",
      "mode": "",
      "incoming": [
        {
          "source": "Parse Apollo Search",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Enrich Enabled?",
          "output_idx": 0,
          "input_idx": 0
        },
        {
          "target": "Fetch About Page",
          "output_idx": 1,
          "input_idx": 0
        }
      ],
      "if_conditions": {
        "options": {
          "caseSensitive": true,
          "leftValue": "",
          "typeValidation": "loose"
        },
        "conditions": [
          {
            "id": "apollo-found",
            "leftValue": "={{ $json._apollo_found }}",
            "rightValue": true,
            "operator": {
              "type": "boolean",
              "operation": "equals",
              "singleValue": true
            }
          }
        ],
        "combinator": "and"
      },
      "if_options": {}
    },
    {
      "name": "Fetch About Page",
      "id": "41c40c2f-8bfd-4565-aeba-88a5eadd25f9",
      "type": "httpRequest",
      "full_type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        15536,
        496
      ],
      "notes": "Fetches /about page as fallback when Apollo found no results. Tries to extract owner name from HTML.",
      "onError": "continueRegularOutput",
      "mode": "",
      "incoming": [
        {
          "source": "Apollo Found People?",
          "output_idx": 1,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Parse About Page",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "http_method": "GET",
      "http_url": "=https://{{ $json.domain }}/about",
      "http_sendHeaders": true,
      "http_headers": [
        {
          "name": "User-Agent",
          "value": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36"
        },
        {
          "name": "Accept",
          "value": "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8"
        }
      ],
      "http_sendBody": false,
      "http_bodyType": "",
      "http_jsonBody": "",
      "http_body": "",
      "http_options": {
        "redirect": {
          "redirect": {
            "maxRedirects": 5
          }
        },
        "response": {
          "response": {
            "fullResponse": true,
            "responseFormat": "text"
          }
        },
        "timeout": 15000
      },
      "http_batching": null,
      "http_timeout": 15000,
      "http_sendQuery": false,
      "http_queryParams": []
    },
    {
      "name": "Enrich Enabled?",
      "id": "8b8d3e1c-c70a-4cc1-85d4-f1e86a91399b",
      "type": "if",
      "full_type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        15552,
        128
      ],
      "notes": "Guards Apollo enrichment credits. Set apollo_enrich_enabled=false in config to skip enrichment and just use search results.",
      "onError": "",
      "mode": "",
      "incoming": [
        {
          "source": "Apollo Found People?",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Apollo People Enrich",
          "output_idx": 0,
          "input_idx": 0
        },
        {
          "target": "Apollo Search Only Contact",
          "output_idx": 1,
          "input_idx": 0
        }
      ],
      "if_conditions": {
        "options": {
          "caseSensitive": true,
          "leftValue": "",
          "typeValidation": "loose"
        },
        "conditions": [
          {
            "id": "enrich-enabled",
            "leftValue": "={{ $('Step 3a Config').first().json.apollo_enrich_enabled }}",
            "rightValue": "true",
            "operator": {
              "type": "string",
              "operation": "equals"
            }
          }
        ],
        "combinator": "and"
      },
      "if_options": {}
    },
    {
      "name": "No Domain Fallback",
      "id": "0fc8bfa9-091c-46d8-a9f8-43bc648b4112",
      "type": "code",
      "full_type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        15664,
        688
      ],
      "notes": "Last resort: tries to extract a person name from the business name when there's no domain to search or scrape.",
      "onError": "",
      "mode": "runOnceForEachItem",
      "incoming": [
        {
          "source": "Has Domain & Apollo?",
          "output_idx": 1,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "No Domain Found Name?",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "jsCode": "// Website scrape fallback for companies without a domain\n// Use the same validated name extraction as solo detection\nconst item = $input.item.json;\nconst name = (item.name || '').trim();\n\nconst commonFirstNames = new Set([\n  'aaron','abby','abigail','adam','adrian','adriana','aiden','aimee','alana','albert',\n  'alexa','alexander','alexandra','alexis','alice','alicia','alison','allison','amanda','amber',\n  'amelia','amy','ana','andrea','andrew','angela','angelica','angie','anita','ann',\n  'anna','anne','annie','anthony','april','aria','ariana','ashley','audrey','ava',\n  'avery','bailey','barbara','becky','bella','ben','benjamin','beth','bethany','betty',\n  'beverly','bianca','blake','bonnie','brad','bradley','brandi','brandon','brandy','brenda',\n  'brent','brian','brianna','bridget','brittany','brooke','bruce','bryan','caitlin','caleb',\n  'cameron','candace','cara','carl','carla','carlos','carly','carmen','carol','caroline',\n  'carolyn','carrie','casey','cassandra','catherine','cathy','celeste','chad','charlene','charles',\n  'charlotte','chelsea','cheryl','chloe','chris','christina','christine','christopher','cindy','claire',\n  'clara','claudia','colleen','connor','courtney','craig','crystal','cynthia','daisy','dale',\n  'dana','daniel','daniela','danielle','darlene','dave','david','dawn','dean','deanna',\n  'debbie','deborah','debra','denise','derek','desiree','diana','diane','dolores','donna',\n  'doris','dorothy','douglas','drew','dustin','dylan','eddie','edward','eileen','elaine',\n  'elena','elizabeth','ella','ellen','emily','emma','eric','erica','erika','erin',\n  'esther','ethan','eva','evelyn','faith','felicia','fiona','florence','frances','frank',\n  'gabriel','gabriela','gabrielle','gail','gary','george','georgia','gerald','gina','glen',\n  'glenn','gloria','grace','greg','gregory','hailey','haley','hannah','harold','harry',\n  'hazel','heather','heidi','helen','henry','holly','hope','howard','hunter','ian',\n  'irene','iris','isaac','isabel','isabella','ivy','jack','jackie','jacob','jacqueline',\n  'jade','jaime','jake','james','jamie','jane','janet','janice','jared','jasmine',\n  'jason','jay','jean','jeff','jeffrey','jenna','jennifer','jenny','jeremy','jerry',\n  'jesse','jessica','jill','jim','jimmy','joan','joanna','joanne','jocelyn','jodi',\n  'joe','joel','john','johnny','jon','jonathan','jordan','jose','joseph','josh',\n  'joshua','joy','joyce','judith','judy','julia','julie','june','justin','kaitlyn',\n  'kara','karen','karina','kate','katelyn','katherine','kathleen','kathryn','kathy','katie',\n  'katrina','kay','kayla','keith','kelly','kelsey','ken','kendra','kenneth','kevin',\n  'kim','kimberly','kirsten','krista','kristen','kristin','kristina','kristy','kyle','kylie',\n  'lacey','lana','lance','larry','laura','lauren','laurie','leah','lee','leigh',\n  'lena','leon','leslie','lexy','liam','lillian','lily','linda','lindsay','lindsey',\n  'lisa','logan','lois','lori','lorraine','louis','louise','lucia','luis','luke',\n  'lydia','lynn','mackenzie','madeline','madison','maggie','mallory','mandy','marc','marcia',\n  'marcus','margaret','maria','marie','marilyn','marina','mario','marisa','mark','marlene',\n  'martha','martin','mary','matt','matthew','maureen','max','maya','megan','meghan',\n  'melanie','melinda','melissa','melody','meredith','mia','michael','michele','michelle','miguel',\n  'mike','mildred','mindy','miranda','misty','molly','monica','monique','morgan','nadia',\n  'nancy','naomi','natalia','natalie','natasha','nathan','nicholas','nicole','nina','noah',\n  'nora','norma','olivia','owen','paige','pamela','patricia','patrick','paul','paula',\n  'peggy','penny','peter','philip','phyllis','priscilla','rachel','ralph','randy','ray',\n  'raymond','rebecca','regina','renee','rhonda','richard','rick','riley','rita','robert',\n  'roberta','robin','rodney','roger','ronald','rosa','rose','rosemary','ruby','russell',\n  'ruth','ryan','sabrina','sally','samantha','samuel','sandra','sandy','sara','sarah',\n  'savannah','scott','sean','selena','serena','seth','shannon','sharon','shawn','sheila',\n  'shelby','shelly','sheri','sherry','shirley','sierra','simone','sofia','sonia','sophia',\n  'stacey','stacy','stella','stephanie','stephen','steve','steven','sue','summer','susan',\n  'suzanne','sydney','sylvia','tamara','tammy','tanya','tara','tatiana','taylor','teresa',\n  'terri','terry','tessa','theresa','thomas','tiffany','timothy','tina','tito','todd',\n  'tom','toni','tony','tonya','tracey','tracy','travis','tricia','troy','tyler',\n  'valerie','vanessa','vera','veronica','vicki','victoria','vincent','violet','virginia','vivian',\n  'walter','wanda','wayne','wendy','wesley','whitney','william','willie','wilma','xavier',\n  'yolanda','yvette','yvonne','zachary','zoe'\n]);\n\nfunction isLikelyFirstName(word) {\n  return commonFirstNames.has(word.toLowerCase());\n}\n\nlet firstName = null;\nlet lastName = null;\n\n// Pattern 1: \"by Name\" - \"Bodywork by Benna\"\nconst byPattern = name.match(/\\bby\\s+([A-Z][a-z]+)(?:\\s+([A-Z][a-z]+))?/i);\nif (byPattern && isLikelyFirstName(byPattern[1])) {\n  firstName = byPattern[1];\n  lastName = byPattern[2] || null;\n}\n\n// Pattern 2: \"with Name\" - \"inTouch with Nadine\"\nif (!firstName) {\n  const withPattern = name.match(/\\bwith\\s+([A-Z][a-z]+)(?:\\s+([A-Z][a-z]+))?/i);\n  if (withPattern && isLikelyFirstName(withPattern[1])) {\n    firstName = withPattern[1];\n    lastName = withPattern[2] || null;\n  }\n}\n\n// Pattern 3: Possessive - \"Martha's Healing Hands\"\nif (!firstName) {\n  const possessive = name.match(/^([A-Z][a-z]+)'s\\s+/i);\n  if (possessive && isLikelyFirstName(possessive[1])) {\n    firstName = possessive[1];\n  }\n}\n\n// Pattern 4: \"FirstName LastName, LMT\" or similar credential\nif (!firstName) {\n  const credMatch = name.match(/^([A-Z][a-z]+)\\s+([A-Z][a-z]+)(?:\\s*,?\\s*(?:LMT|CMT|RMT|Licensed))/i);\n  if (credMatch && isLikelyFirstName(credMatch[1])) {\n    firstName = credMatch[1];\n    lastName = credMatch[2];\n  }\n}\n\n// Pattern 5: Name after comma - \"Mobile Massage Austin, Gina Bongiorno, LMT\"\nif (!firstName) {\n  const commaMatch = name.match(/,\\s*([A-Z][a-z]+)\\s+([A-Z][a-z]+)/i);\n  if (commaMatch && isLikelyFirstName(commaMatch[1])) {\n    firstName = commaMatch[1];\n    lastName = commaMatch[2];\n  }\n}\n\n// Pattern 6: Validated first+last before business keyword\nif (!firstName) {\n  const nameKeyword = name.match(/^([A-Z][a-z]+)\\s+([A-Z][a-z]+)\\s+(?:Massage|Bodywork|Therapeutic|Wellness|Healing|Spa)/i);\n  if (nameKeyword && isLikelyFirstName(nameKeyword[1]) && !isLikelyFirstName(nameKeyword[2])) {\n    firstName = nameKeyword[1];\n    lastName = nameKeyword[2];\n  }\n}\n\nconst hasContact = !!(firstName);\n\nreturn {\n  json: {\n    _contact: hasContact ? {\n      company_id: item.id,\n      first_name: firstName,\n      last_name: lastName,\n      role: 'owner',\n      is_owner: true,\n      email_business: null,\n      email_personal: null,\n      phone_direct: null,\n      linkedin_url: null,\n      location: [item.city, item.state].filter(Boolean).join(', ') || null,\n      cultural_affinity: null,\n      source: 'manual'\n    } : null,\n    _company_name: item.name,\n    _company_id: item.id,\n    _source_method: 'no_domain_name_extraction',\n    _has_contact: hasContact\n  }\n};",
      "upstream_refs": [],
      "ref_methods": [],
      "code_lines": 141
    },
    {
      "name": "Prepare Solo Contact",
      "id": "742b08b8-ac7e-4457-973c-f829cf4845ba",
      "type": "code",
      "full_type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        15696,
        -160
      ],
      "notes": "",
      "onError": "",
      "mode": "runOnceForEachItem",
      "incoming": [
        {
          "source": "Is Solo?",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Validate & Clean Contact",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "jsCode": "const item = $input.item.json;\nreturn {\n  json: {\n    _contact: {\n      company_id: item.id,\n      first_name: item._solo_first_name || null,\n      last_name: item._solo_last_name || null,\n      role: 'owner',\n      is_owner: true,\n      email_business: null,\n      email_personal: null,\n      phone_direct: null,\n      linkedin_url: null,\n      location: [item.city, item.state].filter(Boolean).join(', ') || null,\n      cultural_affinity: null,\n      source: 'solo_detection'\n    },\n    _company_name: item.name,\n    _company_id: item.id,\n    _source_method: 'solo_detection',\n    _has_contact: !!(item._solo_first_name)\n  }\n};",
      "upstream_refs": [],
      "ref_methods": [],
      "code_lines": 23
    },
    {
      "name": "Parse About Page",
      "id": "c7cb906c-8393-4af2-8938-2ce3492df94f",
      "type": "code",
      "full_type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        15696,
        496
      ],
      "notes": "",
      "onError": "",
      "mode": "runOnceForEachItem",
      "incoming": [
        {
          "source": "Fetch About Page",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "About Found Name?",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "jsCode": "const company = $('Solo Practitioner Check').item.json;\nconst response = $input.item.json;\nconst rawHtml = response.body || response.data || '';\nconst html = typeof rawHtml === 'string' ? rawHtml : '';\n\nlet firstName = null;\nlet lastName = null;\n\nconst commonFirstNames = new Set([\n  'aaron','abby','abigail','adam','adrian','adriana','aiden','aimee','alana','albert',\n  'alexa','alexander','alexandra','alexis','alice','alicia','alison','allison','amanda','amber',\n  'amelia','amy','ana','andrea','andrew','angela','angelica','angie','anita','ann',\n  'anna','anne','annie','anthony','april','aria','ariana','ashley','audrey','ava',\n  'avery','bailey','barbara','becky','bella','ben','benjamin','beth','bethany','betty',\n  'beverly','bianca','blake','bonnie','brad','bradley','brandi','brandon','brandy','brenda',\n  'brent','brian','brianna','bridget','brittany','brooke','bruce','bryan','caitlin','caleb',\n  'cameron','candace','cara','carl','carla','carlos','carly','carmen','carol','caroline',\n  'carolyn','carrie','casey','cassandra','catherine','cathy','celeste','chad','charlene','charles',\n  'charlotte','chelsea','cheryl','chloe','chris','christina','christine','christopher','cindy','claire',\n  'clara','claudia','colleen','connor','courtney','craig','crystal','cynthia','daisy','dale',\n  'dana','daniel','daniela','danielle','darlene','dave','david','dawn','dean','deanna',\n  'debbie','deborah','debra','denise','derek','desiree','diana','diane','dolores','donna',\n  'doris','dorothy','douglas','drew','dustin','dylan','eddie','edward','eileen','elaine',\n  'elena','elizabeth','ella','ellen','emily','emma','eric','erica','erika','erin',\n  'esther','ethan','eva','evelyn','faith','felicia','fiona','florence','frances','frank',\n  'gabriel','gabriela','gabrielle','gail','gary','george','georgia','gerald','gina','glen',\n  'glenn','gloria','grace','greg','gregory','hailey','haley','hannah','harold','harry',\n  'hazel','heather','heidi','helen','henry','holly','hope','howard','hunter','ian',\n  'irene','iris','isaac','isabel','isabella','ivy','jack','jackie','jacob','jacqueline',\n  'jade','jaime','jake','james','jamie','jane','janet','janice','jared','jasmine',\n  'jason','jay','jean','jeff','jeffrey','jenna','jennifer','jenny','jeremy','jerry',\n  'jesse','jessica','jill','jim','jimmy','joan','joanna','joanne','jocelyn','jodi',\n  'joe','joel','john','johnny','jon','jonathan','jordan','jose','joseph','josh',\n  'joshua','joy','joyce','judith','judy','julia','julie','june','justin','kaitlyn',\n  'kara','karen','karina','kate','katelyn','katherine','kathleen','kathryn','kathy','katie',\n  'katrina','kay','kayla','keith','kelly','kelsey','ken','kendra','kenneth','kevin',\n  'kim','kimberly','kirsten','krista','kristen','kristin','kristina','kristy','kyle','kylie',\n  'lacey','lana','lance','larry','laura','lauren','laurie','leah','lee','leigh',\n  'lena','leon','leslie','lexy','liam','lillian','lily','linda','lindsay','lindsey',\n  'lisa','logan','lois','lori','lorraine','louis','louise','lucia','luis','luke',\n  'lydia','lynn','mackenzie','madeline','madison','maggie','mallory','mandy','marc','marcia',\n  'marcus','margaret','maria','marie','marilyn','marina','mario','marisa','mark','marlene',\n  'martha','martin','mary','matt','matthew','maureen','max','maya','megan','meghan',\n  'melanie','melinda','melissa','melody','meredith','mia','michael','michele','michelle','miguel',\n  'mike','mildred','mindy','miranda','misty','molly','monica','monique','morgan','nadia',\n  'nancy','naomi','natalia','natalie','natasha','nathan','nicholas','nicole','nina','noah',\n  'nora','norma','olivia','owen','paige','pamela','patricia','patrick','paul','paula',\n  'peggy','penny','peter','philip','phyllis','priscilla','rachel','ralph','randy','ray',\n  'raymond','rebecca','regina','renee','rhonda','richard','rick','riley','rita','robert',\n  'roberta','robin','rodney','roger','ronald','rosa','rose','rosemary','ruby','russell',\n  'ruth','ryan','sabrina','sally','samantha','samuel','sandra','sandy','sara','sarah',\n  'savannah','scott','sean','selena','serena','seth','shannon','sharon','shawn','sheila',\n  'shelby','shelly','sheri','sherry','shirley','sierra','simone','sofia','sonia','sophia',\n  'stacey','stacy','stella','stephanie','stephen','steve','steven','sue','summer','susan',\n  'suzanne','sydney','sylvia','tamara','tammy','tanya','tara','tatiana','taylor','teresa',\n  'terri','terry','tessa','theresa','thomas','tiffany','timothy','tina','tito','todd',\n  'tom','toni','tony','tonya','tracey','tracy','travis','tricia','troy','tyler',\n  'valerie','vanessa','vera','veronica','vicki','victoria','vincent','violet','virginia','vivian',\n  'walter','wanda','wayne','wendy','wesley','whitney','william','willie','wilma','xavier',\n  'yolanda','yvette','yvonne','zachary','zoe'\n]);\n\nfunction isLikelyFirstName(word) {\n  return commonFirstNames.has((word || '').toLowerCase());\n}\n\nif (html.length > 0) {\n  // Strip HTML tags for cleaner text matching\n  const textOnly = html.replace(/<[^>]+>/g, ' ').replace(/\\s+/g, ' ');\n\n  const patterns = [\n    // \"Owner: Jane Smith\" or \"Founded by Jane Smith\"\n    /(?:owner|owned\\s+by|founded\\s+by|proprietor)[:\\s]+([A-Z][a-z]+)\\s+([A-Z][a-z]+)/i,\n    // \"Hi, I'm Jane Smith\" or \"My name is Jane Smith\"\n    /(?:hi,?\\s+i'?m|hello,?\\s+i'?m|my\\s+name\\s+is|i\\s+am)\\s+([A-Z][a-z]+)\\s+([A-Z][a-z]+)/i,\n    // \"About Jane Smith\" (standalone, not \"About Our Team\" etc)\n    /(?:^|\\s)about\\s+([A-Z][a-z]+)\\s+([A-Z][a-z]+)(?:\\s*[,|]|\\s+(?:LMT|CMT|RMT|Licensed))/i,\n    // \"Meet Jane Smith\" (standalone)\n    /(?:^|\\s)meet\\s+([A-Z][a-z]+)\\s+([A-Z][a-z]+)(?:\\s*[,|]|\\s+(?:LMT|CMT|RMT|Licensed|is\\s+a|has\\s+been))/i,\n    // \"Jane Smith, LMT\" or \"Jane Smith, Licensed Massage Therapist\"\n    /([A-Z][a-z]+)\\s+([A-Z][a-z]+),?\\s+(?:LMT|CMT|RMT|Licensed\\s+Massage)/i\n  ];\n\n  for (const pattern of patterns) {\n    // Try against both raw HTML and stripped text\n    for (const source of [textOnly, html]) {\n      const match = source.match(pattern);\n      if (match) {\n        const fn = match[1];\n        const ln = match[2];\n        // Validate: first word must be a real name, both words reasonable length\n        if (isLikelyFirstName(fn) &&\n            fn.length >= 2 && fn.length <= 20 &&\n            ln.length >= 2 && ln.length <= 20) {\n          firstName = fn;\n          lastName = ln;\n          break;\n        }\n      }\n    }\n    if (firstName) break;\n  }\n}\n\nconst hasContact = !!(firstName && lastName);\n\nreturn {\n  json: {\n    _contact: hasContact ? {\n      company_id: company.id,\n      first_name: firstName,\n      last_name: lastName,\n      role: 'owner',\n      is_owner: true,\n      email_business: null,\n      email_personal: null,\n      phone_direct: null,\n      linkedin_url: null,\n      location: [company.city, company.state].filter(Boolean).join(', ') || null,\n      cultural_affinity: null,\n      source: 'website'\n    } : null,\n    _company_name: company.name,\n    _company_id: company.id,\n    _source_method: 'website_scrape',\n    _has_contact: hasContact\n  }\n};",
      "upstream_refs": [
        "Solo Practitioner Check"
      ],
      "ref_methods": [
        {
          "node": "Solo Practitioner Check",
          "method": "item.json"
        }
      ],
      "code_lines": 128
    },
    {
      "name": "Apollo People Enrich",
      "id": "1c370a70-3b98-4ed4-acb7-7ba954e23676",
      "type": "httpRequest",
      "full_type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        15744,
        32
      ],
      "notes": "COSTS 1 CREDIT per call. Enriches the selected person with full name, email, phone, LinkedIn. Batched 5/sec.",
      "onError": "continueRegularOutput",
      "mode": "",
      "incoming": [
        {
          "source": "Enrich Enabled?",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Parse Apollo Enrich",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "http_method": "POST",
      "http_url": "https://api.apollo.io/api/v1/people/match",
      "http_sendHeaders": true,
      "http_headers": [
        {
          "name": "Content-Type",
          "value": "application/json"
        },
        {
          "name": "Cache-Control",
          "value": "no-cache"
        },
        {
          "name": "X-Api-Key",
          "value": "={{ $env.APOLLO_API_KEY }}"
        }
      ],
      "http_sendBody": true,
      "http_bodyType": "json",
      "http_jsonBody": "={\n  \"id\": \"{{ $json._apollo_person_id }}\",\n  \"reveal_personal_emails\": true,\n  \"reveal_phone_number\": false\n}",
      "http_body": "",
      "http_options": {
        "batching": {
          "batch": {
            "batchSize": 5
          }
        },
        "timeout": 15000
      },
      "http_batching": {
        "batch": {
          "batchSize": 5
        }
      },
      "http_timeout": 15000,
      "http_sendQuery": false,
      "http_queryParams": []
    },
    {
      "name": "Apollo Search Only Contact",
      "id": "22abecdd-55fb-4826-9462-fa1f3d48594a",
      "type": "code",
      "full_type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        15792,
        240
      ],
      "notes": "Fallback: uses Apollo search data (first name + obfuscated last name) when enrichment credits are disabled.",
      "onError": "",
      "mode": "runOnceForEachItem",
      "incoming": [
        {
          "source": "Enrich Enabled?",
          "output_idx": 1,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Validate & Clean Contact3",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "jsCode": "// Apollo search found someone but enrichment is disabled - use search-only data\nconst item = $input.item.json;\nreturn {\n  json: {\n    _contact: {\n      company_id: item.id,\n      first_name: item._apollo_first_name || null,\n      last_name: null,\n      role: (item._apollo_title || '').toLowerCase().includes('owner') ? 'owner' : 'unknown',\n      is_owner: (item._apollo_title || '').toLowerCase().includes('owner'),\n      email_business: null,\n      email_personal: null,\n      phone_direct: null,\n      linkedin_url: null,\n      location: [item.city, item.state].filter(Boolean).join(', ') || null,\n      cultural_affinity: null,\n      source: 'apollo'\n    },\n    _company_name: item.name,\n    _company_id: item.id,\n    _source_method: 'apollo_search_only',\n    _has_contact: !!(item._apollo_first_name)\n  }\n};",
      "upstream_refs": [],
      "ref_methods": [],
      "code_lines": 24
    },
    {
      "name": "About Found Name?",
      "id": "4ecaf3fa-e762-404d-96d9-f18970daeabd",
      "type": "if",
      "full_type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        15856,
        496
      ],
      "notes": "",
      "onError": "",
      "mode": "",
      "incoming": [
        {
          "source": "Parse About Page",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Validate & Clean Contact4",
          "output_idx": 0,
          "input_idx": 0
        },
        {
          "target": "Run Summary3",
          "output_idx": 1,
          "input_idx": 0
        }
      ],
      "if_conditions": {
        "options": {
          "caseSensitive": true,
          "leftValue": "",
          "typeValidation": "loose"
        },
        "conditions": [
          {
            "id": "found-name",
            "leftValue": "={{ $json._has_contact }}",
            "rightValue": true,
            "operator": {
              "type": "boolean",
              "operation": "equals",
              "singleValue": true
            }
          }
        ],
        "combinator": "and"
      },
      "if_options": {}
    },
    {
      "name": "No Domain Found Name?",
      "id": "8f88a95e-d323-4149-b45c-73cfa451b070",
      "type": "if",
      "full_type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        15888,
        736
      ],
      "notes": "",
      "onError": "",
      "mode": "",
      "incoming": [
        {
          "source": "No Domain Fallback",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Validate & Clean Contact2",
          "output_idx": 0,
          "input_idx": 0
        },
        {
          "target": "Run Summary3",
          "output_idx": 1,
          "input_idx": 0
        }
      ],
      "if_conditions": {
        "options": {
          "caseSensitive": true,
          "leftValue": "",
          "typeValidation": "loose"
        },
        "conditions": [
          {
            "id": "has-contact",
            "leftValue": "={{ $json._has_contact }}",
            "rightValue": true,
            "operator": {
              "type": "boolean",
              "operation": "equals",
              "singleValue": true
            }
          }
        ],
        "combinator": "and"
      },
      "if_options": {}
    },
    {
      "name": "Parse Apollo Enrich",
      "id": "9a934f56-ca30-44c5-839c-e298daf33b65",
      "type": "code",
      "full_type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        15920,
        32
      ],
      "notes": "",
      "onError": "",
      "mode": "runOnceForEachItem",
      "incoming": [
        {
          "source": "Apollo People Enrich",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Validate & Clean Contact1",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "jsCode": "const company = $('Parse Apollo Search').item.json;\nconst response = $input.item.json;\nconst person = response.person || response.match || response;\n\nif (!person || !person.first_name) {\n  // Enrichment failed but we still have search data\n  return {\n    json: {\n      _contact: {\n        company_id: company.id,\n        first_name: company._apollo_first_name || null,\n        last_name: null,\n        role: (company._apollo_title || '').toLowerCase().includes('owner') ? 'owner' : 'unknown',\n        is_owner: (company._apollo_title || '').toLowerCase().includes('owner'),\n        email_business: null,\n        email_personal: null,\n        phone_direct: null,\n        linkedin_url: null,\n        location: [company.city, company.state].filter(Boolean).join(', ') || null,\n        cultural_affinity: null,\n        source: 'apollo'\n      },\n      _company_name: company.name,\n      _company_id: company.id,\n      _source_method: 'apollo_search_only',\n      _has_contact: !!(company._apollo_first_name)\n    }\n  };\n}\n\n// Extract phone number\nlet phoneNumber = null;\nif (person.phone_numbers && person.phone_numbers.length > 0) {\n  phoneNumber = person.phone_numbers[0].sanitized_number || person.phone_numbers[0].raw_number || null;\n}\n\n// Determine role\nconst title = (person.title || '').toLowerCase();\nlet role = 'unknown';\nlet isOwner = false;\nif (['owner', 'founder', 'ceo', 'proprietor', 'principal', 'co-founder'].some(k => title.includes(k))) {\n  role = 'owner';\n  isOwner = true;\n} else if (['manager', 'director', 'gm', 'general manager'].some(k => title.includes(k))) {\n  role = 'manager';\n} else if (['massage', 'therapist', 'lmt', 'cmt', 'rmt', 'esthetician'].some(k => title.includes(k))) {\n  role = 'practitioner';\n}\n\nreturn {\n  json: {\n    _contact: {\n      company_id: company.id,\n      first_name: person.first_name || null,\n      last_name: person.last_name || null,\n      role: role,\n      is_owner: isOwner,\n      email_business: person.email || null,\n      email_personal: (person.personal_emails && person.personal_emails[0]) || null,\n      phone_direct: phoneNumber,\n      linkedin_url: person.linkedin_url || null,\n      location: [person.city, person.state].filter(Boolean).join(', ') || [company.city, company.state].filter(Boolean).join(', ') || null,\n      cultural_affinity: null,\n      source: 'apollo'\n    },\n    _company_name: company.name,\n    _company_id: company.id,\n    _source_method: 'apollo_enriched',\n    _has_contact: true\n  }\n};",
      "upstream_refs": [
        "Parse Apollo Search"
      ],
      "ref_methods": [
        {
          "node": "Parse Apollo Search",
          "method": "item.json"
        }
      ],
      "code_lines": 71
    },
    {
      "name": "Validate & Clean Contact3",
      "id": "8b5f4d27-1c06-4ae3-9815-c2036fcd7009",
      "type": "code",
      "full_type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        16000,
        240
      ],
      "notes": "",
      "onError": "",
      "mode": "runOnceForEachItem",
      "incoming": [
        {
          "source": "Apollo Search Only Contact",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Insert Contact to Supabase",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "jsCode": "// Validate & Clean Contact\n// Cleans emails, phones, names, LinkedIn URLs before Supabase insert.\n// Nulls out invalid data rather than blocking the insert.\n// Adds _validation_flags array for audit trail.\n\nconst item = $input.item.json;\nconst contact = item._contact;\nconst flags = [];\n\n// If no contact object (shouldn't happen, but safety), pass through\nif (!contact) {\n  return {\n    json: {\n      ...item,\n      _validation_flags: ['no_contact_object']\n    }\n  };\n}\n\n// ═══════════════════════════════════════════════\n// EMAIL VALIDATION\n// ═══════════════════════════════════════════════\n\nfunction validateEmail(email, fieldName) {\n  if (!email) return null;\n\n  // Trim and lowercase\n  let cleaned = email.trim().toLowerCase();\n\n  // Basic format check: x@x.x\n  const emailRegex = /^[a-zA-Z0-9._%+\\-]+@[a-zA-Z0-9.\\-]+\\.[a-zA-Z]{2,}$/;\n  if (!emailRegex.test(cleaned)) {\n    flags.push(`${fieldName}_invalid_format: \"${email}\"`);\n    return null;\n  }\n\n  // Reject known junk/placeholder patterns\n  const junkPatterns = [\n    /^noreply@/,\n    /^no-reply@/,\n    /^donotreply@/,\n    /^do-not-reply@/,\n    /^test@/,\n    /^admin@example\\./,\n    /^info@example\\./,\n    /^user@example\\./,\n    /^sample@/,\n    /^fake@/,\n    /^placeholder@/,\n    /^null@/,\n    /^none@/,\n    /^na@/,\n    /^n\\/a@/,\n    /^unknown@/,\n    /^abuse@/,\n    /^postmaster@/,\n    /^mailer-daemon@/\n  ];\n\n  if (junkPatterns.some(p => p.test(cleaned))) {\n    flags.push(`${fieldName}_junk_pattern: \"${cleaned}\"`);\n    return null;\n  }\n\n  // Reject common role-based/generic emails (not personal)\n  const rolePatterns = [\n    /^info@/,\n    /^contact@/,\n    /^hello@/,\n    /^support@/,\n    /^sales@/,\n    /^office@/,\n    /^billing@/,\n    /^reception@/,\n    /^frontdesk@/,\n    /^front\\.desk@/,\n    /^appointments@/,\n    /^booking@/,\n    /^bookings@/,\n    /^schedule@/,\n    /^scheduling@/,\n    /^inquiries@/,\n    /^inquiry@/,\n    /^general@/,\n    /^team@/,\n    /^staff@/\n  ];\n\n  if (rolePatterns.some(p => p.test(cleaned))) {\n    flags.push(`${fieldName}_role_based: \"${cleaned}\"`);\n    return null;\n  }\n\n  // Reject emails with known placeholder/test domains\n  const junkDomains = [\n    'example.com', 'example.org', 'example.net',\n    'test.com', 'test.org',\n    'placeholder.com',\n    'fake.com',\n    'noemail.com',\n    'nomail.com',\n    'none.com',\n    'localhost',\n    'mailinator.com',\n    'guerrillamail.com',\n    'tempmail.com',\n    'throwaway.email',\n    'yopmail.com'\n  ];\n\n  const domain = cleaned.split('@')[1];\n  if (junkDomains.includes(domain)) {\n    flags.push(`${fieldName}_junk_domain: \"${domain}\"`);\n    return null;\n  }\n\n  // Reject if local part is just numbers (often auto-generated)\n  const localPart = cleaned.split('@')[0];\n  if (/^\\d+$/.test(localPart)) {\n    flags.push(`${fieldName}_numeric_local: \"${cleaned}\"`);\n    return null;\n  }\n\n  // Check for double dots, leading/trailing dots in local part\n  if (localPart.startsWith('.') || localPart.endsWith('.') || localPart.includes('..')) {\n    flags.push(`${fieldName}_malformed_local: \"${cleaned}\"`);\n    return null;\n  }\n\n  return cleaned;\n}\n\ncontact.email_business = validateEmail(contact.email_business, 'email_business');\ncontact.email_personal = validateEmail(contact.email_personal, 'email_personal');\n\n\n// ═══════════════════════════════════════════════\n// PHONE VALIDATION (E.164 normalization)\n// ═══════════════════════════════════════════════\n\nfunction validatePhone(phone, fieldName) {\n  if (!phone) return null;\n\n  // Handle Apollo returning phone as object instead of string\n  if (typeof phone === 'object' && phone !== null) {\n    phone = phone.sanitized_number || phone.raw_number || phone.number || '';\n  }\n\n  // Strip everything except digits and leading +\n  let cleaned = phone.toString().trim();\n  const hasPlus = cleaned.startsWith('+');\n  cleaned = cleaned.replace(/[^\\d]/g, '');\n\n  if (!cleaned || cleaned.length === 0) {\n    flags.push(`${fieldName}_empty_after_strip`);\n    return null;\n  }\n\n  // US/CA normalization: should be 10 digits (or 11 with leading 1)\n  if (cleaned.length === 11 && cleaned.startsWith('1')) {\n    cleaned = cleaned; // already has country code\n  } else if (cleaned.length === 10) {\n    cleaned = '1' + cleaned; // prepend country code\n  } else if (cleaned.length < 10) {\n    flags.push(`${fieldName}_too_short: \"${phone}\" (${cleaned.length} digits)`);\n    return null;\n  } else if (cleaned.length > 11) {\n    // Could be international — keep it but flag for review\n    flags.push(`${fieldName}_possibly_international: \"${phone}\" (${cleaned.length} digits)`);\n    return '+' + cleaned;\n  }\n\n  // Validate US/CA area code (first digit after country code can't be 0 or 1)\n  const areaCode = cleaned.substring(1, 4);\n  if (areaCode.startsWith('0') || areaCode.startsWith('1')) {\n    flags.push(`${fieldName}_invalid_area_code: \"${areaCode}\"`);\n    return null;\n  }\n\n  return '+' + cleaned;\n}\n\ncontact.phone_direct = validatePhone(contact.phone_direct, 'phone_direct');\n\n\n// ═══════════════════════════════════════════════\n// NAME CLEANING\n// ═══════════════════════════════════════════════\n\nfunction cleanName(name, fieldName) {\n  if (!name) return null;\n\n  let cleaned = name.trim();\n\n  // Strip Apollo obfuscation artifacts (trailing *, partial names)\n  cleaned = cleaned.replace(/\\*+$/, '').trim();\n\n  // Reject single-character names\n  if (cleaned.length <= 1) {\n    flags.push(`${fieldName}_too_short: \"${name}\"`);\n    return null;\n  }\n\n  // Reject all-numeric \"names\"\n  if (/^\\d+$/.test(cleaned)) {\n    flags.push(`${fieldName}_numeric: \"${name}\"`);\n    return null;\n  }\n\n  // Reject names with numbers mixed in (likely data artifacts)\n  if (/\\d/.test(cleaned)) {\n    flags.push(`${fieldName}_contains_digits: \"${name}\"`);\n    return null;\n  }\n\n  // Reject names that are clearly not names\n  const junkNames = [\n    'unknown', 'n/a', 'na', 'none', 'null', 'test',\n    'owner', 'manager', 'admin', 'info', 'contact'\n  ];\n  if (junkNames.includes(cleaned.toLowerCase())) {\n    flags.push(`${fieldName}_junk_name: \"${name}\"`);\n    return null;\n  }\n\n  // Reject massage therapy credentials stored as names (Apollo artifact)\n  const credentials = [\n    'lmt', 'cmt', 'rmt', 'lmbt', 'lmp', 'bctmb', 'nctmb', 'nctm',\n    'cpt', 'cst', 'mld', 'nmt', 'amt', 'abmp'\n  ];\n  if (credentials.includes(cleaned.toLowerCase())) {\n    flags.push(`${fieldName}_credential_not_name: \"${name}\"`);\n    return null;\n  }\n\n  // Title case normalization: \"JANE\" → \"Jane\", \"jane\" → \"Jane\"\n  // Preserve already-correct casing like \"McDonald\", \"O'Brien\"\n  if (cleaned === cleaned.toUpperCase() || cleaned === cleaned.toLowerCase()) {\n    cleaned = cleaned.charAt(0).toUpperCase() + cleaned.slice(1).toLowerCase();\n  }\n\n  return cleaned;\n}\n\ncontact.first_name = cleanName(contact.first_name, 'first_name');\ncontact.last_name = cleanName(contact.last_name, 'last_name');\n\n// If first_name got nulled out, this contact is essentially useless\nif (!contact.first_name) {\n  flags.push('contact_has_no_valid_first_name');\n}\n\n\n// ═══════════════════════════════════════════════\n// LINKEDIN URL VALIDATION\n// ═══════════════════════════════════════════════\n\nfunction validateLinkedIn(url) {\n  if (!url) return null;\n\n  let cleaned = url.trim();\n\n  // Must contain linkedin.com/in/ for personal profiles\n  if (!/linkedin\\.com\\/in\\//i.test(cleaned)) {\n    // Could be a company page or malformed URL\n    if (/linkedin\\.com/i.test(cleaned)) {\n      flags.push(`linkedin_not_personal_profile: \"${cleaned}\"`);\n    } else {\n      flags.push(`linkedin_invalid_url: \"${cleaned}\"`);\n    }\n    return null;\n  }\n\n  // Ensure https:// prefix\n  if (!cleaned.startsWith('http')) {\n    cleaned = 'https://' + cleaned;\n  }\n\n  // Normalize to https\n  cleaned = cleaned.replace(/^http:\\/\\//, 'https://');\n\n  return cleaned;\n}\n\ncontact.linkedin_url = validateLinkedIn(contact.linkedin_url);\n\n\n// ═══════════════════════════════════════════════\n// LOCATION CLEANING\n// ═══════════════════════════════════════════════\n\nif (contact.location) {\n  contact.location = contact.location.trim();\n  // Null out empty-ish locations\n  if (!contact.location || contact.location === ',' || contact.location.length < 2) {\n    contact.location = null;\n    flags.push('location_empty_after_clean');\n  }\n}\n\n\n// ═══════════════════════════════════════════════\n// OUTPUT\n// ═══════════════════════════════════════════════\n\n// Update _has_contact based on whether we still have a valid first name\nconst hasValidContact = !!(contact.first_name);\n\nif (flags.length > 0) {\n  console.log(`Validation [${item._company_name}] (${item._source_method}): ${flags.join(', ')}`);\n}\n\nreturn {\n  json: {\n    _contact: contact,\n    _company_name: item._company_name,\n    _company_id: item._company_id,\n    _source_method: item._source_method,\n    _has_contact: hasValidContact,\n    _validation_flags: flags\n  }\n};",
      "upstream_refs": [],
      "ref_methods": [],
      "code_lines": 322
    },
    {
      "name": "Validate & Clean Contact4",
      "id": "7c80f89d-8f02-4bd8-b532-011e20bd571f",
      "type": "code",
      "full_type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        16048,
        400
      ],
      "notes": "",
      "onError": "",
      "mode": "runOnceForEachItem",
      "incoming": [
        {
          "source": "About Found Name?",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Insert Contact to Supabase",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "jsCode": "// Validate & Clean Contact\n// Cleans emails, phones, names, LinkedIn URLs before Supabase insert.\n// Nulls out invalid data rather than blocking the insert.\n// Adds _validation_flags array for audit trail.\n\nconst item = $input.item.json;\nconst contact = item._contact;\nconst flags = [];\n\n// If no contact object (shouldn't happen, but safety), pass through\nif (!contact) {\n  return {\n    json: {\n      ...item,\n      _validation_flags: ['no_contact_object']\n    }\n  };\n}\n\n// ═══════════════════════════════════════════════\n// EMAIL VALIDATION\n// ═══════════════════════════════════════════════\n\nfunction validateEmail(email, fieldName) {\n  if (!email) return null;\n\n  // Trim and lowercase\n  let cleaned = email.trim().toLowerCase();\n\n  // Basic format check: x@x.x\n  const emailRegex = /^[a-zA-Z0-9._%+\\-]+@[a-zA-Z0-9.\\-]+\\.[a-zA-Z]{2,}$/;\n  if (!emailRegex.test(cleaned)) {\n    flags.push(`${fieldName}_invalid_format: \"${email}\"`);\n    return null;\n  }\n\n  // Reject known junk/placeholder patterns\n  const junkPatterns = [\n    /^noreply@/,\n    /^no-reply@/,\n    /^donotreply@/,\n    /^do-not-reply@/,\n    /^test@/,\n    /^admin@example\\./,\n    /^info@example\\./,\n    /^user@example\\./,\n    /^sample@/,\n    /^fake@/,\n    /^placeholder@/,\n    /^null@/,\n    /^none@/,\n    /^na@/,\n    /^n\\/a@/,\n    /^unknown@/,\n    /^abuse@/,\n    /^postmaster@/,\n    /^mailer-daemon@/\n  ];\n\n  if (junkPatterns.some(p => p.test(cleaned))) {\n    flags.push(`${fieldName}_junk_pattern: \"${cleaned}\"`);\n    return null;\n  }\n\n  // Reject common role-based/generic emails (not personal)\n  const rolePatterns = [\n    /^info@/,\n    /^contact@/,\n    /^hello@/,\n    /^support@/,\n    /^sales@/,\n    /^office@/,\n    /^billing@/,\n    /^reception@/,\n    /^frontdesk@/,\n    /^front\\.desk@/,\n    /^appointments@/,\n    /^booking@/,\n    /^bookings@/,\n    /^schedule@/,\n    /^scheduling@/,\n    /^inquiries@/,\n    /^inquiry@/,\n    /^general@/,\n    /^team@/,\n    /^staff@/\n  ];\n\n  if (rolePatterns.some(p => p.test(cleaned))) {\n    flags.push(`${fieldName}_role_based: \"${cleaned}\"`);\n    return null;\n  }\n\n  // Reject emails with known placeholder/test domains\n  const junkDomains = [\n    'example.com', 'example.org', 'example.net',\n    'test.com', 'test.org',\n    'placeholder.com',\n    'fake.com',\n    'noemail.com',\n    'nomail.com',\n    'none.com',\n    'localhost',\n    'mailinator.com',\n    'guerrillamail.com',\n    'tempmail.com',\n    'throwaway.email',\n    'yopmail.com'\n  ];\n\n  const domain = cleaned.split('@')[1];\n  if (junkDomains.includes(domain)) {\n    flags.push(`${fieldName}_junk_domain: \"${domain}\"`);\n    return null;\n  }\n\n  // Reject if local part is just numbers (often auto-generated)\n  const localPart = cleaned.split('@')[0];\n  if (/^\\d+$/.test(localPart)) {\n    flags.push(`${fieldName}_numeric_local: \"${cleaned}\"`);\n    return null;\n  }\n\n  // Check for double dots, leading/trailing dots in local part\n  if (localPart.startsWith('.') || localPart.endsWith('.') || localPart.includes('..')) {\n    flags.push(`${fieldName}_malformed_local: \"${cleaned}\"`);\n    return null;\n  }\n\n  return cleaned;\n}\n\ncontact.email_business = validateEmail(contact.email_business, 'email_business');\ncontact.email_personal = validateEmail(contact.email_personal, 'email_personal');\n\n\n// ═══════════════════════════════════════════════\n// PHONE VALIDATION (E.164 normalization)\n// ═══════════════════════════════════════════════\n\nfunction validatePhone(phone, fieldName) {\n  if (!phone) return null;\n\n  // Handle Apollo returning phone as object instead of string\n  if (typeof phone === 'object' && phone !== null) {\n    phone = phone.sanitized_number || phone.raw_number || phone.number || '';\n  }\n\n  // Strip everything except digits and leading +\n  let cleaned = phone.toString().trim();\n  const hasPlus = cleaned.startsWith('+');\n  cleaned = cleaned.replace(/[^\\d]/g, '');\n\n  if (!cleaned || cleaned.length === 0) {\n    flags.push(`${fieldName}_empty_after_strip`);\n    return null;\n  }\n\n  // US/CA normalization: should be 10 digits (or 11 with leading 1)\n  if (cleaned.length === 11 && cleaned.startsWith('1')) {\n    cleaned = cleaned; // already has country code\n  } else if (cleaned.length === 10) {\n    cleaned = '1' + cleaned; // prepend country code\n  } else if (cleaned.length < 10) {\n    flags.push(`${fieldName}_too_short: \"${phone}\" (${cleaned.length} digits)`);\n    return null;\n  } else if (cleaned.length > 11) {\n    // Could be international — keep it but flag for review\n    flags.push(`${fieldName}_possibly_international: \"${phone}\" (${cleaned.length} digits)`);\n    return '+' + cleaned;\n  }\n\n  // Validate US/CA area code (first digit after country code can't be 0 or 1)\n  const areaCode = cleaned.substring(1, 4);\n  if (areaCode.startsWith('0') || areaCode.startsWith('1')) {\n    flags.push(`${fieldName}_invalid_area_code: \"${areaCode}\"`);\n    return null;\n  }\n\n  return '+' + cleaned;\n}\n\ncontact.phone_direct = validatePhone(contact.phone_direct, 'phone_direct');\n\n\n// ═══════════════════════════════════════════════\n// NAME CLEANING\n// ═══════════════════════════════════════════════\n\nfunction cleanName(name, fieldName) {\n  if (!name) return null;\n\n  let cleaned = name.trim();\n\n  // Strip Apollo obfuscation artifacts (trailing *, partial names)\n  cleaned = cleaned.replace(/\\*+$/, '').trim();\n\n  // Reject single-character names\n  if (cleaned.length <= 1) {\n    flags.push(`${fieldName}_too_short: \"${name}\"`);\n    return null;\n  }\n\n  // Reject all-numeric \"names\"\n  if (/^\\d+$/.test(cleaned)) {\n    flags.push(`${fieldName}_numeric: \"${name}\"`);\n    return null;\n  }\n\n  // Reject names with numbers mixed in (likely data artifacts)\n  if (/\\d/.test(cleaned)) {\n    flags.push(`${fieldName}_contains_digits: \"${name}\"`);\n    return null;\n  }\n\n  // Reject names that are clearly not names\n  const junkNames = [\n    'unknown', 'n/a', 'na', 'none', 'null', 'test',\n    'owner', 'manager', 'admin', 'info', 'contact'\n  ];\n  if (junkNames.includes(cleaned.toLowerCase())) {\n    flags.push(`${fieldName}_junk_name: \"${name}\"`);\n    return null;\n  }\n\n  // Reject massage therapy credentials stored as names (Apollo artifact)\n  const credentials = [\n    'lmt', 'cmt', 'rmt', 'lmbt', 'lmp', 'bctmb', 'nctmb', 'nctm',\n    'cpt', 'cst', 'mld', 'nmt', 'amt', 'abmp'\n  ];\n  if (credentials.includes(cleaned.toLowerCase())) {\n    flags.push(`${fieldName}_credential_not_name: \"${name}\"`);\n    return null;\n  }\n\n  // Title case normalization: \"JANE\" → \"Jane\", \"jane\" → \"Jane\"\n  // Preserve already-correct casing like \"McDonald\", \"O'Brien\"\n  if (cleaned === cleaned.toUpperCase() || cleaned === cleaned.toLowerCase()) {\n    cleaned = cleaned.charAt(0).toUpperCase() + cleaned.slice(1).toLowerCase();\n  }\n\n  return cleaned;\n}\n\ncontact.first_name = cleanName(contact.first_name, 'first_name');\ncontact.last_name = cleanName(contact.last_name, 'last_name');\n\n// If first_name got nulled out, this contact is essentially useless\nif (!contact.first_name) {\n  flags.push('contact_has_no_valid_first_name');\n}\n\n\n// ═══════════════════════════════════════════════\n// LINKEDIN URL VALIDATION\n// ═══════════════════════════════════════════════\n\nfunction validateLinkedIn(url) {\n  if (!url) return null;\n\n  let cleaned = url.trim();\n\n  // Must contain linkedin.com/in/ for personal profiles\n  if (!/linkedin\\.com\\/in\\//i.test(cleaned)) {\n    // Could be a company page or malformed URL\n    if (/linkedin\\.com/i.test(cleaned)) {\n      flags.push(`linkedin_not_personal_profile: \"${cleaned}\"`);\n    } else {\n      flags.push(`linkedin_invalid_url: \"${cleaned}\"`);\n    }\n    return null;\n  }\n\n  // Ensure https:// prefix\n  if (!cleaned.startsWith('http')) {\n    cleaned = 'https://' + cleaned;\n  }\n\n  // Normalize to https\n  cleaned = cleaned.replace(/^http:\\/\\//, 'https://');\n\n  return cleaned;\n}\n\ncontact.linkedin_url = validateLinkedIn(contact.linkedin_url);\n\n\n// ═══════════════════════════════════════════════\n// LOCATION CLEANING\n// ═══════════════════════════════════════════════\n\nif (contact.location) {\n  contact.location = contact.location.trim();\n  // Null out empty-ish locations\n  if (!contact.location || contact.location === ',' || contact.location.length < 2) {\n    contact.location = null;\n    flags.push('location_empty_after_clean');\n  }\n}\n\n\n// ═══════════════════════════════════════════════\n// OUTPUT\n// ═══════════════════════════════════════════════\n\n// Update _has_contact based on whether we still have a valid first name\nconst hasValidContact = !!(contact.first_name);\n\nif (flags.length > 0) {\n  console.log(`Validation [${item._company_name}] (${item._source_method}): ${flags.join(', ')}`);\n}\n\nreturn {\n  json: {\n    _contact: contact,\n    _company_name: item._company_name,\n    _company_id: item._company_id,\n    _source_method: item._source_method,\n    _has_contact: hasValidContact,\n    _validation_flags: flags\n  }\n};",
      "upstream_refs": [],
      "ref_methods": [],
      "code_lines": 322
    },
    {
      "name": "Validate & Clean Contact2",
      "id": "ef1c6cd7-79c0-41e8-84d6-48d976da7f7b",
      "type": "code",
      "full_type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        16080,
        624
      ],
      "notes": "",
      "onError": "",
      "mode": "runOnceForEachItem",
      "incoming": [
        {
          "source": "No Domain Found Name?",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Insert Contact to Supabase",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "jsCode": "// Validate & Clean Contact\n// Cleans emails, phones, names, LinkedIn URLs before Supabase insert.\n// Nulls out invalid data rather than blocking the insert.\n// Adds _validation_flags array for audit trail.\n\nconst item = $input.item.json;\nconst contact = item._contact;\nconst flags = [];\n\n// If no contact object (shouldn't happen, but safety), pass through\nif (!contact) {\n  return {\n    json: {\n      ...item,\n      _validation_flags: ['no_contact_object']\n    }\n  };\n}\n\n// ═══════════════════════════════════════════════\n// EMAIL VALIDATION\n// ═══════════════════════════════════════════════\n\nfunction validateEmail(email, fieldName) {\n  if (!email) return null;\n\n  // Trim and lowercase\n  let cleaned = email.trim().toLowerCase();\n\n  // Basic format check: x@x.x\n  const emailRegex = /^[a-zA-Z0-9._%+\\-]+@[a-zA-Z0-9.\\-]+\\.[a-zA-Z]{2,}$/;\n  if (!emailRegex.test(cleaned)) {\n    flags.push(`${fieldName}_invalid_format: \"${email}\"`);\n    return null;\n  }\n\n  // Reject known junk/placeholder patterns\n  const junkPatterns = [\n    /^noreply@/,\n    /^no-reply@/,\n    /^donotreply@/,\n    /^do-not-reply@/,\n    /^test@/,\n    /^admin@example\\./,\n    /^info@example\\./,\n    /^user@example\\./,\n    /^sample@/,\n    /^fake@/,\n    /^placeholder@/,\n    /^null@/,\n    /^none@/,\n    /^na@/,\n    /^n\\/a@/,\n    /^unknown@/,\n    /^abuse@/,\n    /^postmaster@/,\n    /^mailer-daemon@/\n  ];\n\n  if (junkPatterns.some(p => p.test(cleaned))) {\n    flags.push(`${fieldName}_junk_pattern: \"${cleaned}\"`);\n    return null;\n  }\n\n  // Reject common role-based/generic emails (not personal)\n  const rolePatterns = [\n    /^info@/,\n    /^contact@/,\n    /^hello@/,\n    /^support@/,\n    /^sales@/,\n    /^office@/,\n    /^billing@/,\n    /^reception@/,\n    /^frontdesk@/,\n    /^front\\.desk@/,\n    /^appointments@/,\n    /^booking@/,\n    /^bookings@/,\n    /^schedule@/,\n    /^scheduling@/,\n    /^inquiries@/,\n    /^inquiry@/,\n    /^general@/,\n    /^team@/,\n    /^staff@/\n  ];\n\n  if (rolePatterns.some(p => p.test(cleaned))) {\n    flags.push(`${fieldName}_role_based: \"${cleaned}\"`);\n    return null;\n  }\n\n  // Reject emails with known placeholder/test domains\n  const junkDomains = [\n    'example.com', 'example.org', 'example.net',\n    'test.com', 'test.org',\n    'placeholder.com',\n    'fake.com',\n    'noemail.com',\n    'nomail.com',\n    'none.com',\n    'localhost',\n    'mailinator.com',\n    'guerrillamail.com',\n    'tempmail.com',\n    'throwaway.email',\n    'yopmail.com'\n  ];\n\n  const domain = cleaned.split('@')[1];\n  if (junkDomains.includes(domain)) {\n    flags.push(`${fieldName}_junk_domain: \"${domain}\"`);\n    return null;\n  }\n\n  // Reject if local part is just numbers (often auto-generated)\n  const localPart = cleaned.split('@')[0];\n  if (/^\\d+$/.test(localPart)) {\n    flags.push(`${fieldName}_numeric_local: \"${cleaned}\"`);\n    return null;\n  }\n\n  // Check for double dots, leading/trailing dots in local part\n  if (localPart.startsWith('.') || localPart.endsWith('.') || localPart.includes('..')) {\n    flags.push(`${fieldName}_malformed_local: \"${cleaned}\"`);\n    return null;\n  }\n\n  return cleaned;\n}\n\ncontact.email_business = validateEmail(contact.email_business, 'email_business');\ncontact.email_personal = validateEmail(contact.email_personal, 'email_personal');\n\n\n// ═══════════════════════════════════════════════\n// PHONE VALIDATION (E.164 normalization)\n// ═══════════════════════════════════════════════\n\nfunction validatePhone(phone, fieldName) {\n  if (!phone) return null;\n\n  // Handle Apollo returning phone as object instead of string\n  if (typeof phone === 'object' && phone !== null) {\n    phone = phone.sanitized_number || phone.raw_number || phone.number || '';\n  }\n\n  // Strip everything except digits and leading +\n  let cleaned = phone.toString().trim();\n  const hasPlus = cleaned.startsWith('+');\n  cleaned = cleaned.replace(/[^\\d]/g, '');\n\n  if (!cleaned || cleaned.length === 0) {\n    flags.push(`${fieldName}_empty_after_strip`);\n    return null;\n  }\n\n  // US/CA normalization: should be 10 digits (or 11 with leading 1)\n  if (cleaned.length === 11 && cleaned.startsWith('1')) {\n    cleaned = cleaned; // already has country code\n  } else if (cleaned.length === 10) {\n    cleaned = '1' + cleaned; // prepend country code\n  } else if (cleaned.length < 10) {\n    flags.push(`${fieldName}_too_short: \"${phone}\" (${cleaned.length} digits)`);\n    return null;\n  } else if (cleaned.length > 11) {\n    // Could be international — keep it but flag for review\n    flags.push(`${fieldName}_possibly_international: \"${phone}\" (${cleaned.length} digits)`);\n    return '+' + cleaned;\n  }\n\n  // Validate US/CA area code (first digit after country code can't be 0 or 1)\n  const areaCode = cleaned.substring(1, 4);\n  if (areaCode.startsWith('0') || areaCode.startsWith('1')) {\n    flags.push(`${fieldName}_invalid_area_code: \"${areaCode}\"`);\n    return null;\n  }\n\n  return '+' + cleaned;\n}\n\ncontact.phone_direct = validatePhone(contact.phone_direct, 'phone_direct');\n\n\n// ═══════════════════════════════════════════════\n// NAME CLEANING\n// ═══════════════════════════════════════════════\n\nfunction cleanName(name, fieldName) {\n  if (!name) return null;\n\n  let cleaned = name.trim();\n\n  // Strip Apollo obfuscation artifacts (trailing *, partial names)\n  cleaned = cleaned.replace(/\\*+$/, '').trim();\n\n  // Reject single-character names\n  if (cleaned.length <= 1) {\n    flags.push(`${fieldName}_too_short: \"${name}\"`);\n    return null;\n  }\n\n  // Reject all-numeric \"names\"\n  if (/^\\d+$/.test(cleaned)) {\n    flags.push(`${fieldName}_numeric: \"${name}\"`);\n    return null;\n  }\n\n  // Reject names with numbers mixed in (likely data artifacts)\n  if (/\\d/.test(cleaned)) {\n    flags.push(`${fieldName}_contains_digits: \"${name}\"`);\n    return null;\n  }\n\n  // Reject names that are clearly not names\n  const junkNames = [\n    'unknown', 'n/a', 'na', 'none', 'null', 'test',\n    'owner', 'manager', 'admin', 'info', 'contact'\n  ];\n  if (junkNames.includes(cleaned.toLowerCase())) {\n    flags.push(`${fieldName}_junk_name: \"${name}\"`);\n    return null;\n  }\n\n  // Reject massage therapy credentials stored as names (Apollo artifact)\n  const credentials = [\n    'lmt', 'cmt', 'rmt', 'lmbt', 'lmp', 'bctmb', 'nctmb', 'nctm',\n    'cpt', 'cst', 'mld', 'nmt', 'amt', 'abmp'\n  ];\n  if (credentials.includes(cleaned.toLowerCase())) {\n    flags.push(`${fieldName}_credential_not_name: \"${name}\"`);\n    return null;\n  }\n\n  // Title case normalization: \"JANE\" → \"Jane\", \"jane\" → \"Jane\"\n  // Preserve already-correct casing like \"McDonald\", \"O'Brien\"\n  if (cleaned === cleaned.toUpperCase() || cleaned === cleaned.toLowerCase()) {\n    cleaned = cleaned.charAt(0).toUpperCase() + cleaned.slice(1).toLowerCase();\n  }\n\n  return cleaned;\n}\n\ncontact.first_name = cleanName(contact.first_name, 'first_name');\ncontact.last_name = cleanName(contact.last_name, 'last_name');\n\n// If first_name got nulled out, this contact is essentially useless\nif (!contact.first_name) {\n  flags.push('contact_has_no_valid_first_name');\n}\n\n\n// ═══════════════════════════════════════════════\n// LINKEDIN URL VALIDATION\n// ═══════════════════════════════════════════════\n\nfunction validateLinkedIn(url) {\n  if (!url) return null;\n\n  let cleaned = url.trim();\n\n  // Must contain linkedin.com/in/ for personal profiles\n  if (!/linkedin\\.com\\/in\\//i.test(cleaned)) {\n    // Could be a company page or malformed URL\n    if (/linkedin\\.com/i.test(cleaned)) {\n      flags.push(`linkedin_not_personal_profile: \"${cleaned}\"`);\n    } else {\n      flags.push(`linkedin_invalid_url: \"${cleaned}\"`);\n    }\n    return null;\n  }\n\n  // Ensure https:// prefix\n  if (!cleaned.startsWith('http')) {\n    cleaned = 'https://' + cleaned;\n  }\n\n  // Normalize to https\n  cleaned = cleaned.replace(/^http:\\/\\//, 'https://');\n\n  return cleaned;\n}\n\ncontact.linkedin_url = validateLinkedIn(contact.linkedin_url);\n\n\n// ═══════════════════════════════════════════════\n// LOCATION CLEANING\n// ═══════════════════════════════════════════════\n\nif (contact.location) {\n  contact.location = contact.location.trim();\n  // Null out empty-ish locations\n  if (!contact.location || contact.location === ',' || contact.location.length < 2) {\n    contact.location = null;\n    flags.push('location_empty_after_clean');\n  }\n}\n\n\n// ═══════════════════════════════════════════════\n// OUTPUT\n// ═══════════════════════════════════════════════\n\n// Update _has_contact based on whether we still have a valid first name\nconst hasValidContact = !!(contact.first_name);\n\nif (flags.length > 0) {\n  console.log(`Validation [${item._company_name}] (${item._source_method}): ${flags.join(', ')}`);\n}\n\nreturn {\n  json: {\n    _contact: contact,\n    _company_name: item._company_name,\n    _company_id: item._company_id,\n    _source_method: item._source_method,\n    _has_contact: hasValidContact,\n    _validation_flags: flags\n  }\n};",
      "upstream_refs": [],
      "ref_methods": [],
      "code_lines": 322
    },
    {
      "name": "Validate & Clean Contact1",
      "id": "dae65b65-8ee9-40d0-8c97-40de12212eb3",
      "type": "code",
      "full_type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        16112,
        32
      ],
      "notes": "",
      "onError": "",
      "mode": "runOnceForEachItem",
      "incoming": [
        {
          "source": "Parse Apollo Enrich",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Insert Contact to Supabase",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "jsCode": "// Validate & Clean Contact\n// Cleans emails, phones, names, LinkedIn URLs before Supabase insert.\n// Nulls out invalid data rather than blocking the insert.\n// Adds _validation_flags array for audit trail.\n\nconst item = $input.item.json;\nconst contact = item._contact;\nconst flags = [];\n\n// If no contact object (shouldn't happen, but safety), pass through\nif (!contact) {\n  return {\n    json: {\n      ...item,\n      _validation_flags: ['no_contact_object']\n    }\n  };\n}\n\n// ═══════════════════════════════════════════════\n// EMAIL VALIDATION\n// ═══════════════════════════════════════════════\n\nfunction validateEmail(email, fieldName) {\n  if (!email) return null;\n\n  // Trim and lowercase\n  let cleaned = email.trim().toLowerCase();\n\n  // Basic format check: x@x.x\n  const emailRegex = /^[a-zA-Z0-9._%+\\-]+@[a-zA-Z0-9.\\-]+\\.[a-zA-Z]{2,}$/;\n  if (!emailRegex.test(cleaned)) {\n    flags.push(`${fieldName}_invalid_format: \"${email}\"`);\n    return null;\n  }\n\n  // Reject known junk/placeholder patterns\n  const junkPatterns = [\n    /^noreply@/,\n    /^no-reply@/,\n    /^donotreply@/,\n    /^do-not-reply@/,\n    /^test@/,\n    /^admin@example\\./,\n    /^info@example\\./,\n    /^user@example\\./,\n    /^sample@/,\n    /^fake@/,\n    /^placeholder@/,\n    /^null@/,\n    /^none@/,\n    /^na@/,\n    /^n\\/a@/,\n    /^unknown@/,\n    /^abuse@/,\n    /^postmaster@/,\n    /^mailer-daemon@/\n  ];\n\n  if (junkPatterns.some(p => p.test(cleaned))) {\n    flags.push(`${fieldName}_junk_pattern: \"${cleaned}\"`);\n    return null;\n  }\n\n  // Reject common role-based/generic emails (not personal)\n  const rolePatterns = [\n    /^info@/,\n    /^contact@/,\n    /^hello@/,\n    /^support@/,\n    /^sales@/,\n    /^office@/,\n    /^billing@/,\n    /^reception@/,\n    /^frontdesk@/,\n    /^front\\.desk@/,\n    /^appointments@/,\n    /^booking@/,\n    /^bookings@/,\n    /^schedule@/,\n    /^scheduling@/,\n    /^inquiries@/,\n    /^inquiry@/,\n    /^general@/,\n    /^team@/,\n    /^staff@/\n  ];\n\n  if (rolePatterns.some(p => p.test(cleaned))) {\n    flags.push(`${fieldName}_role_based: \"${cleaned}\"`);\n    return null;\n  }\n\n  // Reject emails with known placeholder/test domains\n  const junkDomains = [\n    'example.com', 'example.org', 'example.net',\n    'test.com', 'test.org',\n    'placeholder.com',\n    'fake.com',\n    'noemail.com',\n    'nomail.com',\n    'none.com',\n    'localhost',\n    'mailinator.com',\n    'guerrillamail.com',\n    'tempmail.com',\n    'throwaway.email',\n    'yopmail.com'\n  ];\n\n  const domain = cleaned.split('@')[1];\n  if (junkDomains.includes(domain)) {\n    flags.push(`${fieldName}_junk_domain: \"${domain}\"`);\n    return null;\n  }\n\n  // Reject if local part is just numbers (often auto-generated)\n  const localPart = cleaned.split('@')[0];\n  if (/^\\d+$/.test(localPart)) {\n    flags.push(`${fieldName}_numeric_local: \"${cleaned}\"`);\n    return null;\n  }\n\n  // Check for double dots, leading/trailing dots in local part\n  if (localPart.startsWith('.') || localPart.endsWith('.') || localPart.includes('..')) {\n    flags.push(`${fieldName}_malformed_local: \"${cleaned}\"`);\n    return null;\n  }\n\n  return cleaned;\n}\n\ncontact.email_business = validateEmail(contact.email_business, 'email_business');\ncontact.email_personal = validateEmail(contact.email_personal, 'email_personal');\n\n\n// ═══════════════════════════════════════════════\n// PHONE VALIDATION (E.164 normalization)\n// ═══════════════════════════════════════════════\n\nfunction validatePhone(phone, fieldName) {\n  if (!phone) return null;\n\n  // Handle Apollo returning phone as object instead of string\n  if (typeof phone === 'object' && phone !== null) {\n    phone = phone.sanitized_number || phone.raw_number || phone.number || '';\n  }\n\n  // Strip everything except digits and leading +\n  let cleaned = phone.toString().trim();\n  const hasPlus = cleaned.startsWith('+');\n  cleaned = cleaned.replace(/[^\\d]/g, '');\n\n  if (!cleaned || cleaned.length === 0) {\n    flags.push(`${fieldName}_empty_after_strip`);\n    return null;\n  }\n\n  // US/CA normalization: should be 10 digits (or 11 with leading 1)\n  if (cleaned.length === 11 && cleaned.startsWith('1')) {\n    cleaned = cleaned; // already has country code\n  } else if (cleaned.length === 10) {\n    cleaned = '1' + cleaned; // prepend country code\n  } else if (cleaned.length < 10) {\n    flags.push(`${fieldName}_too_short: \"${phone}\" (${cleaned.length} digits)`);\n    return null;\n  } else if (cleaned.length > 11) {\n    // Could be international — keep it but flag for review\n    flags.push(`${fieldName}_possibly_international: \"${phone}\" (${cleaned.length} digits)`);\n    return '+' + cleaned;\n  }\n\n  // Validate US/CA area code (first digit after country code can't be 0 or 1)\n  const areaCode = cleaned.substring(1, 4);\n  if (areaCode.startsWith('0') || areaCode.startsWith('1')) {\n    flags.push(`${fieldName}_invalid_area_code: \"${areaCode}\"`);\n    return null;\n  }\n\n  return '+' + cleaned;\n}\n\ncontact.phone_direct = validatePhone(contact.phone_direct, 'phone_direct');\n\n\n// ═══════════════════════════════════════════════\n// NAME CLEANING\n// ═══════════════════════════════════════════════\n\nfunction cleanName(name, fieldName) {\n  if (!name) return null;\n\n  let cleaned = name.trim();\n\n  // Strip Apollo obfuscation artifacts (trailing *, partial names)\n  cleaned = cleaned.replace(/\\*+$/, '').trim();\n\n  // Reject single-character names\n  if (cleaned.length <= 1) {\n    flags.push(`${fieldName}_too_short: \"${name}\"`);\n    return null;\n  }\n\n  // Reject all-numeric \"names\"\n  if (/^\\d+$/.test(cleaned)) {\n    flags.push(`${fieldName}_numeric: \"${name}\"`);\n    return null;\n  }\n\n  // Reject names with numbers mixed in (likely data artifacts)\n  if (/\\d/.test(cleaned)) {\n    flags.push(`${fieldName}_contains_digits: \"${name}\"`);\n    return null;\n  }\n\n  // Reject names that are clearly not names\n  const junkNames = [\n    'unknown', 'n/a', 'na', 'none', 'null', 'test',\n    'owner', 'manager', 'admin', 'info', 'contact'\n  ];\n  if (junkNames.includes(cleaned.toLowerCase())) {\n    flags.push(`${fieldName}_junk_name: \"${name}\"`);\n    return null;\n  }\n\n  // Reject massage therapy credentials stored as names (Apollo artifact)\n  const credentials = [\n    'lmt', 'cmt', 'rmt', 'lmbt', 'lmp', 'bctmb', 'nctmb', 'nctm',\n    'cpt', 'cst', 'mld', 'nmt', 'amt', 'abmp'\n  ];\n  if (credentials.includes(cleaned.toLowerCase())) {\n    flags.push(`${fieldName}_credential_not_name: \"${name}\"`);\n    return null;\n  }\n\n  // Title case normalization: \"JANE\" → \"Jane\", \"jane\" → \"Jane\"\n  // Preserve already-correct casing like \"McDonald\", \"O'Brien\"\n  if (cleaned === cleaned.toUpperCase() || cleaned === cleaned.toLowerCase()) {\n    cleaned = cleaned.charAt(0).toUpperCase() + cleaned.slice(1).toLowerCase();\n  }\n\n  return cleaned;\n}\n\ncontact.first_name = cleanName(contact.first_name, 'first_name');\ncontact.last_name = cleanName(contact.last_name, 'last_name');\n\n// If first_name got nulled out, this contact is essentially useless\nif (!contact.first_name) {\n  flags.push('contact_has_no_valid_first_name');\n}\n\n\n// ═══════════════════════════════════════════════\n// LINKEDIN URL VALIDATION\n// ═══════════════════════════════════════════════\n\nfunction validateLinkedIn(url) {\n  if (!url) return null;\n\n  let cleaned = url.trim();\n\n  // Must contain linkedin.com/in/ for personal profiles\n  if (!/linkedin\\.com\\/in\\//i.test(cleaned)) {\n    // Could be a company page or malformed URL\n    if (/linkedin\\.com/i.test(cleaned)) {\n      flags.push(`linkedin_not_personal_profile: \"${cleaned}\"`);\n    } else {\n      flags.push(`linkedin_invalid_url: \"${cleaned}\"`);\n    }\n    return null;\n  }\n\n  // Ensure https:// prefix\n  if (!cleaned.startsWith('http')) {\n    cleaned = 'https://' + cleaned;\n  }\n\n  // Normalize to https\n  cleaned = cleaned.replace(/^http:\\/\\//, 'https://');\n\n  return cleaned;\n}\n\ncontact.linkedin_url = validateLinkedIn(contact.linkedin_url);\n\n\n// ═══════════════════════════════════════════════\n// LOCATION CLEANING\n// ═══════════════════════════════════════════════\n\nif (contact.location) {\n  contact.location = contact.location.trim();\n  // Null out empty-ish locations\n  if (!contact.location || contact.location === ',' || contact.location.length < 2) {\n    contact.location = null;\n    flags.push('location_empty_after_clean');\n  }\n}\n\n\n// ═══════════════════════════════════════════════\n// OUTPUT\n// ═══════════════════════════════════════════════\n\n// Update _has_contact based on whether we still have a valid first name\nconst hasValidContact = !!(contact.first_name);\n\nif (flags.length > 0) {\n  console.log(`Validation [${item._company_name}] (${item._source_method}): ${flags.join(', ')}`);\n}\n\nreturn {\n  json: {\n    _contact: contact,\n    _company_name: item._company_name,\n    _company_id: item._company_id,\n    _source_method: item._source_method,\n    _has_contact: hasValidContact,\n    _validation_flags: flags\n  }\n};",
      "upstream_refs": [],
      "ref_methods": [],
      "code_lines": 322
    },
    {
      "name": "Validate & Clean Contact",
      "id": "78ec8b0a-9b29-4c6f-84b0-5591436a7649",
      "type": "code",
      "full_type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        16128,
        -160
      ],
      "notes": "",
      "onError": "",
      "mode": "runOnceForEachItem",
      "incoming": [
        {
          "source": "Prepare Solo Contact",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Insert Contact to Supabase",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "jsCode": "// Validate & Clean Contact\n// Cleans emails, phones, names, LinkedIn URLs before Supabase insert.\n// Nulls out invalid data rather than blocking the insert.\n// Adds _validation_flags array for audit trail.\n\nconst item = $input.item.json;\nconst contact = item._contact;\nconst flags = [];\n\n// If no contact object (shouldn't happen, but safety), pass through\nif (!contact) {\n  return {\n    json: {\n      ...item,\n      _validation_flags: ['no_contact_object']\n    }\n  };\n}\n\n// ═══════════════════════════════════════════════\n// EMAIL VALIDATION\n// ═══════════════════════════════════════════════\n\nfunction validateEmail(email, fieldName) {\n  if (!email) return null;\n\n  // Trim and lowercase\n  let cleaned = email.trim().toLowerCase();\n\n  // Basic format check: x@x.x\n  const emailRegex = /^[a-zA-Z0-9._%+\\-]+@[a-zA-Z0-9.\\-]+\\.[a-zA-Z]{2,}$/;\n  if (!emailRegex.test(cleaned)) {\n    flags.push(`${fieldName}_invalid_format: \"${email}\"`);\n    return null;\n  }\n\n  // Reject known junk/placeholder patterns\n  const junkPatterns = [\n    /^noreply@/,\n    /^no-reply@/,\n    /^donotreply@/,\n    /^do-not-reply@/,\n    /^test@/,\n    /^admin@example\\./,\n    /^info@example\\./,\n    /^user@example\\./,\n    /^sample@/,\n    /^fake@/,\n    /^placeholder@/,\n    /^null@/,\n    /^none@/,\n    /^na@/,\n    /^n\\/a@/,\n    /^unknown@/,\n    /^abuse@/,\n    /^postmaster@/,\n    /^mailer-daemon@/\n  ];\n\n  if (junkPatterns.some(p => p.test(cleaned))) {\n    flags.push(`${fieldName}_junk_pattern: \"${cleaned}\"`);\n    return null;\n  }\n\n  // Reject common role-based/generic emails (not personal)\n  const rolePatterns = [\n    /^info@/,\n    /^contact@/,\n    /^hello@/,\n    /^support@/,\n    /^sales@/,\n    /^office@/,\n    /^billing@/,\n    /^reception@/,\n    /^frontdesk@/,\n    /^front\\.desk@/,\n    /^appointments@/,\n    /^booking@/,\n    /^bookings@/,\n    /^schedule@/,\n    /^scheduling@/,\n    /^inquiries@/,\n    /^inquiry@/,\n    /^general@/,\n    /^team@/,\n    /^staff@/\n  ];\n\n  if (rolePatterns.some(p => p.test(cleaned))) {\n    flags.push(`${fieldName}_role_based: \"${cleaned}\"`);\n    return null;\n  }\n\n  // Reject emails with known placeholder/test domains\n  const junkDomains = [\n    'example.com', 'example.org', 'example.net',\n    'test.com', 'test.org',\n    'placeholder.com',\n    'fake.com',\n    'noemail.com',\n    'nomail.com',\n    'none.com',\n    'localhost',\n    'mailinator.com',\n    'guerrillamail.com',\n    'tempmail.com',\n    'throwaway.email',\n    'yopmail.com'\n  ];\n\n  const domain = cleaned.split('@')[1];\n  if (junkDomains.includes(domain)) {\n    flags.push(`${fieldName}_junk_domain: \"${domain}\"`);\n    return null;\n  }\n\n  // Reject if local part is just numbers (often auto-generated)\n  const localPart = cleaned.split('@')[0];\n  if (/^\\d+$/.test(localPart)) {\n    flags.push(`${fieldName}_numeric_local: \"${cleaned}\"`);\n    return null;\n  }\n\n  // Check for double dots, leading/trailing dots in local part\n  if (localPart.startsWith('.') || localPart.endsWith('.') || localPart.includes('..')) {\n    flags.push(`${fieldName}_malformed_local: \"${cleaned}\"`);\n    return null;\n  }\n\n  return cleaned;\n}\n\ncontact.email_business = validateEmail(contact.email_business, 'email_business');\ncontact.email_personal = validateEmail(contact.email_personal, 'email_personal');\n\n\n// ═══════════════════════════════════════════════\n// PHONE VALIDATION (E.164 normalization)\n// ═══════════════════════════════════════════════\n\nfunction validatePhone(phone, fieldName) {\n  if (!phone) return null;\n\n  // Handle Apollo returning phone as object instead of string\n  if (typeof phone === 'object' && phone !== null) {\n    phone = phone.sanitized_number || phone.raw_number || phone.number || '';\n  }\n\n  // Strip everything except digits and leading +\n  let cleaned = phone.toString().trim();\n  const hasPlus = cleaned.startsWith('+');\n  cleaned = cleaned.replace(/[^\\d]/g, '');\n\n  if (!cleaned || cleaned.length === 0) {\n    flags.push(`${fieldName}_empty_after_strip`);\n    return null;\n  }\n\n  // US/CA normalization: should be 10 digits (or 11 with leading 1)\n  if (cleaned.length === 11 && cleaned.startsWith('1')) {\n    cleaned = cleaned; // already has country code\n  } else if (cleaned.length === 10) {\n    cleaned = '1' + cleaned; // prepend country code\n  } else if (cleaned.length < 10) {\n    flags.push(`${fieldName}_too_short: \"${phone}\" (${cleaned.length} digits)`);\n    return null;\n  } else if (cleaned.length > 11) {\n    // Could be international — keep it but flag for review\n    flags.push(`${fieldName}_possibly_international: \"${phone}\" (${cleaned.length} digits)`);\n    return '+' + cleaned;\n  }\n\n  // Validate US/CA area code (first digit after country code can't be 0 or 1)\n  const areaCode = cleaned.substring(1, 4);\n  if (areaCode.startsWith('0') || areaCode.startsWith('1')) {\n    flags.push(`${fieldName}_invalid_area_code: \"${areaCode}\"`);\n    return null;\n  }\n\n  return '+' + cleaned;\n}\n\ncontact.phone_direct = validatePhone(contact.phone_direct, 'phone_direct');\n\n\n// ═══════════════════════════════════════════════\n// NAME CLEANING\n// ═══════════════════════════════════════════════\n\nfunction cleanName(name, fieldName) {\n  if (!name) return null;\n\n  let cleaned = name.trim();\n\n  // Strip Apollo obfuscation artifacts (trailing *, partial names)\n  cleaned = cleaned.replace(/\\*+$/, '').trim();\n\n  // Reject single-character names\n  if (cleaned.length <= 1) {\n    flags.push(`${fieldName}_too_short: \"${name}\"`);\n    return null;\n  }\n\n  // Reject all-numeric \"names\"\n  if (/^\\d+$/.test(cleaned)) {\n    flags.push(`${fieldName}_numeric: \"${name}\"`);\n    return null;\n  }\n\n  // Reject names with numbers mixed in (likely data artifacts)\n  if (/\\d/.test(cleaned)) {\n    flags.push(`${fieldName}_contains_digits: \"${name}\"`);\n    return null;\n  }\n\n  // Reject names that are clearly not names\n  const junkNames = [\n    'unknown', 'n/a', 'na', 'none', 'null', 'test',\n    'owner', 'manager', 'admin', 'info', 'contact'\n  ];\n  if (junkNames.includes(cleaned.toLowerCase())) {\n    flags.push(`${fieldName}_junk_name: \"${name}\"`);\n    return null;\n  }\n\n  // Reject massage therapy credentials stored as names (Apollo artifact)\n  const credentials = [\n    'lmt', 'cmt', 'rmt', 'lmbt', 'lmp', 'bctmb', 'nctmb', 'nctm',\n    'cpt', 'cst', 'mld', 'nmt', 'amt', 'abmp'\n  ];\n  if (credentials.includes(cleaned.toLowerCase())) {\n    flags.push(`${fieldName}_credential_not_name: \"${name}\"`);\n    return null;\n  }\n\n  // Title case normalization: \"JANE\" → \"Jane\", \"jane\" → \"Jane\"\n  // Preserve already-correct casing like \"McDonald\", \"O'Brien\"\n  if (cleaned === cleaned.toUpperCase() || cleaned === cleaned.toLowerCase()) {\n    cleaned = cleaned.charAt(0).toUpperCase() + cleaned.slice(1).toLowerCase();\n  }\n\n  return cleaned;\n}\n\ncontact.first_name = cleanName(contact.first_name, 'first_name');\ncontact.last_name = cleanName(contact.last_name, 'last_name');\n\n// If first_name got nulled out, this contact is essentially useless\nif (!contact.first_name) {\n  flags.push('contact_has_no_valid_first_name');\n}\n\n\n// ═══════════════════════════════════════════════\n// LINKEDIN URL VALIDATION\n// ═══════════════════════════════════════════════\n\nfunction validateLinkedIn(url) {\n  if (!url) return null;\n\n  let cleaned = url.trim();\n\n  // Must contain linkedin.com/in/ for personal profiles\n  if (!/linkedin\\.com\\/in\\//i.test(cleaned)) {\n    // Could be a company page or malformed URL\n    if (/linkedin\\.com/i.test(cleaned)) {\n      flags.push(`linkedin_not_personal_profile: \"${cleaned}\"`);\n    } else {\n      flags.push(`linkedin_invalid_url: \"${cleaned}\"`);\n    }\n    return null;\n  }\n\n  // Ensure https:// prefix\n  if (!cleaned.startsWith('http')) {\n    cleaned = 'https://' + cleaned;\n  }\n\n  // Normalize to https\n  cleaned = cleaned.replace(/^http:\\/\\//, 'https://');\n\n  return cleaned;\n}\n\ncontact.linkedin_url = validateLinkedIn(contact.linkedin_url);\n\n\n// ═══════════════════════════════════════════════\n// LOCATION CLEANING\n// ═══════════════════════════════════════════════\n\nif (contact.location) {\n  contact.location = contact.location.trim();\n  // Null out empty-ish locations\n  if (!contact.location || contact.location === ',' || contact.location.length < 2) {\n    contact.location = null;\n    flags.push('location_empty_after_clean');\n  }\n}\n\n\n// ═══════════════════════════════════════════════\n// OUTPUT\n// ═══════════════════════════════════════════════\n\n// Update _has_contact based on whether we still have a valid first name\nconst hasValidContact = !!(contact.first_name);\n\nif (flags.length > 0) {\n  console.log(`Validation [${item._company_name}] (${item._source_method}): ${flags.join(', ')}`);\n}\n\nreturn {\n  json: {\n    _contact: contact,\n    _company_name: item._company_name,\n    _company_id: item._company_id,\n    _source_method: item._source_method,\n    _has_contact: hasValidContact,\n    _validation_flags: flags\n  }\n};",
      "upstream_refs": [],
      "ref_methods": [],
      "code_lines": 322
    },
    {
      "name": "Insert Contact to Supabase",
      "id": "e31d3abb-2a94-4a24-b668-4edeb0483f6a",
      "type": "httpRequest",
      "full_type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        16352,
        304
      ],
      "notes": "Inserts contact into Supabase contacts table. All paths (solo, apollo, website) converge here with the same _contact shape.",
      "onError": "continueRegularOutput",
      "mode": "",
      "incoming": [
        {
          "source": "Validate & Clean Contact",
          "output_idx": 0,
          "input_idx": 0
        },
        {
          "source": "Validate & Clean Contact1",
          "output_idx": 0,
          "input_idx": 0
        },
        {
          "source": "Validate & Clean Contact3",
          "output_idx": 0,
          "input_idx": 0
        },
        {
          "source": "Validate & Clean Contact4",
          "output_idx": 0,
          "input_idx": 0
        },
        {
          "source": "Validate & Clean Contact2",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Run Summary3",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "http_method": "POST",
      "http_url": "={{ $env.SUPABASE_URL }}/rest/v1/contacts",
      "http_sendHeaders": true,
      "http_headers": [
        {
          "name": "apikey",
          "value": "={{ $env.SUPABASE_SERVICE_KEY }}"
        },
        {
          "name": "Authorization",
          "value": "=Bearer {{ $env.SUPABASE_SERVICE_KEY }}"
        },
        {
          "name": "Content-Type",
          "value": "application/json"
        },
        {
          "name": "Prefer",
          "value": "return=minimal"
        }
      ],
      "http_sendBody": true,
      "http_bodyType": "json",
      "http_jsonBody": "={{ JSON.stringify($json._contact) }}",
      "http_body": "",
      "http_options": {
        "batching": {
          "batch": {
            "batchSize": 10,
            "batchInterval": 500
          }
        }
      },
      "http_batching": {
        "batch": {
          "batchSize": 10,
          "batchInterval": 500
        }
      },
      "http_timeout": null,
      "http_sendQuery": false,
      "http_queryParams": []
    },
    {
      "name": "Run Summary3",
      "id": "5348f2b3-d72b-4a66-9ecb-9631da22e8f2",
      "type": "code",
      "full_type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        16640,
        144
      ],
      "notes": "Final summary: contacts created from each source (solo detection, Apollo, website scrape, name extraction).",
      "onError": "",
      "mode": "",
      "incoming": [
        {
          "source": "About Found Name?",
          "output_idx": 1,
          "input_idx": 0
        },
        {
          "source": "No Domain Found Name?",
          "output_idx": 1,
          "input_idx": 0
        },
        {
          "source": "Insert Contact to Supabase",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Bridge to 4",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "jsCode": "// Collect stats from all paths\nconst config = $('Step 3a Config').first().json;\nlet companiesProcessed = 0;\nlet soloDetected = 0;\nlet soloWithName = 0;\nlet apolloSearched = 0;\nlet apolloFound = 0;\nlet apolloEnriched = 0;\nlet websiteScraped = 0;\nlet websiteFoundName = 0;\nlet noDomainFallback = 0;\nlet noDomainFoundName = 0;\nlet totalContactsInserted = 0;\n\n// Validation stats\nlet validationTotal = 0;\nlet emailsNulled = 0;\nlet phonesNulled = 0;\nlet namesNulled = 0;\nlet linkedinNulled = 0;\nlet roleBasedEmails = 0;\nlet contactsWithFlags = 0;\nlet allFlags = [];\n\ntry {\n  const batchItems = $('Filter & Parse Batch').all();\n  companiesProcessed = batchItems.filter(i => !i.json._empty).length;\n} catch(e) {}\n\ntry {\n  const soloItems = $('Prepare Solo Contact').all();\n  soloDetected = soloItems.length;\n  soloWithName = soloItems.filter(i => i.json._has_contact).length;\n} catch(e) {}\n\ntry {\n  const apolloItems = $('Parse Apollo Search').all();\n  apolloSearched = apolloItems.length;\n  apolloFound = apolloItems.filter(i => i.json._apollo_found).length;\n} catch(e) {}\n\ntry {\n  const enrichItems = $('Parse Apollo Enrich').all();\n  apolloEnriched = enrichItems.filter(i => i.json._has_contact).length;\n} catch(e) {}\n\ntry {\n  const searchOnlyItems = $('Apollo Search Only Contact').all();\n  apolloEnriched += searchOnlyItems.filter(i => i.json._has_contact).length;\n} catch(e) {}\n\ntry {\n  const aboutItems = $('Parse About Page').all();\n  websiteScraped = aboutItems.length;\n  websiteFoundName = aboutItems.filter(i => i.json._has_contact).length;\n} catch(e) {}\n\ntry {\n  const noDomainItems = $('No Domain Fallback').all();\n  noDomainFallback = noDomainItems.length;\n  noDomainFoundName = noDomainItems.filter(i => i.json._has_contact).length;\n} catch(e) {}\n\n// Collect validation stats from all 5 Validate & Clean nodes\nconst validateNodeNames = [\n  'Validate & Clean Contact',\n  'Validate & Clean Contact1',\n  'Validate & Clean Contact2',\n  'Validate & Clean Contact3',\n  'Validate & Clean Contact4'\n];\n\nfor (const nodeName of validateNodeNames) {\n  try {\n    const validatedItems = $(nodeName).all();\n    validationTotal += validatedItems.length;\n    for (const item of validatedItems) {\n      const flags = item.json._validation_flags || [];\n      if (flags.length > 0) {\n        contactsWithFlags++;\n        allFlags.push(...flags);\n      }\n    }\n  } catch(e) {\n    // Node didn't execute in this run (normal - not all paths fire every time)\n  }\n}\n\nemailsNulled = allFlags.filter(f => f.startsWith('email_business_') || f.startsWith('email_personal_')).length;\nphonesNulled = allFlags.filter(f => f.startsWith('phone_direct_')).length;\nnamesNulled = allFlags.filter(f => f.startsWith('first_name_') || f.startsWith('last_name_') || f === 'contact_has_no_valid_first_name').length;\nlinkedinNulled = allFlags.filter(f => f.startsWith('linkedin_')).length;\nroleBasedEmails = allFlags.filter(f => f.includes('_role_based')).length;\n\ntotalContactsInserted = soloWithName + apolloEnriched + websiteFoundName + noDomainFoundName;\n\nconst summary = {\n  run_completed_at: new Date().toISOString(),\n  batch_size: config.batch_size,\n  companies_processed: companiesProcessed,\n  solo_detected: soloDetected,\n  solo_with_name_extracted: soloWithName,\n  apollo_searched: apolloSearched,\n  apollo_found_people: apolloFound,\n  apollo_contacts_created: apolloEnriched,\n  website_scraped: websiteScraped,\n  website_names_found: websiteFoundName,\n  no_domain_fallback: noDomainFallback,\n  no_domain_names_found: noDomainFoundName,\n  total_contacts_inserted: totalContactsInserted,\n  companies_without_contacts: companiesProcessed - totalContactsInserted,\n  validation: {\n    contacts_validated: validationTotal,\n    contacts_with_issues: contactsWithFlags,\n    emails_nulled: emailsNulled,\n    role_based_emails_rejected: roleBasedEmails,\n    phones_nulled: phonesNulled,\n    names_nulled: namesNulled,\n    linkedin_nulled: linkedinNulled,\n    all_flags: allFlags\n  },\n  message: `Created ${totalContactsInserted} contacts from ${companiesProcessed} companies. Sources: ${soloWithName} solo, ${apolloEnriched} Apollo, ${websiteFoundName} website, ${noDomainFoundName} name extraction. Validation cleaned ${contactsWithFlags}/${validationTotal} contacts (${emailsNulled} emails, ${phonesNulled} phones, ${namesNulled} names nulled).`\n};\n\nconsole.log('=== STEP 3a: FIND PEOPLE SUMMARY ===');\nconsole.log(JSON.stringify(summary, null, 2));\n\nreturn [{ json: summary }];",
      "upstream_refs": [
        "Parse About Page",
        "Filter & Parse Batch",
        "Step 3a Config",
        "Prepare Solo Contact",
        "Apollo Search Only Contact",
        "Parse Apollo Enrich",
        "Parse Apollo Search",
        "No Domain Fallback"
      ],
      "ref_methods": [
        {
          "node": "Step 3a Config",
          "method": "first"
        },
        {
          "node": "Filter & Parse Batch",
          "method": "all"
        },
        {
          "node": "Prepare Solo Contact",
          "method": "all"
        },
        {
          "node": "Parse Apollo Search",
          "method": "all"
        },
        {
          "node": "Parse Apollo Enrich",
          "method": "all"
        },
        {
          "node": "Apollo Search Only Contact",
          "method": "all"
        },
        {
          "node": "Parse About Page",
          "method": "all"
        },
        {
          "node": "No Domain Fallback",
          "method": "all"
        }
      ],
      "code_lines": 128
    },
    {
      "name": "Bridge to 4",
      "id": "bbee8b1b-c4e8-493c-9f1f-54bd6f8ddd8c",
      "type": "code",
      "full_type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        16864,
        144
      ],
      "notes": "",
      "onError": "",
      "mode": "",
      "incoming": [
        {
          "source": "Run Summary3",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Step 4 Config",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "jsCode": "// Collapse all input items into a single trigger item for the next step\nreturn [{ json: { _trigger: 'continue', _timestamp: new Date().toISOString() } }];",
      "upstream_refs": [],
      "ref_methods": [],
      "code_lines": 2
    },
    {
      "name": "Step 4 Config",
      "id": "782a2bfd-6b39-401a-aacc-f36090c307a3",
      "type": "set",
      "full_type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        17088,
        144
      ],
      "notes": "Config for Step 4: Enrich People.\n- skip_hunter/skip_snovio: set to 'true' to disable. Set to 'false' when ready.\n- skip_hunter_verifier: 'true' = skip email verification, 'false' = verify emails via Hunter\n- skip_namsor: 'false' = enabled (NamSor API key required as NAMSOR_API_KEY env var)\n- batch_size: how many contacts to process",
      "onError": "",
      "mode": "",
      "incoming": [
        {
          "source": "Bridge to 4",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Fetch Contacts",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "set_assignments": [
        {
          "id": "batch-size",
          "name": "batch_size",
          "value": "10",
          "type": "string"
        },
        {
          "id": "batch-offset",
          "name": "batch_offset",
          "value": "0",
          "type": "string"
        },
        {
          "id": "skip-hunter",
          "name": "skip_hunter",
          "value": "false",
          "type": "string"
        },
        {
          "id": "skip-snovio",
          "name": "skip_snovio",
          "value": "true",
          "type": "string"
        },
        {
          "id": "skip-namsor",
          "name": "skip_namsor",
          "value": "false",
          "type": "string"
        },
        {
          "id": "skip-hunter-verifier",
          "name": "skip_hunter_verifier",
          "value": "false",
          "type": "string"
        }
      ],
      "set_options": {}
    },
    {
      "name": "Fetch Contacts",
      "id": "d334ed75-e0ca-4491-8cf7-8f206fe00170",
      "type": "httpRequest",
      "full_type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        17312,
        144
      ],
      "notes": "Fetches all contacts from Supabase for enrichment",
      "onError": "continueRegularOutput",
      "mode": "",
      "incoming": [
        {
          "source": "Step 4 Config",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Collapse to Single",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "http_method": "GET",
      "http_url": "={{ $env.SUPABASE_URL }}/rest/v1/contacts?select=id,company_id,first_name,last_name,role,is_owner,email_business,email_personal,phone_direct,linkedin_url,cultural_affinity,source,email_status&order=created_at.asc&limit={{ $json.batch_size }}&offset={{ $json.batch_offset }}",
      "http_sendHeaders": true,
      "http_headers": [
        {
          "name": "apikey",
          "value": "={{ $env.SUPABASE_SERVICE_KEY }}"
        },
        {
          "name": "Authorization",
          "value": "=Bearer {{ $env.SUPABASE_SERVICE_KEY }}"
        }
      ],
      "http_sendBody": false,
      "http_bodyType": "",
      "http_jsonBody": "",
      "http_body": "",
      "http_options": {
        "timeout": 30000
      },
      "http_batching": null,
      "http_timeout": 30000,
      "http_sendQuery": false,
      "http_queryParams": []
    },
    {
      "name": "Collapse to Single",
      "id": "81541afe-d0b6-41be-9d80-0b96c9d4a75e",
      "type": "code",
      "full_type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        17536,
        144
      ],
      "notes": "",
      "onError": "",
      "mode": "",
      "incoming": [
        {
          "source": "Fetch Contacts",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Fetch Companies1",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "jsCode": "// Collapse to single item - Fetch Contacts data is accessed by name in Filter & Merge\nreturn [{ json: { _trigger: 'fetch_companies' } }];",
      "upstream_refs": [],
      "ref_methods": [],
      "code_lines": 2
    },
    {
      "name": "Fetch Companies1",
      "id": "68877820-7fb4-4486-85cd-63caf86809cb",
      "type": "httpRequest",
      "full_type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        17760,
        144
      ],
      "notes": "Fetches company data (domain, phone, city) to support enrichment lookups",
      "onError": "continueRegularOutput",
      "mode": "",
      "incoming": [
        {
          "source": "Collapse to Single",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Filter & Merge Contacts",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "http_method": "GET",
      "http_url": "={{ $env.SUPABASE_URL }}/rest/v1/companies?select=id,name,phone,domain,city,state&enrichment_status=in.(partially_enriched,fully_enriched)",
      "http_sendHeaders": true,
      "http_headers": [
        {
          "name": "apikey",
          "value": "={{ $env.SUPABASE_SERVICE_KEY }}"
        },
        {
          "name": "Authorization",
          "value": "=Bearer {{ $env.SUPABASE_SERVICE_KEY }}"
        }
      ],
      "http_sendBody": false,
      "http_bodyType": "",
      "http_jsonBody": "",
      "http_body": "",
      "http_options": {
        "timeout": 30000
      },
      "http_batching": null,
      "http_timeout": 30000,
      "http_sendQuery": false,
      "http_queryParams": []
    },
    {
      "name": "Filter & Merge Contacts",
      "id": "82cda0ea-ce05-42be-9baa-58f5cc657eac",
      "type": "code",
      "full_type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        17984,
        144
      ],
      "notes": "Merges contact data with company data. Filters to contacts that still need enrichment (missing email, cultural_affinity, phone, linkedin, OR email_status is unverified).",
      "onError": "",
      "mode": "",
      "incoming": [
        {
          "source": "Fetch Companies1",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Batch Empty?3",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "jsCode": "// Merge contacts with their company data and filter to those needing enrichment\nconst contactItems = $('Fetch Contacts').all();\nconst companyItems = $('Fetch Companies1').all();\n\n// Parse contacts - deduplicate by id\nlet rawContacts = [];\nfor (const item of contactItems) {\n  if (item.json && Array.isArray(item.json)) {\n    rawContacts.push(...item.json);\n  } else if (item.json && item.json.id) {\n    rawContacts.push(item.json);\n  }\n}\n\n// Deduplicate by contact id\nconst seenIds = new Set();\nlet contacts = [];\nfor (const c of rawContacts) {\n  if (c.id && !seenIds.has(c.id)) {\n    seenIds.add(c.id);\n    contacts.push(c);\n  }\n}\n\n// Parse companies into a lookup map (map deduplicates naturally)\nlet companyMap = {};\nfor (const item of companyItems) {\n  if (Array.isArray(item.json)) {\n    for (const co of item.json) {\n      if (co.id) companyMap[co.id] = co;\n    }\n  } else if (item.json && item.json.id) {\n    companyMap[item.json.id] = item.json;\n  }\n}\n\n// Filter contacts that need enrichment:\n// any contact where there's still something to enrich\nconst needsEnrichment = contacts.filter(c => {\n  const missingEmail = !c.email_business;\n  const missingCulturalAffinity = !c.cultural_affinity;\n  const missingPhone = !c.phone_direct;\n  const missingLinkedin = !c.linkedin_url;\n  // Check if email needs verification: has email but status is not verified/invalid/risky/accept_all\n  const verifiedStatuses = ['verified', 'invalid', 'risky', 'accept_all'];\n  const emailNeedsVerification = c.email_business && !verifiedStatuses.includes(c.email_status);\n  return missingEmail || missingCulturalAffinity || missingPhone || missingLinkedin || emailNeedsVerification;\n});\n\nconsole.log(`Contacts: ${rawContacts.length} raw, ${contacts.length} unique, ${needsEnrichment.length} need enrichment, ${contacts.length - needsEnrichment.length} already fully enriched`);\n\nif (needsEnrichment.length === 0) {\n  return [{ json: { _empty: true, _count: 0, _message: 'All contacts are already enriched' } }];\n}\n\n// Merge company data into each contact\nconst merged = needsEnrichment.map(c => {\n  const company = companyMap[c.company_id] || {};\n  return {\n    json: {\n      ...c,\n      _company_name: company.name || null,\n      _company_domain: company.domain || null,\n      _company_phone: company.phone || null,\n      _company_city: company.city || null,\n      _company_state: company.state || null\n    }\n  };\n});\n\nreturn merged;",
      "upstream_refs": [
        "Fetch Companies1",
        "Fetch Contacts"
      ],
      "ref_methods": [
        {
          "node": "Fetch Contacts",
          "method": "all"
        },
        {
          "node": "Fetch Companies1",
          "method": "all"
        }
      ],
      "code_lines": 71
    },
    {
      "name": "Batch Empty?3",
      "id": "cac8fd6f-5040-4cba-ba13-e32b576ffe5b",
      "type": "if",
      "full_type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        18208,
        144
      ],
      "notes": "",
      "onError": "",
      "mode": "",
      "incoming": [
        {
          "source": "Filter & Merge Contacts",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "No Records - Done3",
          "output_idx": 0,
          "input_idx": 0
        },
        {
          "target": "Needs Email?",
          "output_idx": 1,
          "input_idx": 0
        }
      ],
      "if_conditions": {
        "options": {
          "caseSensitive": true,
          "leftValue": "",
          "typeValidation": "loose"
        },
        "conditions": [
          {
            "id": "is-empty",
            "leftValue": "={{ $json._empty }}",
            "rightValue": true,
            "operator": {
              "type": "boolean",
              "operation": "equals",
              "singleValue": true
            }
          }
        ],
        "combinator": "and"
      },
      "if_options": {}
    },
    {
      "name": "No Records - Done3",
      "id": "ff66d587-56fe-4b0b-aa28-7b77c9dfc6b3",
      "type": "code",
      "full_type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        18432,
        48
      ],
      "notes": "",
      "onError": "",
      "mode": "",
      "incoming": [
        {
          "source": "Batch Empty?3",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [],
      "jsCode": "return [{ json: { message: 'No contacts need enrichment. All done!', completed_at: new Date().toISOString() } }];",
      "upstream_refs": [],
      "ref_methods": [],
      "code_lines": 1
    },
    {
      "name": "Needs Email?",
      "id": "f9d810ae-6ea7-4434-9ccf-6042c1df6c8a",
      "type": "if",
      "full_type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        18432,
        240
      ],
      "notes": "Routes contacts that are missing email_business to the email waterfall. Contacts that already have email skip ahead.",
      "onError": "",
      "mode": "",
      "incoming": [
        {
          "source": "Batch Empty?3",
          "output_idx": 1,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Has Domain & Name?",
          "output_idx": 0,
          "input_idx": 0
        },
        {
          "target": "Skip Email - Pass Through",
          "output_idx": 1,
          "input_idx": 0
        }
      ],
      "if_conditions": {
        "options": {
          "caseSensitive": true,
          "leftValue": "",
          "typeValidation": "loose"
        },
        "conditions": [
          {
            "id": "needs-email",
            "leftValue": "={{ $json.email_business }}",
            "rightValue": "",
            "operator": {
              "type": "string",
              "operation": "notExists"
            }
          }
        ],
        "combinator": "and"
      },
      "if_options": {}
    },
    {
      "name": "Has Domain & Name?",
      "id": "9a56eb2c-56a4-4d09-ad34-c6310ac876d5",
      "type": "if",
      "full_type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        18656,
        336
      ],
      "notes": "Email finder APIs require domain + first name at minimum. Contacts without these skip email enrichment.",
      "onError": "",
      "mode": "",
      "incoming": [
        {
          "source": "Needs Email?",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Hunter Enabled?",
          "output_idx": 0,
          "input_idx": 0
        },
        {
          "target": "No Domain - Skip Email",
          "output_idx": 1,
          "input_idx": 0
        }
      ],
      "if_conditions": {
        "options": {
          "caseSensitive": true,
          "leftValue": "",
          "typeValidation": "loose"
        },
        "conditions": [
          {
            "id": "has-domain",
            "leftValue": "={{ $json._company_domain }}",
            "rightValue": "",
            "operator": {
              "type": "string",
              "operation": "exists"
            }
          },
          {
            "id": "has-first-name",
            "leftValue": "={{ $json.first_name }}",
            "rightValue": "",
            "operator": {
              "type": "string",
              "operation": "exists"
            }
          }
        ],
        "combinator": "and"
      },
      "if_options": {}
    },
    {
      "name": "Hunter Enabled?",
      "id": "5dd93e8e-397c-4e48-b3f2-23ae7e6e72ea",
      "type": "if",
      "full_type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        18864,
        176
      ],
      "notes": "Checks if Hunter is disabled in config. TRUE output = skip_hunter is 'true' (disabled), FALSE output = Hunter enabled.",
      "onError": "",
      "mode": "",
      "incoming": [
        {
          "source": "Has Domain & Name?",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Skip Hunter",
          "output_idx": 0,
          "input_idx": 0
        },
        {
          "target": "Hunter Email Finder",
          "output_idx": 1,
          "input_idx": 0
        }
      ],
      "if_conditions": {
        "options": {
          "caseSensitive": true,
          "leftValue": "",
          "typeValidation": "loose"
        },
        "conditions": [
          {
            "id": "skip-hunter-check",
            "leftValue": "={{ $('Step 4 Config').first().json.skip_hunter }}",
            "rightValue": "true",
            "operator": {
              "type": "string",
              "operation": "equals"
            }
          }
        ],
        "combinator": "and"
      },
      "if_options": {}
    },
    {
      "name": "Hunter Email Finder",
      "id": "5d9601c6-1954-4440-a2d9-f166c8f896c8",
      "type": "httpRequest",
      "full_type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        19008,
        400
      ],
      "notes": "Hunter.io Email Finder: domain + first_name + last_name → email. 1 credit per call. Rate limit: 15/sec, 500/min.",
      "onError": "continueRegularOutput",
      "mode": "",
      "incoming": [
        {
          "source": "Hunter Enabled?",
          "output_idx": 1,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Parse Hunter Response",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "http_method": "GET",
      "http_url": "=https://api.hunter.io/v2/email-finder?domain={{ encodeURIComponent($json._company_domain) }}&first_name={{ encodeURIComponent($json.first_name) }}&last_name={{ encodeURIComponent($json.last_name || '') }}&api_key={{ $env.HUNTER_API_KEY }}",
      "http_sendHeaders": true,
      "http_headers": [
        {
          "name": "Accept",
          "value": "application/json"
        }
      ],
      "http_sendBody": false,
      "http_bodyType": "",
      "http_jsonBody": "",
      "http_body": "",
      "http_options": {
        "batching": {
          "batch": {
            "batchSize": 5
          }
        },
        "timeout": 15000
      },
      "http_batching": {
        "batch": {
          "batchSize": 5
        }
      },
      "http_timeout": 15000,
      "http_sendQuery": false,
      "http_queryParams": []
    },
    {
      "name": "Skip Hunter",
      "id": "60863bb9-1b6d-4574-8898-e6d7e724c25c",
      "type": "code",
      "full_type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        19232,
        80
      ],
      "notes": "",
      "onError": "",
      "mode": "runOnceForEachItem",
      "incoming": [
        {
          "source": "Hunter Enabled?",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Hunter Found Email?",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "jsCode": "// Hunter is disabled — pass through with no hunter results\nconst item = $input.item.json;\n\nreturn {\n  json: {\n    ...item,\n    _hunter_email: null,\n    _hunter_score: 0,\n    _hunter_linkedin: null,\n    _hunter_phone: null,\n    _email_source: null\n  }\n};",
      "upstream_refs": [],
      "ref_methods": [],
      "code_lines": 13
    },
    {
      "name": "Parse Hunter Response",
      "id": "c81f5c4f-a06a-4bac-9aea-18bc0ef26a31",
      "type": "code",
      "full_type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        19232,
        400
      ],
      "notes": "",
      "onError": "",
      "mode": "runOnceForEachItem",
      "incoming": [
        {
          "source": "Hunter Email Finder",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Hunter Found Email?",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "jsCode": "const contact = $('Has Domain & Name?').item.json;\nconst response = $input.item.json;\n\nlet hunterEmail = null;\nlet hunterScore = 0;\nlet hunterLinkedin = null;\nlet hunterPhone = null;\nlet hunterPosition = null;\n\n// Hunter v2 response: { data: { email, score, linkedin_url, phone_number, position } }\nconst data = response.data || response;\nif (data && data.email && data.score >= 50) {\n  hunterEmail = data.email;\n  hunterScore = data.score || 0;\n  hunterLinkedin = data.linkedin_url || null;\n  hunterPhone = data.phone_number || null;\n  hunterPosition = data.position || null;\n}\n\nconsole.log(`Hunter for ${contact.first_name} ${contact.last_name || ''} @ ${contact._company_domain}: ${hunterEmail ? hunterEmail + ' (score: ' + hunterScore + ')' : 'no result'}`);\n\nreturn {\n  json: {\n    ...contact,\n    _hunter_email: hunterEmail,\n    _hunter_score: hunterScore,\n    _hunter_linkedin: hunterLinkedin,\n    _hunter_phone: hunterPhone,\n    _hunter_position: hunterPosition,\n    _email_source: hunterEmail ? 'hunter' : null\n  }\n};",
      "upstream_refs": [
        "Has Domain & Name?"
      ],
      "ref_methods": [
        {
          "node": "Has Domain & Name?",
          "method": "item.json"
        }
      ],
      "code_lines": 32
    },
    {
      "name": "Hunter Found Email?",
      "id": "83d7b998-66ad-4876-9a2a-88e0a9abb91d",
      "type": "if",
      "full_type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        19536,
        160
      ],
      "notes": "",
      "onError": "",
      "mode": "",
      "incoming": [
        {
          "source": "Parse Hunter Response",
          "output_idx": 0,
          "input_idx": 0
        },
        {
          "source": "Skip Hunter",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Merge Email Results",
          "output_idx": 0,
          "input_idx": 0
        },
        {
          "target": "Snov.io Enabled?",
          "output_idx": 1,
          "input_idx": 0
        }
      ],
      "if_conditions": {
        "options": {
          "caseSensitive": true,
          "leftValue": "",
          "typeValidation": "loose"
        },
        "conditions": [
          {
            "id": "hunter-found",
            "leftValue": "={{ $json._hunter_email }}",
            "rightValue": "",
            "operator": {
              "type": "string",
              "operation": "exists"
            }
          }
        ],
        "combinator": "and"
      },
      "if_options": {}
    },
    {
      "name": "Snov.io Enabled?",
      "id": "3c41e9db-c0b6-47d4-9612-506c2fa6bb6e",
      "type": "if",
      "full_type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        19680,
        304
      ],
      "notes": "Checks if Snov.io is disabled. TRUE = skip, FALSE = call API.",
      "onError": "",
      "mode": "",
      "incoming": [
        {
          "source": "Hunter Found Email?",
          "output_idx": 1,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Skip Snov.io",
          "output_idx": 0,
          "input_idx": 0
        },
        {
          "target": "Snov.io Email Finder",
          "output_idx": 1,
          "input_idx": 0
        }
      ],
      "if_conditions": {
        "options": {
          "caseSensitive": true,
          "leftValue": "",
          "typeValidation": "loose"
        },
        "conditions": [
          {
            "id": "skip-snovio-check",
            "leftValue": "={{ $('Step 4 Config').first().json.skip_snovio }}",
            "rightValue": "true",
            "operator": {
              "type": "string",
              "operation": "equals"
            }
          }
        ],
        "combinator": "and"
      },
      "if_options": {}
    },
    {
      "name": "Snov.io Email Finder",
      "id": "d1d92981-9bf0-4121-8df2-316965fa109b",
      "type": "httpRequest",
      "full_type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        19904,
        400
      ],
      "notes": "Snov.io fallback email finder. Requires access token via SNOVIO_ACCESS_TOKEN env var.",
      "onError": "continueRegularOutput",
      "mode": "",
      "incoming": [
        {
          "source": "Snov.io Enabled?",
          "output_idx": 1,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Parse Snov.io Response",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "http_method": "POST",
      "http_url": "https://api.snov.io/v1/get-emails-from-names",
      "http_sendHeaders": true,
      "http_headers": [
        {
          "name": "Content-Type",
          "value": "application/json"
        }
      ],
      "http_sendBody": true,
      "http_bodyType": "json",
      "http_jsonBody": "={\n  \"firstName\": \"{{ $json.first_name }}\",\n  \"lastName\": \"{{ $json.last_name || '' }}\",\n  \"domain\": \"{{ $json._company_domain }}\"\n}",
      "http_body": "",
      "http_options": {
        "batching": {
          "batch": {
            "batchSize": 3,
            "batchInterval": 1500
          }
        },
        "timeout": 15000
      },
      "http_batching": {
        "batch": {
          "batchSize": 3,
          "batchInterval": 1500
        }
      },
      "http_timeout": 15000,
      "http_sendQuery": false,
      "http_queryParams": []
    },
    {
      "name": "Skip Email - Pass Through",
      "id": "d92f1323-f5fd-4467-a11c-6f069c2bfab0",
      "type": "code",
      "full_type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        20096,
        -32
      ],
      "notes": "Contacts that already have email_business or don't have domain+name skip email waterfall.",
      "onError": "",
      "mode": "runOnceForEachItem",
      "incoming": [
        {
          "source": "Needs Email?",
          "output_idx": 1,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Collect Email Results",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "jsCode": "// For contacts that already have email or can't do email lookup — just pass through with existing data\nconst item = $input.item.json;\n\nreturn {\n  json: {\n    ...item,\n    _best_email: item.email_business || null,\n    _best_phone: item.phone_direct || item._company_phone || null,\n    _best_linkedin: item.linkedin_url || null,\n    _email_source: item.email_business ? 'existing' : null\n  }\n};",
      "upstream_refs": [],
      "ref_methods": [],
      "code_lines": 12
    },
    {
      "name": "Skip Snov.io",
      "id": "7e692961-46aa-4db9-acdf-37322c18a060",
      "type": "code",
      "full_type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        20128,
        240
      ],
      "notes": "",
      "onError": "",
      "mode": "runOnceForEachItem",
      "incoming": [
        {
          "source": "Snov.io Enabled?",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Merge Email Results",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "jsCode": "// Snov.io disabled — pass through\nconst item = $input.item.json;\n\nreturn {\n  json: {\n    ...item,\n    _snovio_email: null\n  }\n};",
      "upstream_refs": [],
      "ref_methods": [],
      "code_lines": 9
    },
    {
      "name": "Parse Snov.io Response",
      "id": "d64e3483-e853-49f5-9a2d-633395d3b8b2",
      "type": "code",
      "full_type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        20128,
        400
      ],
      "notes": "",
      "onError": "",
      "mode": "runOnceForEachItem",
      "incoming": [
        {
          "source": "Snov.io Email Finder",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Merge Email Results",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "jsCode": "const contact = $input.item.json;\nconst response = $input.item.json;\n\n// Snov.io response has emails array\nlet snovEmail = null;\nconst emails = response.emails || response.data?.emails || [];\n\nif (Array.isArray(emails) && emails.length > 0) {\n  // Pick the first valid email\n  const validEmail = emails.find(e => e.emailStatus === 'valid' || e.status === 'valid') || emails[0];\n  snovEmail = validEmail.email || validEmail.value || null;\n}\n\n// Preserve upstream contact data (it's in the same json since HTTP node passes through)\n// We need to get the original contact data from the upstream node\nconst upstreamContact = $('Hunter Found Email?').item.json;\n\nconsole.log(`Snov.io for ${upstreamContact.first_name} ${upstreamContact.last_name || ''}: ${snovEmail || 'no result'}`);\n\nreturn {\n  json: {\n    ...upstreamContact,\n    _snovio_email: snovEmail,\n    _email_source: snovEmail ? 'snovio' : upstreamContact._email_source\n  }\n};",
      "upstream_refs": [
        "Hunter Found Email?"
      ],
      "ref_methods": [
        {
          "node": "Hunter Found Email?",
          "method": "item.json"
        }
      ],
      "code_lines": 26
    },
    {
      "name": "Merge Email Results",
      "id": "a0be5606-9334-41d7-af77-e599d8f86dee",
      "type": "code",
      "full_type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        20320,
        160
      ],
      "notes": "Merges results from email waterfall (Hunter → Snov.io) and picks the best available email, phone, linkedin.",
      "onError": "",
      "mode": "runOnceForEachItem",
      "incoming": [
        {
          "source": "Hunter Found Email?",
          "output_idx": 0,
          "input_idx": 0
        },
        {
          "source": "Parse Snov.io Response",
          "output_idx": 0,
          "input_idx": 0
        },
        {
          "source": "Skip Snov.io",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Collect Email Results",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "jsCode": "const item = $input.item.json;\n\n// Determine best email from waterfall\nlet bestEmail = item._hunter_email || item._snovio_email || null;\nlet emailSource = item._email_source || null;\n\n// Determine best phone: direct phone > hunter phone > company phone fallback\nlet bestPhone = item.phone_direct || item._hunter_phone || item._company_phone || null;\n\n// Determine best linkedin\nlet bestLinkedin = item.linkedin_url || item._hunter_linkedin || null;\n\nreturn {\n  json: {\n    ...item,\n    _best_email: bestEmail,\n    _best_phone: bestPhone,\n    _best_linkedin: bestLinkedin,\n    _email_source: emailSource\n  }\n};",
      "upstream_refs": [],
      "ref_methods": [],
      "code_lines": 21
    },
    {
      "name": "No Domain - Skip Email",
      "id": "ab0c3486-9ad4-43bb-8e80-8f8e92691a38",
      "type": "code",
      "full_type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        20352,
        544
      ],
      "notes": "Contacts without domain+name can't do email finder lookups. Still proceeds to NamSor.",
      "onError": "",
      "mode": "runOnceForEachItem",
      "incoming": [
        {
          "source": "Has Domain & Name?",
          "output_idx": 1,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Collect Email Results",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "jsCode": "// Contacts without domain+name can't use email finder APIs — pass through\nconst item = $input.item.json;\n\nreturn {\n  json: {\n    ...item,\n    _best_email: null,\n    _best_phone: item.phone_direct || item._company_phone || null,\n    _best_linkedin: item.linkedin_url || null,\n    _email_source: null\n  }\n};",
      "upstream_refs": [],
      "ref_methods": [],
      "code_lines": 12
    },
    {
      "name": "Collect Email Results",
      "id": "40f54f8e-8f98-4e37-a231-58b579509e67",
      "type": "code",
      "full_type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        20560,
        160
      ],
      "notes": "",
      "onError": "",
      "mode": "",
      "incoming": [
        {
          "source": "Merge Email Results",
          "output_idx": 0,
          "input_idx": 0
        },
        {
          "source": "Skip Email - Pass Through",
          "output_idx": 0,
          "input_idx": 0
        },
        {
          "source": "No Domain - Skip Email",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Has Email to Verify?",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "jsCode": "// Collect all items from all three email paths and deduplicate\nconst items = [];\ntry { items.push(...$('Merge Email Results').all()); } catch(e) {}\ntry { items.push(...$('Skip Email - Pass Through').all()); } catch(e) {}\ntry { items.push(...$('No Domain - Skip Email').all()); } catch(e) {}\n\nconst seen = new Set();\nconst unique = [];\nfor (const item of items) {\n  const id = item.json.id;\n  if (id && !seen.has(id)) {\n    seen.add(id);\n    unique.push({ json: item.json });\n  }\n}\n\nconsole.log(`Collected ${items.length} items from email paths, ${unique.length} unique contacts`);\nreturn unique;",
      "upstream_refs": [
        "No Domain - Skip Email",
        "Skip Email - Pass Through",
        "Merge Email Results"
      ],
      "ref_methods": [
        {
          "node": "Merge Email Results",
          "method": "all"
        },
        {
          "node": "Skip Email - Pass Through",
          "method": "all"
        },
        {
          "node": "No Domain - Skip Email",
          "method": "all"
        }
      ],
      "code_lines": 18
    },
    {
      "name": "Has Email to Verify?",
      "id": "d40844b9-4771-4a61-aa47-ffdbfca35408",
      "type": "if",
      "full_type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        20720,
        224
      ],
      "notes": "Routes contacts with a best email to verification. Contacts without email skip ahead.",
      "onError": "",
      "mode": "",
      "incoming": [
        {
          "source": "Collect Email Results",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Hunter Verifier Enabled?",
          "output_idx": 0,
          "input_idx": 0
        },
        {
          "target": "Skip Verification",
          "output_idx": 1,
          "input_idx": 0
        }
      ],
      "if_conditions": {
        "options": {
          "caseSensitive": true,
          "leftValue": "",
          "typeValidation": "loose"
        },
        "conditions": [
          {
            "id": "has-best-email",
            "leftValue": "={{ $json._best_email }}",
            "rightValue": "",
            "operator": {
              "type": "string",
              "operation": "exists"
            }
          }
        ],
        "combinator": "and"
      },
      "if_options": {}
    },
    {
      "name": "Hunter Verifier Enabled?",
      "id": "7805a8b3-f947-4754-9d4f-a5000410caa8",
      "type": "if",
      "full_type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        20896,
        112
      ],
      "notes": "Checks if Hunter Verifier is disabled in config. TRUE = skip_hunter_verifier is 'true' (disabled), FALSE = Verifier enabled.",
      "onError": "",
      "mode": "",
      "incoming": [
        {
          "source": "Has Email to Verify?",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Skip Verification",
          "output_idx": 0,
          "input_idx": 0
        },
        {
          "target": "Hunter Email Verifier",
          "output_idx": 1,
          "input_idx": 0
        }
      ],
      "if_conditions": {
        "options": {
          "caseSensitive": true,
          "leftValue": "",
          "typeValidation": "strict",
          "version": 1
        },
        "conditions": [
          {
            "id": "skip-verifier-check",
            "leftValue": "={{ $('Step 4 Config').first().json.skip_hunter_verifier }}",
            "rightValue": "true",
            "operator": {
              "type": "string",
              "operation": "equals"
            }
          }
        ],
        "combinator": "and"
      },
      "if_options": {}
    },
    {
      "name": "Hunter Email Verifier",
      "id": "51de5078-11c8-4d90-9fc6-7a30396157b3",
      "type": "httpRequest",
      "full_type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        21120,
        128
      ],
      "notes": "Hunter Email Verifier: 1 credit per call. Returns status (valid/invalid/accept_all/unknown), score, SMTP check results.",
      "onError": "continueRegularOutput",
      "mode": "",
      "incoming": [
        {
          "source": "Hunter Verifier Enabled?",
          "output_idx": 1,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Parse Verifier Response",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "http_method": "GET",
      "http_url": "=https://api.hunter.io/v2/email-verifier?email={{ encodeURIComponent($json._best_email) }}&api_key={{ $env.HUNTER_API_KEY }}",
      "http_sendHeaders": true,
      "http_headers": [
        {
          "name": "Accept",
          "value": "application/json"
        }
      ],
      "http_sendBody": false,
      "http_bodyType": "",
      "http_jsonBody": "",
      "http_body": "",
      "http_options": {
        "batching": {
          "batch": {
            "batchSize": 3,
            "batchInterval": 2000
          }
        },
        "timeout": 15000
      },
      "http_batching": {
        "batch": {
          "batchSize": 3,
          "batchInterval": 2000
        }
      },
      "http_timeout": 15000,
      "http_sendQuery": false,
      "http_queryParams": []
    },
    {
      "name": "Skip Verification",
      "id": "e611d79d-01f6-4df6-9782-7b6e3e23ea48",
      "type": "code",
      "full_type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        21120,
        336
      ],
      "notes": "",
      "onError": "",
      "mode": "runOnceForEachItem",
      "incoming": [
        {
          "source": "Has Email to Verify?",
          "output_idx": 1,
          "input_idx": 0
        },
        {
          "source": "Hunter Verifier Enabled?",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Collect Verified Results",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "jsCode": "// Verification skipped (disabled or no email to verify) — pass through\nconst item = $input.item.json;\n\nreturn {\n  json: {\n    ...item,\n    _email_status: item._best_email ? 'unverified' : null,\n    _email_verified_at: null,\n    _verifier_score: null,\n    _verifier_smtp_check: null,\n    _verifier_mx_records: null\n  }\n};",
      "upstream_refs": [],
      "ref_methods": [],
      "code_lines": 13
    },
    {
      "name": "Parse Verifier Response",
      "id": "ea83c777-3e8a-4ba3-8fd2-a11ed9964c89",
      "type": "code",
      "full_type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        21312,
        128
      ],
      "notes": "",
      "onError": "",
      "mode": "runOnceForEachItem",
      "incoming": [
        {
          "source": "Hunter Email Verifier",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Collect Verified Results",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "jsCode": "const contact = $('Has Email to Verify?').item.json;\nconst response = $input.item.json;\n\nlet emailStatus = 'unverified';\nlet verifierScore = null;\nlet smtpCheck = null;\nlet mxRecords = null;\n\n// Hunter v2 verifier response: { data: { status, score, smtp_check, mx_records, ... } }\nconst data = response.data || response;\n\nif (data && data.status) {\n  // Map Hunter status to our schema values\n  // Hunter returns: valid, invalid, accept_all, webmail, disposable, unknown\n  switch (data.status) {\n    case 'valid':\n      emailStatus = 'verified';\n      break;\n    case 'invalid':\n      emailStatus = 'invalid';\n      break;\n    case 'accept_all':\n      emailStatus = 'accept_all';\n      break;\n    case 'disposable':\n      emailStatus = 'invalid'; // treat disposable as invalid for outreach\n      break;\n    case 'webmail':\n      emailStatus = 'verified'; // webmail (gmail, yahoo) is valid for outreach\n      break;\n    case 'unknown':\n    default:\n      emailStatus = 'risky';\n      break;\n  }\n\n  verifierScore = data.score || null;\n  smtpCheck = data.smtp_check !== undefined ? data.smtp_check : null;\n  mxRecords = data.mx_records !== undefined ? data.mx_records : null;\n}\n\nconsole.log(`Verifier for ${contact._best_email}: ${emailStatus} (score: ${verifierScore}, smtp: ${smtpCheck})`);\n\nreturn {\n  json: {\n    ...contact,\n    _email_status: emailStatus,\n    _email_verified_at: new Date().toISOString(),\n    _verifier_score: verifierScore,\n    _verifier_smtp_check: smtpCheck,\n    _verifier_mx_records: mxRecords\n  }\n};",
      "upstream_refs": [
        "Has Email to Verify?"
      ],
      "ref_methods": [
        {
          "node": "Has Email to Verify?",
          "method": "item.json"
        }
      ],
      "code_lines": 53
    },
    {
      "name": "Collect Verified Results",
      "id": "34342f98-87fa-44e7-a5ab-431c0076baaa",
      "type": "code",
      "full_type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        21472,
        240
      ],
      "notes": "",
      "onError": "",
      "mode": "",
      "incoming": [
        {
          "source": "Parse Verifier Response",
          "output_idx": 0,
          "input_idx": 0
        },
        {
          "source": "Skip Verification",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Needs NamSor?",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "jsCode": "// Collect from verification paths and deduplicate\nconst items = [];\ntry { items.push(...$('Parse Verifier Response').all()); } catch(e) {}\ntry { items.push(...$('Skip Verification').all()); } catch(e) {}\n\nconst seen = new Set();\nconst unique = [];\nfor (const item of items) {\n  const id = item.json.id;\n  if (id && !seen.has(id)) {\n    seen.add(id);\n    unique.push({ json: item.json });\n  }\n}\n\nconsole.log(`Collected ${items.length} items from verification paths, ${unique.length} unique contacts`);\nreturn unique;",
      "upstream_refs": [
        "Parse Verifier Response",
        "Skip Verification"
      ],
      "ref_methods": [
        {
          "node": "Parse Verifier Response",
          "method": "all"
        },
        {
          "node": "Skip Verification",
          "method": "all"
        }
      ],
      "code_lines": 17
    },
    {
      "name": "Needs NamSor?",
      "id": "3679d3b0-6f87-4c7d-9abc-45f97063a921",
      "type": "if",
      "full_type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        21664,
        224
      ],
      "notes": "Routes to NamSor if: enabled in config AND contact has first_name AND cultural_affinity is missing.",
      "onError": "",
      "mode": "",
      "incoming": [
        {
          "source": "Collect Verified Results",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "NamSor Origin",
          "output_idx": 0,
          "input_idx": 0
        },
        {
          "target": "Skip NamSor",
          "output_idx": 1,
          "input_idx": 0
        }
      ],
      "if_conditions": {
        "options": {
          "caseSensitive": true,
          "leftValue": "",
          "typeValidation": "loose"
        },
        "conditions": [
          {
            "id": "skip-namsor-check",
            "leftValue": "={{ $('Step 4 Config').first().json.skip_namsor }}",
            "rightValue": "false",
            "operator": {
              "type": "string",
              "operation": "equals"
            }
          },
          {
            "id": "has-first-name",
            "leftValue": "={{ $json.first_name }}",
            "rightValue": "",
            "operator": {
              "type": "string",
              "operation": "exists"
            }
          },
          {
            "id": "missing-affinity",
            "leftValue": "={{ $json.cultural_affinity }}",
            "rightValue": "",
            "operator": {
              "type": "string",
              "operation": "notExists"
            }
          }
        ],
        "combinator": "and"
      },
      "if_options": {}
    },
    {
      "name": "NamSor Origin",
      "id": "d7043289-c4c9-4045-8b49-03e1c7bd0c13",
      "type": "httpRequest",
      "full_type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        21792,
        144
      ],
      "notes": "NamSor Origin API: first_name + last_name → country of origin, region, sub-region. 10 credits per name. Auth via X-API-KEY header.",
      "onError": "continueRegularOutput",
      "mode": "",
      "incoming": [
        {
          "source": "Needs NamSor?",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Parse NamSor Response",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "http_method": "GET",
      "http_url": "=https://v2.namsor.com/NamSorAPIv2/api2/json/origin/{{ encodeURIComponent($json.first_name) }}/{{ encodeURIComponent($json.last_name || 'Unknown') }}",
      "http_sendHeaders": true,
      "http_headers": [
        {
          "name": "X-API-KEY",
          "value": "={{ $env.NAMSOR_API_KEY }}"
        },
        {
          "name": "Accept",
          "value": "application/json"
        }
      ],
      "http_sendBody": false,
      "http_bodyType": "",
      "http_jsonBody": "",
      "http_body": "",
      "http_options": {
        "batching": {
          "batch": {
            "batchSize": 5,
            "batchInterval": 500
          }
        },
        "timeout": 10000
      },
      "http_batching": {
        "batch": {
          "batchSize": 5,
          "batchInterval": 500
        }
      },
      "http_timeout": 10000,
      "http_sendQuery": false,
      "http_queryParams": []
    },
    {
      "name": "Parse NamSor Response",
      "id": "2e70abe4-4633-4fb3-919b-41354769f215",
      "type": "code",
      "full_type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        22016,
        144
      ],
      "notes": "",
      "onError": "",
      "mode": "runOnceForEachItem",
      "incoming": [
        {
          "source": "NamSor Origin",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Collect NamSor Results",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "jsCode": "const contact = $('Needs NamSor?').item.json;\nconst response = $input.item.json;\n\n// NamSor origin response: { countryOrigin, countryOriginAlt, regionOrigin, subRegionOrigin, probabilityCalibrated }\nlet culturalAffinity = null;\n\nif (response && response.countryOrigin) {\n  // Build a readable cultural affinity string\n  const parts = [];\n  if (response.regionOrigin) parts.push(response.regionOrigin);\n  if (response.subRegionOrigin && response.subRegionOrigin !== response.regionOrigin) {\n    parts.push(response.subRegionOrigin);\n  }\n  if (response.countryOrigin) parts.push(response.countryOrigin);\n  \n  culturalAffinity = parts.join(' / ');\n  \n  // If probability is very low, mark as uncertain\n  if (response.probabilityCalibrated && response.probabilityCalibrated < 0.3) {\n    culturalAffinity = culturalAffinity + ' (low confidence)';\n  }\n}\n\nconsole.log(`NamSor for ${contact.first_name} ${contact.last_name || ''}: ${culturalAffinity || 'no result'}`);\n\nreturn {\n  json: {\n    ...contact,\n    _cultural_affinity: culturalAffinity,\n    _namsor_country: response.countryOrigin || null,\n    _namsor_region: response.regionOrigin || null,\n    _namsor_probability: response.probabilityCalibrated || null\n  }\n};",
      "upstream_refs": [
        "Needs NamSor?"
      ],
      "ref_methods": [
        {
          "node": "Needs NamSor?",
          "method": "item.json"
        }
      ],
      "code_lines": 34
    },
    {
      "name": "Skip NamSor",
      "id": "46b0dec8-5a15-44b3-92e8-3479bb7be764",
      "type": "code",
      "full_type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        22016,
        336
      ],
      "notes": "",
      "onError": "",
      "mode": "runOnceForEachItem",
      "incoming": [
        {
          "source": "Needs NamSor?",
          "output_idx": 1,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Collect NamSor Results",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "jsCode": "// NamSor skipped — pass through with existing cultural_affinity (if any)\nconst item = $input.item.json;\n\nreturn {\n  json: {\n    ...item,\n    _cultural_affinity: item.cultural_affinity || null,\n    _namsor_country: null,\n    _namsor_region: null,\n    _namsor_probability: null\n  }\n};",
      "upstream_refs": [],
      "ref_methods": [],
      "code_lines": 12
    },
    {
      "name": "Collect NamSor Results",
      "id": "740434fd-1b38-4b3c-9508-78d4a422957b",
      "type": "code",
      "full_type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        22336,
        240
      ],
      "notes": "",
      "onError": "",
      "mode": "",
      "incoming": [
        {
          "source": "Parse NamSor Response",
          "output_idx": 0,
          "input_idx": 0
        },
        {
          "source": "Skip NamSor",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Prepare Contact Update",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "jsCode": "// Collect from NamSor paths and deduplicate\nconst items = [];\ntry { items.push(...$('Parse NamSor Response').all()); } catch(e) {}\ntry { items.push(...$('Skip NamSor').all()); } catch(e) {}\n\nconst seen = new Set();\nconst unique = [];\nfor (const item of items) {\n  const id = item.json.id;\n  if (id && !seen.has(id)) {\n    seen.add(id);\n    unique.push({ json: item.json });\n  }\n}\n\nconsole.log(`Collected ${items.length} items from NamSor paths, ${unique.length} unique contacts`);\nreturn unique;",
      "upstream_refs": [
        "Skip NamSor",
        "Parse NamSor Response"
      ],
      "ref_methods": [
        {
          "node": "Parse NamSor Response",
          "method": "all"
        },
        {
          "node": "Skip NamSor",
          "method": "all"
        }
      ],
      "code_lines": 17
    },
    {
      "name": "Prepare Contact Update",
      "id": "4d212022-0a6f-4a89-af49-a2761e2a4a75",
      "type": "code",
      "full_type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        22688,
        224
      ],
      "notes": "Builds the Supabase PATCH payload. Includes email_status, email_verified_at, and validates phone (E.164). Nulls out invalid emails.",
      "onError": "",
      "mode": "runOnceForEachItem",
      "incoming": [
        {
          "source": "Collect NamSor Results",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Has Updates?",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "jsCode": "const item = $input.item.json;\n\n// ── Phone validation (same logic as Layer 1) ──\nfunction validatePhone(phone) {\n  if (!phone) return null;\n\n  if (typeof phone === 'object' && phone !== null) {\n    phone = phone.sanitized_number || phone.raw_number || phone.number || '';\n  }\n\n  let cleaned = phone.toString().trim();\n  cleaned = cleaned.replace(/[^\\d]/g, '');\n\n  if (!cleaned || cleaned.length === 0) return null;\n\n  if (cleaned.length === 11 && cleaned.startsWith('1')) {\n    // already has country code\n  } else if (cleaned.length === 10) {\n    cleaned = '1' + cleaned;\n  } else if (cleaned.length < 10) {\n    return null;\n  } else if (cleaned.length > 11) {\n    return '+' + cleaned; // possibly international\n  }\n\n  const areaCode = cleaned.substring(1, 4);\n  if (areaCode.startsWith('0') || areaCode.startsWith('1')) {\n    return null;\n  }\n\n  return '+' + cleaned;\n}\n\n// Build the update payload — only include fields that have new data\nconst update = {};\n\n// Email: prefer waterfall result over existing\nconst newEmail = item._best_email;\nif (newEmail && !item.email_business) {\n  update.email_business = newEmail;\n}\n\n// Email verification status\nif (item._email_status && item._email_status !== 'unverified') {\n  update.email_status = item._email_status;\n  update.email_verified_at = item._email_verified_at;\n\n  // If email was found invalid, null it out so we don't store bad data\n  if (item._email_status === 'invalid') {\n    update.email_business = null;\n    // Also remove from best_email tracking\n    console.log(`Invalid email removed for ${item.first_name} ${item.last_name || ''}: ${newEmail || item.email_business}`);\n  }\n} else if (newEmail || item.email_business) {\n  // Email exists but wasn't verified (verifier skipped) — mark as unverified\n  update.email_status = 'unverified';\n}\n\n// Phone: prefer direct phone, then hunter, then company fallback\n// Apply validation to all phone sources\nconst newPhone = validatePhone(item._best_phone);\nif (newPhone && !item.phone_direct) {\n  update.phone_direct = newPhone;\n}\n\n// LinkedIn\nconst newLinkedin = item._best_linkedin;\nif (newLinkedin && !item.linkedin_url) {\n  update.linkedin_url = newLinkedin;\n}\n\n// Cultural affinity from NamSor\nconst newAffinity = item._cultural_affinity;\nif (newAffinity && !item.cultural_affinity) {\n  update.cultural_affinity = newAffinity;\n}\n\nconst hasUpdates = Object.keys(update).length > 0;\n\nconsole.log(`Contact ${item.first_name} ${item.last_name || ''} (${item.id}): ${hasUpdates ? JSON.stringify(update) : 'no new data'}`);\n\nreturn {\n  json: {\n    _contact_id: item.id,\n    _company_id: item.company_id,\n    _first_name: item.first_name,\n    _last_name: item.last_name,\n    _company_name: item._company_name,\n    _update_payload: hasUpdates ? update : null,\n    _has_updates: hasUpdates,\n    _email_source: item._email_source || null,\n    _email_status: item._email_status || null,\n    _verifier_score: item._verifier_score || null,\n    _namsor_country: item._namsor_country || null,\n    _namsor_probability: item._namsor_probability || null\n  }\n};",
      "upstream_refs": [],
      "ref_methods": [],
      "code_lines": 97
    },
    {
      "name": "Has Updates?",
      "id": "daacc06c-14f2-49aa-93d3-3424d2ace589",
      "type": "if",
      "full_type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        22912,
        224
      ],
      "notes": "",
      "onError": "",
      "mode": "",
      "incoming": [
        {
          "source": "Prepare Contact Update",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Update Contact in Supabase",
          "output_idx": 0,
          "input_idx": 0
        },
        {
          "target": "Collect Updates",
          "output_idx": 1,
          "input_idx": 0
        }
      ],
      "if_conditions": {
        "options": {
          "caseSensitive": true,
          "leftValue": "",
          "typeValidation": "loose"
        },
        "conditions": [
          {
            "id": "has-updates",
            "leftValue": "={{ $json._has_updates }}",
            "rightValue": true,
            "operator": {
              "type": "boolean",
              "operation": "equals",
              "singleValue": true
            }
          }
        ],
        "combinator": "and"
      },
      "if_options": {}
    },
    {
      "name": "Update Contact in Supabase",
      "id": "cef9b4ed-9820-4d9c-8da1-e789cbb004d4",
      "type": "httpRequest",
      "full_type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        23136,
        112
      ],
      "notes": "PATCH updates the contact record with enriched fields. Only sends changed fields.",
      "onError": "continueRegularOutput",
      "mode": "",
      "incoming": [
        {
          "source": "Has Updates?",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Collect Updates",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "http_method": "PATCH",
      "http_url": "={{ $env.SUPABASE_URL }}/rest/v1/contacts?id=eq.{{ $json._contact_id }}",
      "http_sendHeaders": true,
      "http_headers": [
        {
          "name": "apikey",
          "value": "={{ $env.SUPABASE_SERVICE_KEY }}"
        },
        {
          "name": "Authorization",
          "value": "=Bearer {{ $env.SUPABASE_SERVICE_KEY }}"
        },
        {
          "name": "Content-Type",
          "value": "application/json"
        },
        {
          "name": "Prefer",
          "value": "return=minimal"
        }
      ],
      "http_sendBody": true,
      "http_bodyType": "json",
      "http_jsonBody": "={{ JSON.stringify($json._update_payload) }}",
      "http_body": "",
      "http_options": {
        "batching": {
          "batch": {
            "batchSize": 10,
            "batchInterval": 500
          }
        },
        "timeout": 15000
      },
      "http_batching": {
        "batch": {
          "batchSize": 10,
          "batchInterval": 500
        }
      },
      "http_timeout": 15000,
      "http_sendQuery": false,
      "http_queryParams": []
    },
    {
      "name": "Collect Updates",
      "id": "2757cd87-cb51-41d5-88e8-5cccd21a1533",
      "type": "code",
      "full_type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        23328,
        224
      ],
      "notes": "",
      "onError": "",
      "mode": "",
      "incoming": [
        {
          "source": "Has Updates?",
          "output_idx": 1,
          "input_idx": 0
        },
        {
          "source": "Update Contact in Supabase",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [
        {
          "target": "Run Summary4",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "jsCode": "// Collect from update paths and deduplicate\nconst items = [];\ntry { items.push(...$('Update Contact in Supabase').all()); } catch(e) {}\ntry { items.push(...$('Has Updates?').all().filter(i => !i.json._has_updates)); } catch(e) {}\n\nconst seen = new Set();\nconst unique = [];\nfor (const item of items) {\n  const id = item.json._contact_id || item.json.id;\n  if (id && !seen.has(id)) {\n    seen.add(id);\n    unique.push({ json: item.json });\n  }\n}\n\nreturn unique;",
      "upstream_refs": [
        "Has Updates?",
        "Update Contact in Supabase"
      ],
      "ref_methods": [
        {
          "node": "Update Contact in Supabase",
          "method": "all"
        },
        {
          "node": "Has Updates?",
          "method": "all"
        }
      ],
      "code_lines": 16
    },
    {
      "name": "Run Summary4",
      "id": "4406e050-b543-4a6c-932f-9620e8d59d3a",
      "type": "code",
      "full_type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        23536,
        224
      ],
      "notes": "Final summary: contacts processed, emails found (by source), verification results, phones added, cultural affinity set.",
      "onError": "",
      "mode": "",
      "incoming": [
        {
          "source": "Collect Updates",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "outgoing": [],
      "jsCode": "const config = $('Step 4 Config').first().json;\n\nlet totalProcessed = 0;\nlet emailsFound = 0;\nlet emailsFromHunter = 0;\nlet emailsFromSnovio = 0;\nlet emailsExisting = 0;\nlet phonesEnriched = 0;\nlet linkedinEnriched = 0;\nlet namsorProcessed = 0;\nlet namsorSuccess = 0;\nlet contactsUpdated = 0;\nlet contactsSkipped = 0;\n\n// Verification stats\nlet emailsVerified = 0;\nlet emailsInvalid = 0;\nlet emailsRisky = 0;\nlet emailsAcceptAll = 0;\nlet emailsUnverified = 0;\nlet verificationTotal = 0;\n\n// Count from Prepare Contact Update outputs\ntry {\n  const prepItems = $('Prepare Contact Update').all();\n  totalProcessed = prepItems.length;\n  for (const item of prepItems) {\n    const d = item.json;\n    if (d._has_updates) contactsUpdated++;\n    else contactsSkipped++;\n\n    if (d._email_source === 'hunter') emailsFromHunter++;\n    else if (d._email_source === 'snovio') emailsFromSnovio++;\n    else if (d._email_source === 'existing') emailsExisting++;\n\n    if (d._update_payload && d._update_payload.email_business) emailsFound++;\n    if (d._update_payload && d._update_payload.phone_direct) phonesEnriched++;\n    if (d._update_payload && d._update_payload.linkedin_url) linkedinEnriched++;\n    if (d._namsor_country) namsorProcessed++;\n    if (d._namsor_country && d._update_payload && d._update_payload.cultural_affinity) namsorSuccess++;\n\n    // Verification stats\n    if (d._email_status) {\n      verificationTotal++;\n      switch (d._email_status) {\n        case 'verified': emailsVerified++; break;\n        case 'invalid': emailsInvalid++; break;\n        case 'risky': emailsRisky++; break;\n        case 'accept_all': emailsAcceptAll++; break;\n        case 'unverified': emailsUnverified++; break;\n      }\n    }\n  }\n} catch(e) {\n  console.log('Error collecting stats:', e.message);\n}\n\nconst summary = {\n  run_completed_at: new Date().toISOString(),\n  config: {\n    batch_size: config.batch_size,\n    hunter_finder_enabled: config.skip_hunter !== 'true',\n    hunter_verifier_enabled: config.skip_hunter_verifier !== 'true',\n    snovio_enabled: config.skip_snovio !== 'true',\n    namsor_enabled: config.skip_namsor !== 'true'\n  },\n  contacts_processed: totalProcessed,\n  contacts_updated: contactsUpdated,\n  contacts_no_changes: contactsSkipped,\n  email_enrichment: {\n    new_emails_found: emailsFound,\n    from_hunter: emailsFromHunter,\n    from_snovio: emailsFromSnovio,\n    already_had_email: emailsExisting\n  },\n  email_verification: {\n    total_checked: verificationTotal,\n    verified: emailsVerified,\n    invalid_removed: emailsInvalid,\n    risky: emailsRisky,\n    accept_all: emailsAcceptAll,\n    not_verified: emailsUnverified\n  },\n  phone_enrichment: {\n    phones_added: phonesEnriched\n  },\n  linkedin_enrichment: {\n    linkedin_added: linkedinEnriched\n  },\n  namsor_enrichment: {\n    names_sent: namsorProcessed,\n    cultural_affinity_set: namsorSuccess\n  },\n  message: `Processed ${totalProcessed} contacts. Updated ${contactsUpdated} (${emailsFound} emails, ${phonesEnriched} phones, ${linkedinEnriched} LinkedIn, ${namsorSuccess} cultural affinity). Verification: ${emailsVerified} valid, ${emailsInvalid} invalid removed, ${emailsRisky} risky, ${emailsAcceptAll} accept_all, ${emailsUnverified} not checked. ${contactsSkipped} had no new data.`\n};\n\nconsole.log('=== STEP 4: ENRICH PEOPLE SUMMARY ===');\nconsole.log(JSON.stringify(summary, null, 2));\n\nreturn [{ json: summary }];",
      "upstream_refs": [
        "Step 4 Config",
        "Prepare Contact Update"
      ],
      "ref_methods": [
        {
          "node": "Step 4 Config",
          "method": "first"
        },
        {
          "node": "Prepare Contact Update",
          "method": "all"
        }
      ],
      "code_lines": 100
    }
  ],
  "convergence_points": [
    {
      "target": "Merge All Sources",
      "target_type": "merge",
      "sources": [
        {
          "source": "Normalize Google Results",
          "output_idx": 0,
          "input_idx": 0
        },
        {
          "source": "Normalize Yelp Results",
          "output_idx": 0,
          "input_idx": 1
        }
      ],
      "count": 2
    },
    {
      "target": "Run Summary",
      "target_type": "code",
      "sources": [
        {
          "source": "Insert to Supabase",
          "output_idx": 0,
          "input_idx": 0
        },
        {
          "source": "Insert Flagged (Needs Review)",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "count": 2
    },
    {
      "target": "Wait 30s",
      "target_type": "wait",
      "sources": [
        {
          "source": "Extract Run ID",
          "output_idx": 0,
          "input_idx": 0
        },
        {
          "source": "Run Succeeded?",
          "output_idx": 1,
          "input_idx": 0
        }
      ],
      "count": 2
    },
    {
      "target": "Merge Website Results",
      "target_type": "code",
      "sources": [
        {
          "source": "Analyze Website HTML",
          "output_idx": 0,
          "input_idx": 0
        },
        {
          "source": "Skip - No Website",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "count": 2
    },
    {
      "target": "Prepare Company Update",
      "target_type": "code",
      "sources": [
        {
          "source": "Parse Google Details",
          "output_idx": 0,
          "input_idx": 0
        },
        {
          "source": "Skip Google Details",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "count": 2
    },
    {
      "target": "Run Summary1",
      "target_type": "code",
      "sources": [
        {
          "source": "Insert Social Profiles",
          "output_idx": 0,
          "input_idx": 0
        },
        {
          "source": "Needs Social Discovery?",
          "output_idx": 1,
          "input_idx": 0
        },
        {
          "source": "Discovery Queries Exist?",
          "output_idx": 1,
          "input_idx": 0
        },
        {
          "source": "FB Matches Found?",
          "output_idx": 1,
          "input_idx": 0
        },
        {
          "source": "Insert FB Social Profiles",
          "output_idx": 0,
          "input_idx": 0
        },
        {
          "source": "IG Matches Found?",
          "output_idx": 1,
          "input_idx": 0
        },
        {
          "source": "Insert IG Social Profiles",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "count": 7
    },
    {
      "target": "Wait FB 30s",
      "target_type": "wait",
      "sources": [
        {
          "source": "Extract FB Run ID",
          "output_idx": 0,
          "input_idx": 0
        },
        {
          "source": "FB Run Succeeded?",
          "output_idx": 1,
          "input_idx": 0
        }
      ],
      "count": 2
    },
    {
      "target": "Wait IG 30s",
      "target_type": "wait",
      "sources": [
        {
          "source": "Extract IG Run ID",
          "output_idx": 0,
          "input_idx": 0
        },
        {
          "source": "IG Run Succeeded?",
          "output_idx": 1,
          "input_idx": 0
        }
      ],
      "count": 2
    },
    {
      "target": "Run Summary2",
      "target_type": "code",
      "sources": [
        {
          "source": "Should Enrich?",
          "output_idx": 1,
          "input_idx": 0
        },
        {
          "source": "Update Social Profile in Supabase",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "count": 2
    },
    {
      "target": "Merge Backfill",
      "target_type": "merge",
      "sources": [
        {
          "source": "Needs Backfill?",
          "output_idx": 1,
          "input_idx": 1
        },
        {
          "source": "Extract & Patch Domain",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "count": 2
    },
    {
      "target": "Run Summary3",
      "target_type": "code",
      "sources": [
        {
          "source": "About Found Name?",
          "output_idx": 1,
          "input_idx": 0
        },
        {
          "source": "No Domain Found Name?",
          "output_idx": 1,
          "input_idx": 0
        },
        {
          "source": "Insert Contact to Supabase",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "count": 3
    },
    {
      "target": "Insert Contact to Supabase",
      "target_type": "httpRequest",
      "sources": [
        {
          "source": "Validate & Clean Contact",
          "output_idx": 0,
          "input_idx": 0
        },
        {
          "source": "Validate & Clean Contact1",
          "output_idx": 0,
          "input_idx": 0
        },
        {
          "source": "Validate & Clean Contact3",
          "output_idx": 0,
          "input_idx": 0
        },
        {
          "source": "Validate & Clean Contact4",
          "output_idx": 0,
          "input_idx": 0
        },
        {
          "source": "Validate & Clean Contact2",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "count": 5
    },
    {
      "target": "Hunter Found Email?",
      "target_type": "if",
      "sources": [
        {
          "source": "Parse Hunter Response",
          "output_idx": 0,
          "input_idx": 0
        },
        {
          "source": "Skip Hunter",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "count": 2
    },
    {
      "target": "Merge Email Results",
      "target_type": "code",
      "sources": [
        {
          "source": "Hunter Found Email?",
          "output_idx": 0,
          "input_idx": 0
        },
        {
          "source": "Parse Snov.io Response",
          "output_idx": 0,
          "input_idx": 0
        },
        {
          "source": "Skip Snov.io",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "count": 3
    },
    {
      "target": "Collect Email Results",
      "target_type": "code",
      "sources": [
        {
          "source": "Merge Email Results",
          "output_idx": 0,
          "input_idx": 0
        },
        {
          "source": "Skip Email - Pass Through",
          "output_idx": 0,
          "input_idx": 0
        },
        {
          "source": "No Domain - Skip Email",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "count": 3
    },
    {
      "target": "Collect NamSor Results",
      "target_type": "code",
      "sources": [
        {
          "source": "Parse NamSor Response",
          "output_idx": 0,
          "input_idx": 0
        },
        {
          "source": "Skip NamSor",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "count": 2
    },
    {
      "target": "Collect Updates",
      "target_type": "code",
      "sources": [
        {
          "source": "Has Updates?",
          "output_idx": 1,
          "input_idx": 0
        },
        {
          "source": "Update Contact in Supabase",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "count": 2
    },
    {
      "target": "Skip Verification",
      "target_type": "code",
      "sources": [
        {
          "source": "Has Email to Verify?",
          "output_idx": 1,
          "input_idx": 0
        },
        {
          "source": "Hunter Verifier Enabled?",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "count": 2
    },
    {
      "target": "Collect Verified Results",
      "target_type": "code",
      "sources": [
        {
          "source": "Parse Verifier Response",
          "output_idx": 0,
          "input_idx": 0
        },
        {
          "source": "Skip Verification",
          "output_idx": 0,
          "input_idx": 0
        }
      ],
      "count": 2
    }
  ],
  "cross_refs": [
    {
      "code_node": "Parse Status",
      "referenced_node": "Extract Run ID",
      "method": "first"
    },
    {
      "code_node": "Parse Status",
      "referenced_node": "Parse Status",
      "method": "first"
    },
    {
      "code_node": "Normalize Google Results",
      "referenced_node": "Metro Config",
      "method": "first"
    },
    {
      "code_node": "Normalize Yelp Results",
      "referenced_node": "Metro Config",
      "method": "first"
    },
    {
      "code_node": "Normalize Yelp Results",
      "referenced_node": "Split Search Queries",
      "method": "first"
    },
    {
      "code_node": "Run Summary",
      "referenced_node": "Deduplicate Records",
      "method": "all"
    },
    {
      "code_node": "Run Summary",
      "referenced_node": "Metro Config",
      "method": "first"
    },
    {
      "code_node": "Extract & Patch Domain",
      "referenced_node": "Needs Backfill?",
      "method": "item.json"
    },
    {
      "code_node": "Analyze Website HTML",
      "referenced_node": "Has Website?",
      "method": "item.json"
    },
    {
      "code_node": "Merge Website Results",
      "referenced_node": "Enrichment Config",
      "method": "first"
    },
    {
      "code_node": "Parse Google Details",
      "referenced_node": "Has Google Place ID?",
      "method": "item.json"
    },
    {
      "code_node": "Prepare Social Processing",
      "referenced_node": "Prepare Company Update",
      "method": "item.json"
    },
    {
      "code_node": "Prepare Social Processing",
      "referenced_node": "Enrichment Config",
      "method": "first"
    },
    {
      "code_node": "Extract FB Run ID",
      "referenced_node": "Prepare FB Search Input",
      "method": "first"
    },
    {
      "code_node": "Extract IG Run ID",
      "referenced_node": "Prepare IG Search Input",
      "method": "first"
    },
    {
      "code_node": "Parse FB Status",
      "referenced_node": "Extract FB Run ID",
      "method": "first"
    },
    {
      "code_node": "Parse FB Status",
      "referenced_node": "Parse FB Status",
      "method": "first"
    },
    {
      "code_node": "Parse IG Status",
      "referenced_node": "Extract IG Run ID",
      "method": "first"
    },
    {
      "code_node": "Parse IG Status",
      "referenced_node": "Parse IG Status",
      "method": "first"
    },
    {
      "code_node": "Match FB Results to Companies",
      "referenced_node": "Extract FB Run ID",
      "method": "first"
    },
    {
      "code_node": "Match IG Results to Companies",
      "referenced_node": "Extract IG Run ID",
      "method": "first"
    },
    {
      "code_node": "Run Summary1",
      "referenced_node": "Enrichment Config",
      "method": "first"
    },
    {
      "code_node": "Run Summary1",
      "referenced_node": "Parse Batch",
      "method": "all"
    },
    {
      "code_node": "Run Summary1",
      "referenced_node": "Analyze Website HTML",
      "method": "all"
    },
    {
      "code_node": "Run Summary1",
      "referenced_node": "Match FB Results to Companies",
      "method": "first"
    },
    {
      "code_node": "Run Summary1",
      "referenced_node": "Match IG Results to Companies",
      "method": "first"
    },
    {
      "code_node": "Build SociaVault Request",
      "referenced_node": "Step 3b Config",
      "method": "first"
    },
    {
      "code_node": "Parse SociaVault Response",
      "referenced_node": "Should Enrich?",
      "method": "item.json"
    },
    {
      "code_node": "Run Summary2",
      "referenced_node": "Step 3b Config",
      "method": "first"
    },
    {
      "code_node": "Run Summary2",
      "referenced_node": "Build SociaVault Request",
      "method": "all"
    },
    {
      "code_node": "Run Summary2",
      "referenced_node": "Parse SociaVault Response",
      "method": "all"
    },
    {
      "code_node": "Filter & Parse Batch",
      "referenced_node": "Fetch Companies",
      "method": "all"
    },
    {
      "code_node": "Parse Apollo Search",
      "referenced_node": "Solo Practitioner Check",
      "method": "item.json"
    },
    {
      "code_node": "Parse About Page",
      "referenced_node": "Solo Practitioner Check",
      "method": "item.json"
    },
    {
      "code_node": "Parse Apollo Enrich",
      "referenced_node": "Parse Apollo Search",
      "method": "item.json"
    },
    {
      "code_node": "Run Summary3",
      "referenced_node": "Step 3a Config",
      "method": "first"
    },
    {
      "code_node": "Run Summary3",
      "referenced_node": "Filter & Parse Batch",
      "method": "all"
    },
    {
      "code_node": "Run Summary3",
      "referenced_node": "Prepare Solo Contact",
      "method": "all"
    },
    {
      "code_node": "Run Summary3",
      "referenced_node": "Parse Apollo Search",
      "method": "all"
    },
    {
      "code_node": "Run Summary3",
      "referenced_node": "Parse Apollo Enrich",
      "method": "all"
    },
    {
      "code_node": "Run Summary3",
      "referenced_node": "Apollo Search Only Contact",
      "method": "all"
    },
    {
      "code_node": "Run Summary3",
      "referenced_node": "Parse About Page",
      "method": "all"
    },
    {
      "code_node": "Run Summary3",
      "referenced_node": "No Domain Fallback",
      "method": "all"
    },
    {
      "code_node": "Filter & Merge Contacts",
      "referenced_node": "Fetch Contacts",
      "method": "all"
    },
    {
      "code_node": "Filter & Merge Contacts",
      "referenced_node": "Fetch Companies1",
      "method": "all"
    },
    {
      "code_node": "Parse Hunter Response",
      "referenced_node": "Has Domain & Name?",
      "method": "item.json"
    },
    {
      "code_node": "Parse Snov.io Response",
      "referenced_node": "Hunter Found Email?",
      "method": "item.json"
    },
    {
      "code_node": "Collect Email Results",
      "referenced_node": "Merge Email Results",
      "method": "all"
    },
    {
      "code_node": "Collect Email Results",
      "referenced_node": "Skip Email - Pass Through",
      "method": "all"
    },
    {
      "code_node": "Collect Email Results",
      "referenced_node": "No Domain - Skip Email",
      "method": "all"
    },
    {
      "code_node": "Parse Verifier Response",
      "referenced_node": "Has Email to Verify?",
      "method": "item.json"
    },
    {
      "code_node": "Collect Verified Results",
      "referenced_node": "Parse Verifier Response",
      "method": "all"
    },
    {
      "code_node": "Collect Verified Results",
      "referenced_node": "Skip Verification",
      "method": "all"
    },
    {
      "code_node": "Parse NamSor Response",
      "referenced_node": "Needs NamSor?",
      "method": "item.json"
    },
    {
      "code_node": "Collect NamSor Results",
      "referenced_node": "Parse NamSor Response",
      "method": "all"
    },
    {
      "code_node": "Collect NamSor Results",
      "referenced_node": "Skip NamSor",
      "method": "all"
    },
    {
      "code_node": "Collect Updates",
      "referenced_node": "Update Contact in Supabase",
      "method": "all"
    },
    {
      "code_node": "Collect Updates",
      "referenced_node": "Has Updates?",
      "method": "all"
    },
    {
      "code_node": "Run Summary4",
      "referenced_node": "Step 4 Config",
      "method": "first"
    },
    {
      "code_node": "Run Summary4",
      "referenced_node": "Prepare Contact Update",
      "method": "all"
    }
  ],
  "duplicate_code_groups": {
    "Bridge to 3b": [
      "Bridge to 3b",
      "Bridge to 3a",
      "Bridge to 4"
    ],
    "Validate & Clean Contact3": [
      "Validate & Clean Contact3",
      "Validate & Clean Contact4",
      "Validate & Clean Contact2",
      "Validate & Clean Contact1",
      "Validate & Clean Contact"
    ]
  },
  "connections_raw": {
    "Metro Config": {
      "main": [
        [
          {
            "node": "Split Search Queries",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Split Search Queries": {
      "main": [
        [
          {
            "node": "Google Places - Text Search",
            "type": "main",
            "index": 0
          },
          {
            "node": "Start Apify Run",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Google Places - Text Search": {
      "main": [
        [
          {
            "node": "Normalize Google Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Normalize Google Results": {
      "main": [
        [
          {
            "node": "Merge All Sources",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge All Sources": {
      "main": [
        [
          {
            "node": "Deduplicate Records",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Deduplicate Records": {
      "main": [
        [
          {
            "node": "Prepare for Supabase",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare for Supabase": {
      "main": [
        [
          {
            "node": "Fuzzy Match?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fuzzy Match?": {
      "main": [
        [
          {
            "node": "Insert Flagged (Needs Review)",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Insert to Supabase",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Insert to Supabase": {
      "main": [
        [
          {
            "node": "Run Summary",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Insert Flagged (Needs Review)": {
      "main": [
        [
          {
            "node": "Run Summary",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Run ID": {
      "main": [
        [
          {
            "node": "Wait 30s",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Wait 30s": {
      "main": [
        [
          {
            "node": "Check Run Status",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Run Status": {
      "main": [
        [
          {
            "node": "Parse Status",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Status": {
      "main": [
        [
          {
            "node": "Run Succeeded?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Run Succeeded?": {
      "main": [
        [
          {
            "node": "Fetch Apify Results",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Wait 30s",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Start Apify Run": {
      "main": [
        [
          {
            "node": "Extract Run ID",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Normalize Yelp Results": {
      "main": [
        [
          {
            "node": "Merge All Sources",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Fetch Apify Results": {
      "main": [
        [
          {
            "node": "Normalize Yelp Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Run Summary": {
      "main": [
        [
          {
            "node": "Enrichment Config",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Enrichment Config": {
      "main": [
        [
          {
            "node": "Fetch Batch from Supabase",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Batch from Supabase": {
      "main": [
        [
          {
            "node": "Parse Batch",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Batch": {
      "main": [
        [
          {
            "node": "Batch Empty?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Batch Empty?": {
      "main": [
        [
          {
            "node": "No Records - Done",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Needs Backfill?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Has Website?": {
      "main": [
        [
          {
            "node": "Fetch Website HTML",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Skip - No Website",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Website HTML": {
      "main": [
        [
          {
            "node": "Analyze Website HTML",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Analyze Website HTML": {
      "main": [
        [
          {
            "node": "Merge Website Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Skip - No Website": {
      "main": [
        [
          {
            "node": "Merge Website Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Website Results": {
      "main": [
        [
          {
            "node": "Has Google Place ID?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Has Google Place ID?": {
      "main": [
        [
          {
            "node": "Google Places Details",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Skip Google Details",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Google Places Details": {
      "main": [
        [
          {
            "node": "Parse Google Details",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Google Details": {
      "main": [
        [
          {
            "node": "Prepare Company Update",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Skip Google Details": {
      "main": [
        [
          {
            "node": "Prepare Company Update",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Company Update": {
      "main": [
        [
          {
            "node": "Update Company in Supabase",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Company in Supabase": {
      "main": [
        [
          {
            "node": "Prepare Social Processing",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Social Processing": {
      "main": [
        [
          {
            "node": "Has Social Links?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Has Social Links?": {
      "main": [
        [
          {
            "node": "Prepare Social Profiles Insert",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Needs Social Discovery?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Social Profiles Insert": {
      "main": [
        [
          {
            "node": "Insert Social Profiles",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Insert Social Profiles": {
      "main": [
        [
          {
            "node": "Run Summary1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Needs Social Discovery?": {
      "main": [
        [
          {
            "node": "Build Social Discovery Batch",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Run Summary1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Social Discovery Batch": {
      "main": [
        [
          {
            "node": "Discovery Queries Exist?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Discovery Queries Exist?": {
      "main": [
        [
          {
            "node": "Prepare FB Search Input",
            "type": "main",
            "index": 0
          },
          {
            "node": "Prepare IG Search Input",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Run Summary1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare FB Search Input": {
      "main": [
        [
          {
            "node": "Start FB Search Run",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Start FB Search Run": {
      "main": [
        [
          {
            "node": "Extract FB Run ID",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract FB Run ID": {
      "main": [
        [
          {
            "node": "Wait FB 30s",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Wait FB 30s": {
      "main": [
        [
          {
            "node": "Check FB Run Status",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check FB Run Status": {
      "main": [
        [
          {
            "node": "Parse FB Status",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse FB Status": {
      "main": [
        [
          {
            "node": "FB Run Succeeded?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "FB Run Succeeded?": {
      "main": [
        [
          {
            "node": "Fetch FB Search Results",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Wait FB 30s",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch FB Search Results": {
      "main": [
        [
          {
            "node": "Match FB Results to Companies",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Match FB Results to Companies": {
      "main": [
        [
          {
            "node": "FB Matches Found?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "FB Matches Found?": {
      "main": [
        [
          {
            "node": "Insert FB Social Profiles",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Run Summary1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Insert FB Social Profiles": {
      "main": [
        [
          {
            "node": "Run Summary1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare IG Search Input": {
      "main": [
        [
          {
            "node": "Start IG Search Run",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Start IG Search Run": {
      "main": [
        [
          {
            "node": "Extract IG Run ID",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract IG Run ID": {
      "main": [
        [
          {
            "node": "Wait IG 30s",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Wait IG 30s": {
      "main": [
        [
          {
            "node": "Check IG Run Status",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check IG Run Status": {
      "main": [
        [
          {
            "node": "Parse IG Status",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse IG Status": {
      "main": [
        [
          {
            "node": "IG Run Succeeded?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IG Run Succeeded?": {
      "main": [
        [
          {
            "node": "Fetch IG Search Results",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Wait IG 30s",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch IG Search Results": {
      "main": [
        [
          {
            "node": "Match IG Results to Companies",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Match IG Results to Companies": {
      "main": [
        [
          {
            "node": "IG Matches Found?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IG Matches Found?": {
      "main": [
        [
          {
            "node": "Insert IG Social Profiles",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Run Summary1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Insert IG Social Profiles": {
      "main": [
        [
          {
            "node": "Run Summary1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Step 3b Config": {
      "main": [
        [
          {
            "node": "Fetch Unenriched Social Profiles",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Unenriched Social Profiles": {
      "main": [
        [
          {
            "node": "Parse Batch1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build SociaVault Request": {
      "main": [
        [
          {
            "node": "Should Enrich?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Should Enrich?": {
      "main": [
        [
          {
            "node": "Call SociaVault API",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Run Summary2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Call SociaVault API": {
      "main": [
        [
          {
            "node": "Parse SociaVault Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse SociaVault Response": {
      "main": [
        [
          {
            "node": "Update Social Profile in Supabase",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Social Profile in Supabase": {
      "main": [
        [
          {
            "node": "Run Summary2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Batch1": {
      "main": [
        [
          {
            "node": "Batch Empty?1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Batch Empty?1": {
      "main": [
        [
          {
            "node": "No Records - Done1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Build SociaVault Request",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Run Summary1": {
      "main": [
        [
          {
            "node": "Bridge to 3b",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Needs Backfill?": {
      "main": [
        [
          {
            "node": "Google Places Lookup",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Merge Backfill",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Google Places Lookup": {
      "main": [
        [
          {
            "node": "Extract & Patch Domain",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract & Patch Domain": {
      "main": [
        [
          {
            "node": "Merge Backfill",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Backfill": {
      "main": [
        [
          {
            "node": "Has Website?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Step 3a Config": {
      "main": [
        [
          {
            "node": "Fetch Companies",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Companies": {
      "main": [
        [
          {
            "node": "Fetch Existing Contacts",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Existing Contacts": {
      "main": [
        [
          {
            "node": "Filter & Parse Batch",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Filter & Parse Batch": {
      "main": [
        [
          {
            "node": "Batch Empty?2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Solo Practitioner Check": {
      "main": [
        [
          {
            "node": "Is Solo?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Is Solo?": {
      "main": [
        [
          {
            "node": "Prepare Solo Contact",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Has Domain & Apollo?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Solo Contact": {
      "main": [
        [
          {
            "node": "Validate & Clean Contact",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Has Domain & Apollo?": {
      "main": [
        [
          {
            "node": "Apollo People Search",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "No Domain Fallback",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Apollo People Search": {
      "main": [
        [
          {
            "node": "Parse Apollo Search",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Apollo Search": {
      "main": [
        [
          {
            "node": "Apollo Found People?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Apollo Found People?": {
      "main": [
        [
          {
            "node": "Enrich Enabled?",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Fetch About Page",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Enrich Enabled?": {
      "main": [
        [
          {
            "node": "Apollo People Enrich",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Apollo Search Only Contact",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Apollo People Enrich": {
      "main": [
        [
          {
            "node": "Parse Apollo Enrich",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Apollo Enrich": {
      "main": [
        [
          {
            "node": "Validate & Clean Contact1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Apollo Search Only Contact": {
      "main": [
        [
          {
            "node": "Validate & Clean Contact3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch About Page": {
      "main": [
        [
          {
            "node": "Parse About Page",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse About Page": {
      "main": [
        [
          {
            "node": "About Found Name?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "About Found Name?": {
      "main": [
        [
          {
            "node": "Validate & Clean Contact4",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Run Summary3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "No Domain Fallback": {
      "main": [
        [
          {
            "node": "No Domain Found Name?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "No Domain Found Name?": {
      "main": [
        [
          {
            "node": "Validate & Clean Contact2",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Run Summary3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Insert Contact to Supabase": {
      "main": [
        [
          {
            "node": "Run Summary3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Batch Empty?2": {
      "main": [
        [
          {
            "node": "No Records - Done2",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Solo Practitioner Check",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Run Summary2": {
      "main": [
        [
          {
            "node": "Bridge to 3a",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Bridge to 3b": {
      "main": [
        [
          {
            "node": "Step 3b Config",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Bridge to 3a": {
      "main": [
        [
          {
            "node": "Step 3a Config",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "When clicking ‘Execute workflow’": {
      "main": [
        [
          {
            "node": "Metro Config",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate & Clean Contact": {
      "main": [
        [
          {
            "node": "Insert Contact to Supabase",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate & Clean Contact1": {
      "main": [
        [
          {
            "node": "Insert Contact to Supabase",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate & Clean Contact3": {
      "main": [
        [
          {
            "node": "Insert Contact to Supabase",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate & Clean Contact4": {
      "main": [
        [
          {
            "node": "Insert Contact to Supabase",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate & Clean Contact2": {
      "main": [
        [
          {
            "node": "Insert Contact to Supabase",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Run Summary3": {
      "main": [
        [
          {
            "node": "Bridge to 4",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Step 4 Config": {
      "main": [
        [
          {
            "node": "Fetch Contacts",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Contacts": {
      "main": [
        [
          {
            "node": "Collapse to Single",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Filter & Merge Contacts": {
      "main": [
        [
          {
            "node": "Batch Empty?3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Needs Email?": {
      "main": [
        [
          {
            "node": "Has Domain & Name?",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Skip Email - Pass Through",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Has Domain & Name?": {
      "main": [
        [
          {
            "node": "Hunter Enabled?",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "No Domain - Skip Email",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Hunter Email Finder": {
      "main": [
        [
          {
            "node": "Parse Hunter Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Hunter Response": {
      "main": [
        [
          {
            "node": "Hunter Found Email?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Hunter Found Email?": {
      "main": [
        [
          {
            "node": "Merge Email Results",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Snov.io Enabled?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Snov.io Email Finder": {
      "main": [
        [
          {
            "node": "Parse Snov.io Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Snov.io Response": {
      "main": [
        [
          {
            "node": "Merge Email Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Email Results": {
      "main": [
        [
          {
            "node": "Collect Email Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Skip Email - Pass Through": {
      "main": [
        [
          {
            "node": "Collect Email Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "No Domain - Skip Email": {
      "main": [
        [
          {
            "node": "Collect Email Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Hunter Enabled?": {
      "main": [
        [
          {
            "node": "Skip Hunter",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Hunter Email Finder",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Skip Hunter": {
      "main": [
        [
          {
            "node": "Hunter Found Email?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Snov.io Enabled?": {
      "main": [
        [
          {
            "node": "Skip Snov.io",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Snov.io Email Finder",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Skip Snov.io": {
      "main": [
        [
          {
            "node": "Merge Email Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Needs NamSor?": {
      "main": [
        [
          {
            "node": "NamSor Origin",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Skip NamSor",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "NamSor Origin": {
      "main": [
        [
          {
            "node": "Parse NamSor Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse NamSor Response": {
      "main": [
        [
          {
            "node": "Collect NamSor Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Skip NamSor": {
      "main": [
        [
          {
            "node": "Collect NamSor Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Contact Update": {
      "main": [
        [
          {
            "node": "Has Updates?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Has Updates?": {
      "main": [
        [
          {
            "node": "Update Contact in Supabase",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Collect Updates",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Contact in Supabase": {
      "main": [
        [
          {
            "node": "Collect Updates",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Companies1": {
      "main": [
        [
          {
            "node": "Filter & Merge Contacts",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Batch Empty?3": {
      "main": [
        [
          {
            "node": "No Records - Done3",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Needs Email?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Bridge to 4": {
      "main": [
        [
          {
            "node": "Step 4 Config",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Collapse to Single": {
      "main": [
        [
          {
            "node": "Fetch Companies1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Has Email to Verify?": {
      "main": [
        [
          {
            "node": "Hunter Verifier Enabled?",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Skip Verification",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Hunter Verifier Enabled?": {
      "main": [
        [
          {
            "node": "Skip Verification",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Hunter Email Verifier",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Hunter Email Verifier": {
      "main": [
        [
          {
            "node": "Parse Verifier Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Verifier Response": {
      "main": [
        [
          {
            "node": "Collect Verified Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Skip Verification": {
      "main": [
        [
          {
            "node": "Collect Verified Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Collect Verified Results": {
      "main": [
        [
          {
            "node": "Needs NamSor?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Collect NamSor Results": {
      "main": [
        [
          {
            "node": "Prepare Contact Update",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Collect Updates": {
      "main": [
        [
          {
            "node": "Run Summary4",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Collect Email Results": {
      "main": [
        [
          {
            "node": "Has Email to Verify?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  }
}