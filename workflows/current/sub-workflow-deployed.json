{
  "updatedAt": "2026-02-21T18:15:05.002Z",
  "createdAt": "2026-02-20T16:45:58.923Z",
  "id": "fGm4IP0rWxgHptN8",
  "name": "Batch Enrichment — Sub-Workflow",
  "description": null,
  "active": true,
  "isArchived": false,
  "nodes": [
    {
      "id": "sw-webhook-0001",
      "name": "Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        0,
        192
      ],
      "webhookId": "batch-enrichment-v1",
      "parameters": {
        "httpMethod": "POST",
        "path": "batch-enrichment-v1",
        "responseMode": "responseNode",
        "options": {}
      }
    },
    {
      "id": "sw-respond-0001",
      "name": "Respond to Webhook",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [
        500,
        192
      ],
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify({ status: \"accepted\", company_count: $json.body.company_ids.length }) }}",
        "options": {}
      }
    },
    {
      "id": "sw-enrich-companies-0001",
      "name": "Enrich Companies",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1000,
        192
      ],
      "parameters": {
        "jsCode": "// Enrich Companies — Single Code node replacing entire Step 2 + Step 3b pipeline\n// Mode: runOnceForAllItems\n// Input: { metro, company_ids } from sub-workflow webhook, OR trigger from main workflow\n// Output: summary → Find Contacts (includes metro + company_ids for chain)\n//\n// For each discovered company: domain backfill, website scrape, Google Details,\n// company update, social profiles insert. All via this.helpers.httpRequest().\n\nconst inputData = $input.first().json;\n// n8n Webhook v2 wraps POST body under .body; unwrap for sub-workflow mode\nconst payload = inputData.body || inputData;\nconst metro = payload.metro || payload.metro_name;\nconst companyIds = payload.company_ids || null;\nif (!metro) {\n  throw new Error('Enrich Companies: missing metro in input. Expected metro or metro_name field.');\n}\nconst supabaseUrl = $env.SUPABASE_URL;\nconst supabaseKey = $env.SUPABASE_SERVICE_KEY;\nconst googleApiKey = $env.GOOGLE_PLACES_API_KEY;\nconst sbHeaders = { 'apikey': supabaseKey, 'Authorization': 'Bearer ' + supabaseKey };\nconst sbWriteHeaders = { ...sbHeaders, 'Content-Type': 'application/json', 'Prefer': 'return=minimal' };\n\n// ═══ CONFIG (previously in Enrichment Config Set node) ═══\nconst SKIP_GOOGLE_DETAILS = false;\nconst HTTP_TIMEOUT = 15000;\n\n// ═══ CONSTANTS ═══\n\nconst BLOCKED_DOMAINS = ['wixsite.com','wix.com','setmore.com','schedulista.com','glossgenius.com','square.site','genbook.com','jane.app','acuityscheduling.com','mindbodyonline.com','mindbody.io','vagaro.com','fresha.com','schedulicity.com','booksy.com','massagebook.com','noterro.com','clinicsense.com','calendly.com','squarespace.com'];\n\nconst bookingSignatures = {\n  'jane_app': ['jane.app', 'janeapp.com'],\n  'acuity': ['acuityscheduling.com', 'squareup.com/appointments', 'app.acuityscheduling.com'],\n  'mindbody': ['mindbodyonline.com', 'clients.mindbodyonline.com', 'mindbody.io', 'healcode.com'],\n  'square': ['square.site', 'squareup.com'],\n  'vagaro': ['vagaro.com'],\n  'fresha': ['fresha.com', 'shedul.com'],\n  'schedulicity': ['schedulicity.com'],\n  'schedulista': ['schedulista.com'],\n  'booksy': ['booksy.com'],\n  'massagebook': ['massagebook.com'],\n  'genbook': ['genbook.com'],\n  'noterro': ['noterro.com'],\n  'clinicsense': ['clinicsense.com'],\n  'wix_bookings': ['wix.com/booking', 'bookings.wixapps.net'],\n  'calendly': ['calendly.com']\n};\n\nconst bookingPatterns = ['book now', 'book online', 'book appointment', 'schedule now', 'schedule online', 'book a massage', 'online booking'];\n\nconst adSignatures = [\n  'googleadservices.com', 'googlesyndication.com', 'googleads.g.doubleclick.net',\n  'google_conversion', 'conversion_async', 'ads/ga-audiences',\n  'fbevents.js', 'fbq(', 'snap.licdn.com', 'linkedin.com/insight',\n  'analytics.tiktok.com', 'tiktok.com/i18n/pixel', 'ads-twitter.com', 'static.ads-twitter.com'\n];\n\nconst socialPatterns = {\n  facebook: /https?:\\/\\/(?:www\\.)?facebook\\.com\\/[a-zA-Z0-9._-]+/gi,\n  instagram: /https?:\\/\\/(?:www\\.)?instagram\\.com\\/[a-zA-Z0-9._-]+/gi,\n  tiktok: /https?:\\/\\/(?:www\\.)?tiktok\\.com\\/@[a-zA-Z0-9._-]+/gi,\n  linkedin: /https?:\\/\\/(?:www\\.)?linkedin\\.com\\/(?:company|in)\\/[a-zA-Z0-9._-]+/gi,\n  x: /https?:\\/\\/(?:www\\.)?(?:twitter\\.com|x\\.com)\\/[a-zA-Z0-9._-]+/gi,\n  youtube: /https?:\\/\\/(?:www\\.)?youtube\\.com\\/(?:c\\/|channel\\/|@)[a-zA-Z0-9._-]+/gi\n};\n\nconst junkEmailDomains = [\n  'sentry.io', 'schema.org', 'w3.org', 'wordpress.com', 'wordpress.org',\n  'squarespace.com', 'wix.com', 'gravatar.com', 'facebook.com', 'twitter.com',\n  'instagram.com', 'youtube.com', 'linkedin.com', 'pinterest.com', 'tiktok.com',\n  'cloudflare.com', 'googleapis.com', 'googletagmanager.com', 'google-analytics.com',\n  'gstatic.com', 'jsdelivr.net', 'cdnjs.cloudflare.com', 'unpkg.com',\n  'bootstrapcdn.com', 'fontawesome.com', 'typekit.net', 'fonts.googleapis.com',\n  'example.com', 'example.org', 'test.com', 'localhost',\n  'mailinator.com', 'guerrillamail.com', 'tempmail.com', 'yopmail.com'\n];\n\nconst junkLocalPatterns = [\n  /^noreply$/i, /^no-reply$/i, /^donotreply$/i, /^do-not-reply$/i,\n  /^postmaster$/i, /^mailer-daemon$/i, /^webmaster$/i, /^root$/i,\n  /^null$/i, /^test$/i, /^admin$/i, /^abuse$/i\n];\n\nconst roleBasedPrefixes = ['info', 'contact', 'hello', 'office', 'reception',\n  'frontdesk', 'front.desk', 'appointments', 'booking', 'bookings',\n  'schedule', 'scheduling', 'inquiries', 'inquiry', 'general', 'team', 'staff',\n  'support', 'sales', 'billing'];\n\nconst emailRegex = /[a-zA-Z0-9._%+\\-]+@[a-zA-Z0-9.\\-]+\\.[a-zA-Z]{2,}/g;\nconst mailtoRegex = /mailto:([a-zA-Z0-9._%+\\-]+@[a-zA-Z0-9.\\-]+\\.[a-zA-Z]{2,})/gi;\n\nconst teamPatterns = [\n  /our\\s+team/i, /meet\\s+(?:the\\s+)?team/i, /our\\s+(?:therapists|practitioners|staff|massage\\s+therapists)/i,\n  /meet\\s+(?:our|the)\\s+(?:therapists|practitioners|staff)/i\n];\n\nconst soloSignals = ['sole proprietor', 'solo practice', 'independent massage',\n  'i am a licensed', \"i'm a licensed\", 'about me', 'my practice', 'my approach',\n  'my services', 'i specialize', 'i provide'];\n\n// ═══ HELPER FUNCTIONS ═══\n\nfunction isDomainBlocked(domain) {\n  if (!domain) return false;\n  const lower = domain.toLowerCase();\n  return BLOCKED_DOMAINS.some(b => lower === b || lower.endsWith('.' + b));\n}\n\nfunction detectBookingFromDomain(domain) {\n  if (!domain) return { has_online_booking: false, booking_platform: null };\n  const lower = domain.toLowerCase();\n  for (const [platform, sigs] of Object.entries(bookingSignatures)) {\n    for (const sig of sigs) {\n      if (lower.includes(sig)) return { has_online_booking: true, booking_platform: platform };\n    }\n  }\n  return { has_online_booking: false, booking_platform: null };\n}\n\nfunction analyzeWebsiteHtml(rawHtml, domain) {\n  const result = {\n    has_online_booking: false, booking_platform: null, has_paid_ads: false,\n    estimated_size: null, social_links_found: [], emails_found: [], best_email: null,\n    _website_fetch_status: 'success'\n  };\n\n  // Domain-based booking detection first\n  const domainBooking = detectBookingFromDomain(domain);\n  result.has_online_booking = domainBooking.has_online_booking;\n  result.booking_platform = domainBooking.booking_platform;\n\n  if (!rawHtml || typeof rawHtml !== 'string') {\n    result._website_fetch_status = 'empty_response';\n    return result;\n  }\n\n  const html = rawHtml.toLowerCase();\n  const htmlOriginal = rawHtml;\n\n  // Email extraction\n  const allEmailMatches = htmlOriginal.match(emailRegex) || [];\n  mailtoRegex.lastIndex = 0;\n  const mailtoEmails = new Set();\n  let mailtoMatch;\n  while ((mailtoMatch = mailtoRegex.exec(htmlOriginal)) !== null) {\n    mailtoEmails.add(mailtoMatch[1].toLowerCase());\n  }\n\n  const uniqueEmails = [...new Set(allEmailMatches.map(e => e.toLowerCase()))];\n  const scoredEmails = [];\n\n  for (const email of uniqueEmails) {\n    const [localPart, emailDomain] = email.split('@');\n    if (!emailDomain) continue;\n    if (junkEmailDomains.some(d => emailDomain.includes(d))) continue;\n    if (junkLocalPatterns.some(p => p.test(localPart))) continue;\n    if (/^\\d+$/.test(localPart)) continue;\n\n    let score = 0;\n    if (domain && emailDomain.includes(domain.replace('www.', ''))) score += 20;\n    if (mailtoEmails.has(email)) score += 10;\n    if (roleBasedPrefixes.some(p => localPart === p || localPart.startsWith(p + '.'))) score += 5;\n    scoredEmails.push({ email, score, from_mailto: mailtoEmails.has(email) });\n  }\n\n  scoredEmails.sort((a, b) => b.score - a.score);\n  result.emails_found = scoredEmails.slice(0, 5);\n  result.best_email = scoredEmails.length > 0 ? scoredEmails[0].email : null;\n\n  // HTML-based booking detection\n  if (!result.has_online_booking) {\n    for (const [platform, sigs] of Object.entries(bookingSignatures)) {\n      for (const sig of sigs) {\n        if (html.includes(sig)) {\n          result.booking_platform = platform;\n          result.has_online_booking = true;\n          break;\n        }\n      }\n      if (result.has_online_booking) break;\n    }\n  }\n  if (!result.has_online_booking) {\n    for (const pattern of bookingPatterns) {\n      if (html.includes(pattern)) {\n        result.has_online_booking = true;\n        result.booking_platform = 'unknown';\n        break;\n      }\n    }\n  }\n\n  // Paid ads detection\n  for (const sig of adSignatures) {\n    if (html.includes(sig)) { result.has_paid_ads = true; break; }\n  }\n\n  // Social links extraction\n  const seenPlatforms = new Set();\n  for (const [platform, regex] of Object.entries(socialPatterns)) {\n    regex.lastIndex = 0;\n    const matches = htmlOriginal.match(regex) || [];\n    for (const url of matches) {\n      const lowerUrl = url.toLowerCase();\n      if (lowerUrl.includes('/sharer') || lowerUrl.includes('/share') ||\n          lowerUrl.includes('/intent') || lowerUrl.includes('/login') ||\n          lowerUrl.includes('/help') || lowerUrl.includes('/about') ||\n          lowerUrl.includes('/policies') || lowerUrl.includes('/privacy')) continue;\n      if (!seenPlatforms.has(platform)) {\n        result.social_links_found.push({ platform, url: url.replace(/\\/+$/, '') });\n        seenPlatforms.add(platform);\n      }\n    }\n  }\n\n  // Team size estimation\n  let hasTeamPage = false;\n  for (const p of teamPatterns) { if (p.test(htmlOriginal)) { hasTeamPage = true; break; } }\n  if (hasTeamPage) {\n    const namePatterns = htmlOriginal.match(/<h[2-4][^>]*>[^<]{2,40}<\\/h[2-4]>/gi) || [];\n    const staffLinks = htmlOriginal.match(/\\/(?:team|staff|therapist|practitioner)s?\\/[a-z-]+/gi) || [];\n    const memberCount = Math.max(namePatterns.length, staffLinks.length);\n    if (memberCount <= 1) result.estimated_size = 'solo';\n    else if (memberCount <= 5) result.estimated_size = 'small';\n    else result.estimated_size = 'medium';\n  } else {\n    if (soloSignals.some(s => html.includes(s))) result.estimated_size = 'solo';\n  }\n\n  return result;\n}\n\nfunction extractDomainFromPlaces(company, places) {\n  if (!places || places.length === 0) return null;\n\n  const companyName = (company.name || '').toLowerCase().replace(/[^a-z0-9\\s]/g, '');\n  const companyPhone = (company.phone || '').replace(/[^\\d]/g, '');\n\n  let bestMatch = null;\n  let bestScore = 0;\n\n  for (const place of places) {\n    const placeName = ((place.displayName && place.displayName.text) || '').toLowerCase().replace(/[^a-z0-9\\s]/g, '');\n    let score = 0;\n\n    const companyWords = companyName.split(/\\s+/).filter(w => w.length > 2);\n    const placeWords = placeName.split(/\\s+/).filter(w => w.length > 2);\n    const matchingWords = companyWords.filter(w => placeWords.some(pw => pw.includes(w) || w.includes(pw)));\n    score = companyWords.length > 0 ? matchingWords.length / companyWords.length : 0;\n\n    const placePhone = (place.internationalPhoneNumber || place.nationalPhoneNumber || '').replace(/[^\\d]/g, '');\n    if (companyPhone && placePhone && (placePhone.includes(companyPhone.slice(-10)) || companyPhone.includes(placePhone.slice(-10)))) {\n      score += 0.5;\n    }\n\n    if (score > bestScore && score >= 0.4) { bestScore = score; bestMatch = place; }\n  }\n\n  if (!bestMatch) return null;\n\n  const website = bestMatch.websiteUri || '';\n  let domain = null;\n  if (website) {\n    const match = website.match(/^https?:\\/\\/(?:www\\.)?([^\\/]+)/i);\n    if (match) domain = match[1];\n  }\n\n  // Check domain against blocklist\n  if (domain && isDomainBlocked(domain)) domain = null;\n\n  return {\n    domain,\n    google_place_id: bestMatch.id || null,\n    google_rating: bestMatch.rating || null,\n    google_review_count: bestMatch.userRatingCount || null,\n    _match_score: bestScore\n  };\n}\n\nconst delay = (ms) => new Promise(r => setTimeout(r, ms));\n\n// ═══ FETCH COMPANIES ═══\n\n// Batch mode: query by company IDs; Legacy mode: query by metro + status\nlet companyQueryParams;\nif (companyIds && companyIds.length > 0) {\n  companyQueryParams = `id=in.(${companyIds.join(',')})`;\n} else {\n  companyQueryParams = `enrichment_status=in.(discovered,partially_enriched)&discovery_metro=eq.${encodeURIComponent(metro)}`;\n}\n\nconst companies = await this.helpers.httpRequest({\n  method: 'GET',\n  url: `${supabaseUrl}/rest/v1/companies?${companyQueryParams}&order=discovered_at.asc&limit=1000&select=id,name,phone,domain,address,city,state,country,google_place_id,category,has_website,google_review_count,google_rating,source_urls,on_yelp,on_groupon`,\n  headers: sbHeaders,\n  json: true\n});\n\nif (!Array.isArray(companies) || companies.length === 0) {\n  console.log('No companies to enrich for metro: ' + metro);\n  return [{ json: { step: 'enrich_companies', processed: 0, message: 'No companies to enrich', metro, company_ids: companyIds } }];\n}\n\nconsole.log(`Enrich Companies: ${companies.length} companies to process for ${metro}`);\n\n// ═══ STATS ═══\nconst stats = {\n  processed: 0, domainBackfilled: 0, websitesFetched: 0, websiteErrors: 0,\n  bookingDetected: 0, paidAdsDetected: 0, socialFromWebsite: 0, socialProfilesInserted: 0,\n  googleDetailsProcessed: 0, companyUpdates: 0, updateErrors: 0, errors: 0\n};\n\n// ═══ MAIN LOOP ═══\n\nfor (const company of companies) {\n  try {\n    let domain = company.domain;\n    let backfillPatch = {};\n    let has_website = company.has_website;\n\n    // ── 1. Domain backfill if needed ──\n    if (!domain && has_website) {\n      try {\n        const placesResp = await this.helpers.httpRequest({\n          method: 'POST',\n          url: 'https://places.googleapis.com/v1/places:searchText',\n          headers: {\n            'X-Goog-FieldMask': 'places.id,places.displayName,places.nationalPhoneNumber,places.internationalPhoneNumber,places.websiteUri,places.rating,places.userRatingCount',\n            'X-Goog-Api-Key': googleApiKey,\n            'Content-Type': 'application/json'\n          },\n          body: { textQuery: `${company.name} ${company.city} ${company.state}`, maxResultCount: 3 },\n          json: true\n        });\n\n        const result = extractDomainFromPlaces(company, placesResp.places || []);\n        if (result) {\n          if (result.domain) {\n            domain = result.domain;\n            has_website = true;\n            backfillPatch.domain = domain;\n            backfillPatch.has_website = true;\n          }\n          if (result.google_place_id && !company.google_place_id) backfillPatch.google_place_id = result.google_place_id;\n          if (result.google_rating && !company.google_rating) backfillPatch.google_rating = result.google_rating;\n          if (result.google_review_count && !company.google_review_count) backfillPatch.google_review_count = result.google_review_count;\n          stats.domainBackfilled++;\n        }\n        await delay(200);\n      } catch(e) {\n        console.log(`Domain backfill error for ${company.name}: ${e.message}`);\n      }\n    }\n\n    // ── 2. Website scrape ──\n    let websiteData = {\n      has_online_booking: false, booking_platform: null, has_paid_ads: false,\n      estimated_size: null, social_links_found: [], emails_found: [], best_email: null,\n      _website_fetch_status: 'skipped'\n    };\n\n    if (domain && !isDomainBlocked(domain)) {\n      try {\n        const resp = await this.helpers.httpRequest({\n          method: 'GET',\n          url: `https://${domain}`,\n          headers: {\n            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36',\n            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8'\n          },\n          returnFullResponse: true,\n          timeout: HTTP_TIMEOUT,\n          json: false,\n        });\n        const rawHtml = resp.body || '';\n        if (typeof rawHtml === 'string' && rawHtml.length > 100) {\n          websiteData = analyzeWebsiteHtml(rawHtml, domain);\n          stats.websitesFetched++;\n        } else {\n          websiteData._website_fetch_status = 'empty_response';\n          stats.websiteErrors++;\n        }\n      } catch(e) {\n        websiteData._website_fetch_status = 'error';\n        // Still check domain for booking platform signals\n        const domainBooking = detectBookingFromDomain(domain);\n        websiteData.has_online_booking = domainBooking.has_online_booking;\n        websiteData.booking_platform = domainBooking.booking_platform;\n        stats.websiteErrors++;\n      }\n    } else if (domain && isDomainBlocked(domain)) {\n      // Blocked domain — still detect booking platform from domain\n      const domainBooking = detectBookingFromDomain(domain);\n      websiteData.has_online_booking = domainBooking.has_online_booking;\n      websiteData.booking_platform = domainBooking.booking_platform;\n      websiteData._website_fetch_status = 'skipped_blocked_domain';\n    } else {\n      // No domain — check company's existing domain for booking signals\n      const domainBooking = detectBookingFromDomain(company.domain);\n      websiteData.has_online_booking = domainBooking.has_online_booking;\n      websiteData.booking_platform = domainBooking.booking_platform;\n      websiteData._website_fetch_status = 'skipped_no_website';\n    }\n\n    if (websiteData.has_online_booking) stats.bookingDetected++;\n    if (websiteData.has_paid_ads) stats.paidAdsDetected++;\n    stats.socialFromWebsite += websiteData.social_links_found.length;\n\n    // ── 3. Google Places Details ──\n    let googleDetails = {\n      opening_hours: null, business_status: null, photo_count: 0,\n      price_level: null, additional_types: [], _fetch_status: 'skipped'\n    };\n\n    const placeId = company.google_place_id || backfillPatch.google_place_id;\n    if (placeId && !SKIP_GOOGLE_DETAILS) {\n      try {\n        const details = await this.helpers.httpRequest({\n          method: 'GET',\n          url: `https://places.googleapis.com/v1/places/${placeId}`,\n          headers: {\n            'X-Goog-FieldMask': 'currentOpeningHours,regularOpeningHours,types,photos,priceLevel,businessStatus',\n            'X-Goog-Api-Key': googleApiKey\n          },\n          json: true\n        });\n\n        if (details && !details.error) {\n          if (details.regularOpeningHours && details.regularOpeningHours.periods) {\n            googleDetails.opening_hours = details.regularOpeningHours;\n          } else if (details.currentOpeningHours && details.currentOpeningHours.periods) {\n            googleDetails.opening_hours = details.currentOpeningHours;\n          }\n          googleDetails.business_status = details.businessStatus || null;\n          if (details.photos && Array.isArray(details.photos)) googleDetails.photo_count = details.photos.length;\n          googleDetails.price_level = details.priceLevel || null;\n          if (details.types && Array.isArray(details.types)) googleDetails.additional_types = details.types;\n          googleDetails._fetch_status = 'success';\n          stats.googleDetailsProcessed++;\n        }\n        await delay(100);\n      } catch(e) {\n        googleDetails._fetch_status = 'error';\n        console.log(`Google Details error for ${company.name}: ${e.message}`);\n      }\n    }\n\n    // ── 4. Build update payload ──\n    const now = new Date().toISOString();\n    const updatePayload = {\n      has_online_booking: websiteData.has_online_booking || false,\n      booking_platform: websiteData.booking_platform || null,\n      has_paid_ads: websiteData.has_paid_ads || false,\n      estimated_size: websiteData.estimated_size || null,\n      enrichment_status: 'partially_enriched',\n      enriched_at: now\n    };\n\n    // Backfill data\n    if (backfillPatch.domain) updatePayload.domain = backfillPatch.domain;\n    if (backfillPatch.google_place_id) updatePayload.google_place_id = backfillPatch.google_place_id;\n    if (backfillPatch.google_rating) updatePayload.google_rating = backfillPatch.google_rating;\n    if (backfillPatch.google_review_count) updatePayload.google_review_count = backfillPatch.google_review_count;\n    if (backfillPatch.has_website) updatePayload.has_website = backfillPatch.has_website;\n    if (has_website && !company.has_website) updatePayload.has_website = has_website;\n\n    // Website-scraped email\n    if (websiteData.best_email) updatePayload.email = websiteData.best_email;\n\n    // ── 5. PATCH company in Supabase ──\n    try {\n      await this.helpers.httpRequest({\n        method: 'PATCH',\n        url: `${supabaseUrl}/rest/v1/companies?id=eq.${company.id}`,\n        headers: sbWriteHeaders,\n        body: updatePayload,\n        json: true\n      });\n      stats.companyUpdates++;\n    } catch(e) {\n      console.log(`Company update error for ${company.name} (${company.id}): ${e.message}`);\n      stats.updateErrors++;\n    }\n\n    // ── 6. Insert social profiles if found ──\n    if (websiteData.social_links_found.length > 0) {\n      const rows = websiteData.social_links_found.map(link => ({\n        company_id: company.id,\n        platform: link.platform,\n        profile_url: link.url,\n        follower_count: null,\n        post_count: null,\n        last_post_date: null,\n        scraped_at: now\n      }));\n\n      try {\n        await this.helpers.httpRequest({\n          method: 'POST',\n          url: `${supabaseUrl}/rest/v1/social_profiles`,\n          headers: { ...sbHeaders, 'Content-Type': 'application/json', 'Prefer': 'resolution=merge-duplicates,return=minimal' },\n          body: rows,\n          json: true\n        });\n        stats.socialProfilesInserted += rows.length;\n      } catch(e) {\n        console.log(`Social profiles insert error for ${company.name}: ${e.message}`);\n      }\n    }\n\n    stats.processed++;\n    if (stats.processed % 25 === 0) {\n      console.log(`  Progress: ${stats.processed}/${companies.length} companies enriched`);\n    }\n  } catch(e) {\n    console.log(`FATAL error enriching ${company.name}: ${e.message}`);\n    stats.errors++;\n  }\n}\n\n// ═══ SUMMARY ═══\nconst summary = {\n  step: 'enrich_companies',\n  metro,\n  run_completed_at: new Date().toISOString(),\n  companies_processed: stats.processed,\n  domain_backfilled: stats.domainBackfilled,\n  websites_fetched: stats.websitesFetched,\n  website_errors: stats.websiteErrors,\n  booking_platforms_detected: stats.bookingDetected,\n  paid_ads_detected: stats.paidAdsDetected,\n  social_links_from_websites: stats.socialFromWebsite,\n  social_profiles_inserted: stats.socialProfilesInserted,\n  google_details_processed: stats.googleDetailsProcessed,\n  company_updates: stats.companyUpdates,\n  update_errors: stats.updateErrors,\n  fatal_errors: stats.errors,\n  message: `Enriched ${stats.processed} companies. ${stats.websitesFetched} websites fetched, ${stats.socialProfilesInserted} social profiles, ${stats.bookingDetected} booking platforms, ${stats.paidAdsDetected} paid ads. ${stats.updateErrors} update errors, ${stats.errors} fatal errors.`\n};\n\nconsole.log('=== STEP 2: ENRICH COMPANIES SUMMARY ===');\nconsole.log(JSON.stringify(summary, null, 2));\n\n// Pass metro + company_ids through for the next node in the chain\nreturn [{ json: { ...summary, metro, company_ids: companyIds } }];"
      }
    },
    {
      "id": "sw-find-contacts-0001",
      "name": "Find Contacts",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1500,
        192
      ],
      "parameters": {
        "jsCode": "// Find Contacts — Single Code node replacing entire Step 3a pipeline\n// Mode: runOnceForAllItems\n// Input: { metro, company_ids } from upstream Enrich Companies, OR main workflow trigger\n// Output: summary → Enrich Contacts (includes metro + company_ids for chain)\n//\n// For each company without contacts: solo detection, Apollo search/enrich,\n// about page scraping, name extraction, validation, Supabase insert.\n\nconst inputData = $input.first().json;\n// n8n Webhook v2 wraps POST body under .body; unwrap defensively\nconst payload = inputData.body || inputData;\nconst metro = payload.metro || payload.metro_name;\nconst companyIds = payload.company_ids || null;\nif (!metro) {\n  throw new Error('Find Contacts: missing metro in input. Expected metro or metro_name field.');\n}\nconst supabaseUrl = $env.SUPABASE_URL;\nconst supabaseKey = $env.SUPABASE_SERVICE_KEY;\nconst apolloApiKey = $env.APOLLO_API_KEY;\nconst sbHeaders = { 'apikey': supabaseKey, 'Authorization': 'Bearer ' + supabaseKey };\n\n// ═══ CONFIG (previously in Step 3a Config Set node) ═══\nconst SKIP_APOLLO = false;\nconst SKIP_WEBSITE_SCRAPE = false;\nconst APOLLO_ENRICH_ENABLED = true;\n\nconst delay = (ms) => new Promise(r => setTimeout(r, ms));\n\n// ═══ COMMON FIRST NAMES ═══\nconst commonFirstNames = new Set([\n  'aaron','abby','abigail','adam','adrian','adriana','aiden','aimee','alana','albert',\n  'alec','alexa','alexander','alexandra','alexis','alice','alicia','alina','alison','allison',\n  'alyssa','amanda','amber','amelia','amy','ana','andrea','andrew','angela','angelica',\n  'angie','anita','ann','anna','anne','annie','anthony','april','aria','ariana',\n  'ashley','audrey','austin','autumn','ava','avery','bailey','barbara','beatrice','becky',\n  'bella','ben','benjamin','beth','bethany','betty','beverly','bianca','blake','bonnie',\n  'brad','bradley','brandi','brandon','brandy','breanna','brenda','brent','brett','brian',\n  'briana','brianna','bridget','brittany','brittney','brooke','bruce','bryan','caitlin','caleb',\n  'cameron','camila','candace','cara','carina','carl','carla','carlos','carly','carmen',\n  'carol','carolina','caroline','carolyn','carrie','casey','cassandra','cassidy','catherine','cathy',\n  'cecilia','celeste','celia','chad','charlene','charles','charlie','charlotte','chase','chelsea',\n  'cheryl','chloe','chris','christa','christian','christina','christine','christopher','cindy','claire',\n  'clara','claudia','cody','colleen','connor','constance','corey','corinne','courtney','craig',\n  'crystal','cynthia','daisy','dale','dana','daniel','daniela','danielle','daphne','darlene',\n  'darren','dave','david','dawn','dean','deanna','debbie','deborah','debra','denise',\n  'derek','desiree','destiny','diana','diane','dianne','dolores','dominic','donna','doris',\n  'dorothy','douglas','drew','dustin','dylan','eddie','edith','edward','eileen','elaine',\n  'elena','elisa','elizabeth','ella','ellen','ellie','emily','emma','eric','erica',\n  'erika','erin','ernest','esther','ethan','eugene','eva','evan','evelyn','faith',\n  'faye','felicia','fiona','florence','frances','frank','gabriel','gabriela','gabriella','gabrielle',\n  'gail','gary','gavin','genevieve','george','georgia','gerald','gina','giselle','gladys',\n  'glen','glenn','gloria','grace','grant','greg','gregory','gretchen','hailey','haley',\n  'hannah','harold','harriet','harry','hayden','hazel','heather','heidi','helen','henry',\n  'hillary','holly','hope','howard','hunter','ian','irene','iris','isaac','isabel',\n  'isabella','ivy','jack','jackie','jackson','jacob','jacqueline','jade','jaime','jake',\n  'james','jamie','jan','jane','janet','janice','jared','jasmine','jason','jay',\n  'jean','jeanette','jeanne','jeff','jeffrey','jenna','jennifer','jenny','jeremy','jerry',\n  'jesse','jessica','jill','jillian','jim','jimmy','jo','joan','joann','joanna',\n  'joanne','jocelyn','jodi','jody','joe','joel','johanna','john','johnny','jolene',\n  'jon','jonathan','jordan','jorge','jose','joseph','josephine','josh','joshua','joy',\n  'joyce','juan','judith','judy','julia','julian','juliana','julie','june','justin',\n  'kaitlyn','kara','karen','karina','karl','kate','katelyn','katherine','kathleen','kathryn',\n  'kathy','katie','katrina','kay','kayla','keith','kelley','kelli','kelly','kelsey',\n  'ken','kendra','kenneth','kenny','kerry','kevin','kim','kimberly','kirsten','krista',\n  'kristen','kristin','kristina','kristy','kyle','kylie','lacey','lana','lance','larry',\n  'laura','lauren','laurie','leah','lee','leigh','lena','leo','leon','leslie',\n  'lexy','liam','lillian','lily','linda','lindsay','lindsey','lisa','logan','lois',\n  'lora','lorena','lori','lorraine','louis','louise','lucia','luis','luke','lydia',\n  'lynn','mackenzie','madeline','madison','maggie','malik','mallory','mandy','marc','marcia',\n  'marco','marcus','margaret','maria','mariah','marie','marilyn','marina','mario','marisa',\n  'marissa','mark','marlene','marsha','martha','martin','mary','mason','matt','matthew',\n  'maureen','max','maya','megan','meghan','melanie','melinda','melissa','melody','meredith',\n  'mia','michael','michele','michelle','miguel','mike','mildred','mindy','miranda','misty',\n  'mitchell','molly','monica','monique','morgan','mya','nadia','nancy','naomi','natalia',\n  'natalie','natasha','nathan','nathaniel','neil','nelson','nicholas','nicole','nina','noah',\n  'noel','nora','norma','olivia','owen','paige','pam','pamela','patricia','patrick',\n  'patty','paul','paula','pauline','peggy','penny','peter','philip','phyllis','priscilla',\n  'rachel','ralph','ramona','randall','randy','ray','raymond','rebecca','regina','renee',\n  'rhonda','ricardo','richard','rick','ricky','riley','rita','rob','robert','roberta',\n  'robin','rochelle','rodney','roger','ronald','rosa','rosalie','rose','rosemary','roxanne',\n  'ruby','russell','ruth','ryan','sabrina','sally','samantha','samuel','sandra','sandy',\n  'sara','sarah','savannah','scott','sean','selena','serena','seth','shana','shane',\n  'shannon','sharon','shawn','sheila','shelby','shelley','shelly','sheri','sherri','sherry',\n  'shirley','sierra','silvia','simone','sofia','sonia','sonya','sophia','stacey','stacy',\n  'stella','stephanie','stephen','steve','steven','sue','summer','susan','suzanne','sydney',\n  'sylvia','tabitha','tamara','tammy','tanya','tara','tatiana','taylor','teresa','terri',\n  'terry','tess','tessa','theresa','thomas','tiffany','tim','timothy','tina','tito',\n  'todd','tom','tommy','toni','tony','tonya','tracey','traci','tracy','travis',\n  'tricia','trisha','troy','tyler','valerie','vanessa','vera','veronica','vicki','vicky',\n  'victoria','vincent','violet','virginia','vivian','wade','walter','wanda','warren','wayne',\n  'wendy','wesley','whitney','william','willie','wilma','xavier','yolanda','yvette','yvonne',\n  'zachary','zoe'\n]);\n\nfunction isLikelyFirstName(word) {\n  return commonFirstNames.has((word || '').toLowerCase());\n}\n\n// ═══ SOLO PRACTITIONER DETECTION ═══\n\nfunction checkSoloPractitioner(company) {\n  const name = (company.name || '').trim();\n  const estimatedSize = company.estimated_size;\n  let isSolo = false, firstName = null, lastName = null;\n\n  // Pattern 1: \"by Name\"\n  const byPattern = name.match(/\\bby\\s+([A-Z][a-z]+)(?:\\s+([A-Z][a-z]+))?/i);\n  if (byPattern) {\n    if (isLikelyFirstName(byPattern[1]) || estimatedSize === 'solo') {\n      isSolo = true; firstName = byPattern[1]; lastName = byPattern[2] || null;\n    }\n  }\n\n  // Pattern 2: \"with Name\"\n  if (!firstName) {\n    const withPattern = name.match(/\\bwith\\s+([A-Z][a-z]+)(?:\\s+([A-Z][a-z]+))?/i);\n    if (withPattern && (isLikelyFirstName(withPattern[1]) || estimatedSize === 'solo')) {\n      isSolo = true; firstName = withPattern[1]; lastName = withPattern[2] || null;\n    }\n  }\n\n  // Pattern 3: Possessive\n  if (!firstName) {\n    const possessiveMatch = name.match(/^([A-Z][a-z]+)'s\\s+/i);\n    if (possessiveMatch && isLikelyFirstName(possessiveMatch[1])) {\n      isSolo = true; firstName = possessiveMatch[1];\n    }\n  }\n\n  // Pattern 4: \"FirstName LastName, LMT/CMT/RMT\"\n  if (!firstName) {\n    const nameFirst = name.match(/^([A-Z][a-z]+)\\s+([A-Z][a-z]+)(?:\\s*[,|]\\s*|\\s+)(?:LMT|CMT|RMT|Licensed|Massage|Bodywork|Therapeutic|Wellness)/i);\n    if (nameFirst && isLikelyFirstName(nameFirst[1]) && !commonFirstNames.has(nameFirst[2].toLowerCase())) {\n      isSolo = true; firstName = nameFirst[1]; lastName = nameFirst[2];\n    }\n  }\n\n  // Pattern 5: \"FirstName LastName's Massage/Spa\"\n  if (!firstName) {\n    const possessiveFullName = name.match(/^([A-Z][a-z]+)\\s+([A-Z][a-z]+)'s\\s+(?:Massage|Bodywork|Wellness|Spa|Healing)/i);\n    if (possessiveFullName && isLikelyFirstName(possessiveFullName[1])) {\n      isSolo = true; firstName = possessiveFullName[1]; lastName = possessiveFullName[2];\n    }\n  }\n\n  // Pattern 6: Three-part name with title\n  if (!firstName) {\n    const threePartName = name.match(/^([A-Z][a-z]+)\\s+([A-Z][a-z]+)\\s+([A-Z][a-z]+),?\\s+(?:LMT|CMT|RMT|Licensed)/i);\n    if (threePartName && isLikelyFirstName(threePartName[1])) {\n      isSolo = true; firstName = threePartName[1]; lastName = threePartName[3];\n    }\n  }\n\n  // Pattern 7: Name after comma\n  if (!firstName) {\n    const commaNameMatch = name.match(/,\\s*([A-Z][a-z]+)\\s+([A-Z][a-z]+)(?:\\s*,?\\s*(?:LMT|CMT|RMT|Licensed))?/i);\n    if (commaNameMatch && isLikelyFirstName(commaNameMatch[1])) {\n      isSolo = true; firstName = commaNameMatch[1]; lastName = commaNameMatch[2];\n    }\n  }\n\n  if (estimatedSize === 'solo' && !isSolo) isSolo = true;\n\n  // Reject if extracted first name matches city\n  if (firstName && company.city && firstName.toLowerCase() === company.city.toLowerCase()) {\n    firstName = null; lastName = null;\n  }\n\n  return { isSolo, firstName, lastName };\n}\n\n// ═══ NAME EXTRACTION FROM HTML ═══\n\nfunction extractNameFromHtml(html) {\n  if (!html || html.length < 100) return null;\n  const textOnly = html.replace(/<[^>]+>/g, ' ').replace(/\\s+/g, ' ');\n\n  const patterns = [\n    /(?:owner|owned\\s+by|founded\\s+by|proprietor)[:\\s]+([A-Z][a-z]+)\\s+([A-Z][a-z]+)/i,\n    /(?:hi,?\\s+i'?m|hello,?\\s+i'?m|my\\s+name\\s+is|i\\s+am)\\s+([A-Z][a-z]+)\\s+([A-Z][a-z]+)/i,\n    /(?:^|\\s)about\\s+([A-Z][a-z]+)\\s+([A-Z][a-z]+)(?:\\s*[,|]|\\s+(?:LMT|CMT|RMT|Licensed))/i,\n    /(?:^|\\s)meet\\s+([A-Z][a-z]+)\\s+([A-Z][a-z]+)(?:\\s*[,|]|\\s+(?:LMT|CMT|RMT|Licensed|is\\s+a|has\\s+been))/i,\n    /([A-Z][a-z]+)\\s+([A-Z][a-z]+),?\\s+(?:LMT|CMT|RMT|Licensed\\s+Massage)/i\n  ];\n\n  for (const pattern of patterns) {\n    for (const source of [textOnly, html]) {\n      const match = source.match(pattern);\n      if (match) {\n        const fn = match[1], ln = match[2];\n        if (isLikelyFirstName(fn) && fn.length >= 2 && fn.length <= 20 && ln.length >= 2 && ln.length <= 20) {\n          return { firstName: fn, lastName: ln };\n        }\n      }\n    }\n  }\n  return null;\n}\n\n// ═══ NAME EXTRACTION FROM BUSINESS NAME (no domain fallback) ═══\n\nfunction extractNameFromBusinessName(company) {\n  const name = (company.name || '').trim();\n  let firstName = null, lastName = null;\n\n  const patterns = [\n    { re: /\\bby\\s+([A-Z][a-z]+)(?:\\s+([A-Z][a-z]+))?/i, fi: 1, li: 2 },\n    { re: /\\bwith\\s+([A-Z][a-z]+)(?:\\s+([A-Z][a-z]+))?/i, fi: 1, li: 2 },\n    { re: /^([A-Z][a-z]+)'s\\s+/i, fi: 1, li: null },\n    { re: /^([A-Z][a-z]+)\\s+([A-Z][a-z]+)(?:\\s*,?\\s*(?:LMT|CMT|RMT|Licensed))/i, fi: 1, li: 2 },\n    { re: /,\\s*([A-Z][a-z]+)\\s+([A-Z][a-z]+)/i, fi: 1, li: 2 },\n    { re: /^([A-Z][a-z]+)\\s+([A-Z][a-z]+)\\s+(?:Massage|Bodywork|Therapeutic|Wellness|Healing|Spa)/i, fi: 1, li: 2 },\n  ];\n\n  for (const p of patterns) {\n    const m = name.match(p.re);\n    if (m && isLikelyFirstName(m[p.fi])) {\n      firstName = m[p.fi];\n      lastName = p.li ? (m[p.li] || null) : null;\n      // For pattern 6, reject if lastName is also a common first name\n      if (p.re.source.includes('Massage|Bodywork') && lastName && isLikelyFirstName(lastName)) continue;\n      break;\n    }\n  }\n\n  return firstName ? { firstName, lastName } : null;\n}\n\n// ═══ CONTACT VALIDATION ═══\n\nfunction validateAndCleanContact(contact) {\n  const flags = [];\n\n  function validateEmail(email, fieldName) {\n    if (!email) return null;\n    let cleaned = email.trim().toLowerCase();\n    if (!/^[a-zA-Z0-9._%+\\-]+@[a-zA-Z0-9.\\-]+\\.[a-zA-Z]{2,}$/.test(cleaned)) {\n      flags.push(`${fieldName}_invalid_format`); return null;\n    }\n    const junkPatterns = [/^noreply@/, /^no-reply@/, /^donotreply@/, /^test@/, /^admin@example\\./, /^sample@/, /^fake@/, /^placeholder@/, /^null@/, /^none@/, /^unknown@/, /^abuse@/, /^postmaster@/, /^mailer-daemon@/];\n    if (junkPatterns.some(p => p.test(cleaned))) { flags.push(`${fieldName}_junk`); return null; }\n    const rolePatterns = [/^info@/, /^contact@/, /^hello@/, /^support@/, /^sales@/, /^office@/, /^billing@/, /^reception@/, /^frontdesk@/, /^front\\.desk@/, /^appointments@/, /^booking@/, /^bookings@/, /^schedule@/, /^scheduling@/, /^inquiries@/, /^inquiry@/, /^general@/, /^team@/, /^staff@/];\n    if (rolePatterns.some(p => p.test(cleaned))) flags.push(`${fieldName}_role_based_kept`);\n    const junkDomains = ['example.com', 'example.org', 'test.com', 'localhost', 'mailinator.com', 'guerrillamail.com', 'tempmail.com', 'yopmail.com'];\n    const domain = cleaned.split('@')[1];\n    if (junkDomains.includes(domain)) { flags.push(`${fieldName}_junk_domain`); return null; }\n    const localPart = cleaned.split('@')[0];\n    if (/^\\d+$/.test(localPart)) { flags.push(`${fieldName}_numeric_local`); return null; }\n    return cleaned;\n  }\n\n  function validatePhone(phone, fieldName) {\n    if (!phone) return null;\n    if (typeof phone === 'object') phone = phone.sanitized_number || phone.raw_number || phone.number || '';\n    let cleaned = phone.toString().trim().replace(/[^\\d]/g, '');\n    if (!cleaned || cleaned.length === 0) return null;\n    if (cleaned.length === 11 && cleaned.startsWith('1')) { /* ok */ }\n    else if (cleaned.length === 10) cleaned = '1' + cleaned;\n    else if (cleaned.length < 10) { flags.push(`${fieldName}_too_short`); return null; }\n    else if (cleaned.length > 11 && cleaned.length <= 15) {\n      if (cleaned.startsWith('1')) return null;\n      return '+' + cleaned;\n    }\n    else if (cleaned.length > 15) return null;\n    const areaCode = cleaned.substring(1, 4);\n    if (areaCode.startsWith('0') || areaCode.startsWith('1')) return null;\n    return '+' + cleaned;\n  }\n\n  function cleanName(name, fieldName) {\n    if (!name) return null;\n    let cleaned = name.trim().replace(/\\*+$/, '').trim();\n    if (cleaned.length <= 1) return null;\n    if (/^\\d+$/.test(cleaned) || /\\d/.test(cleaned)) return null;\n    const junkNames = ['unknown', 'n/a', 'na', 'none', 'null', 'test', 'owner', 'manager', 'admin', 'info', 'contact'];\n    if (junkNames.includes(cleaned.toLowerCase())) return null;\n    const credentials = ['lmt', 'cmt', 'rmt', 'lmbt', 'lmp', 'bctmb', 'nctmb', 'nctm', 'cpt', 'cst', 'mld', 'nmt', 'amt', 'abmp'];\n    if (credentials.includes(cleaned.toLowerCase())) return null;\n    if (cleaned === cleaned.toUpperCase() || cleaned === cleaned.toLowerCase()) {\n      cleaned = cleaned.charAt(0).toUpperCase() + cleaned.slice(1).toLowerCase();\n    }\n    return cleaned;\n  }\n\n  contact.email_business = validateEmail(contact.email_business, 'email_business');\n  contact.email_personal = validateEmail(contact.email_personal, 'email_personal');\n  contact.phone_direct = validatePhone(contact.phone_direct, 'phone_direct');\n  contact.first_name = cleanName(contact.first_name, 'first_name');\n  contact.last_name = cleanName(contact.last_name, 'last_name');\n  if (!contact.first_name) flags.push('contact_has_no_valid_first_name');\n\n  if (contact.linkedin_url) {\n    if (!/linkedin\\.com\\/in\\//i.test(contact.linkedin_url)) contact.linkedin_url = null;\n    else if (!contact.linkedin_url.startsWith('http')) contact.linkedin_url = 'https://' + contact.linkedin_url;\n  }\n\n  if (contact.location) {\n    contact.location = contact.location.trim();\n    if (!contact.location || contact.location === ',' || contact.location.length < 2) contact.location = null;\n  }\n\n  return { contact, flags, hasValidContact: !!(contact.first_name) };\n}\n\n// ═══ APOLLO ROLE SCORING ═══\n\nconst ownerKeywords = ['owner', 'founder', 'ceo', 'proprietor', 'principal', 'co-founder'];\nconst managerKeywords = ['manager', 'director', 'general manager', 'gm', 'head'];\nconst practitionerKeywords = ['massage', 'therapist', 'lmt', 'cmt', 'rmt', 'bodywork', 'esthetician'];\n\n// ═══ FETCH DATA FROM SUPABASE ═══\n\n// 1. Fetch enriched companies — batch mode (by IDs) or legacy mode (by metro)\nlet companyQueryParams;\nif (companyIds && companyIds.length > 0) {\n  companyQueryParams = `id=in.(${companyIds.join(',')})`;\n} else {\n  companyQueryParams = `enrichment_status=in.(partially_enriched,fully_enriched)&discovery_metro=eq.${encodeURIComponent(metro)}`;\n}\n\nconst companies = await this.helpers.httpRequest({\n  method: 'GET',\n  url: `${supabaseUrl}/rest/v1/companies?${companyQueryParams}&order=lead_score.desc,discovered_at.asc&limit=1000&select=id,name,phone,domain,address,city,state,country,google_place_id,category,estimated_size,has_website,google_review_count,google_rating`,\n  headers: sbHeaders,\n  json: true\n});\n\nif (!Array.isArray(companies) || companies.length === 0) {\n  console.log('No enriched companies found for metro: ' + metro);\n  return [{ json: { step: 'find_contacts', processed: 0, message: 'No companies to find contacts for', metro, company_ids: companyIds } }];\n}\n\n// 2. Fetch existing contacts (for dedup) — only company_id needed\nconst existingContacts = await this.helpers.httpRequest({\n  method: 'GET',\n  url: `${supabaseUrl}/rest/v1/contacts?select=company_id`,\n  headers: sbHeaders,\n  json: true\n});\n\nconst existingSet = new Set();\nif (Array.isArray(existingContacts)) {\n  for (const c of existingContacts) {\n    if (c.company_id) existingSet.add(c.company_id);\n  }\n}\n\n// 3. Filter to companies without contacts\nconst needsContacts = companies.filter(c => c.id && !existingSet.has(c.id));\n\nconsole.log(`Find Contacts: ${companies.length} companies total, ${existingSet.size} already have contacts, ${needsContacts.length} need people discovery for ${metro}`);\n\nif (needsContacts.length === 0) {\n  return [{ json: { step: 'find_contacts', processed: 0, message: 'All companies already have contacts', metro, company_ids: companyIds } }];\n}\n\n// ═══ STATS ═══\nconst stats = {\n  processed: 0, soloDetected: 0, soloWithName: 0,\n  apolloSearched: 0, apolloFound: 0, apolloEnriched: 0,\n  websiteScraped: 0, websiteFoundName: 0,\n  noDomainFallback: 0, noDomainFoundName: 0,\n  contactsInserted: 0, validationIssues: 0, errors: 0\n};\n\n// ═══ MAIN LOOP ═══\n\nlet apolloBatchCount = 0;\n\nfor (const company of needsContacts) {\n  try {\n    let contact = null;\n    let sourceMethod = 'none';\n\n    // ── 1. Solo practitioner check ──\n    const soloResult = checkSoloPractitioner(company);\n    if (soloResult.isSolo) {\n      stats.soloDetected++;\n      if (soloResult.firstName) {\n        stats.soloWithName++;\n        contact = {\n          company_id: company.id, first_name: soloResult.firstName, last_name: soloResult.lastName,\n          role: 'owner', is_owner: true, email_business: null, email_personal: null,\n          phone_direct: null, linkedin_url: null,\n          location: [company.city, company.state].filter(Boolean).join(', ') || null,\n          cultural_affinity: null, source: 'solo_detection'\n        };\n        sourceMethod = 'solo_detection';\n      }\n    }\n\n    // ── 2. Apollo search (if not solo, has domain, enabled) ──\n    if (!soloResult.isSolo && company.domain && !SKIP_APOLLO) {\n      try {\n        // Rate limiting: 3 per batch, 2s delay between batches\n        apolloBatchCount++;\n        if (apolloBatchCount > 3) {\n          await delay(2000);\n          apolloBatchCount = 1;\n        }\n\n        const apolloResp = await this.helpers.httpRequest({\n          method: 'POST',\n          url: 'https://api.apollo.io/api/v1/mixed_people/api_search',\n          headers: {\n            'Content-Type': 'application/json', 'Cache-Control': 'no-cache',\n            'X-Api-Key': apolloApiKey\n          },\n          body: {\n            q_organization_domains: company.domain,\n            person_titles: ['owner', 'founder', 'ceo', 'proprietor', 'director', 'manager', 'massage therapist', 'licensed massage therapist'],\n            per_page: 5\n          },\n          json: true\n        });\n\n        const people = apolloResp.people || [];\n        stats.apolloSearched++;\n\n        if (people.length > 0) {\n          stats.apolloFound++;\n\n          // Score people by role relevance\n          let bestPerson = null, bestScore = -1;\n          for (const person of people) {\n            const title = (person.title || '').toLowerCase();\n            let score = 0;\n            if (ownerKeywords.some(k => title.includes(k))) score = 10;\n            else if (managerKeywords.some(k => title.includes(k))) score = 5;\n            else if (practitionerKeywords.some(k => title.includes(k))) score = 3;\n            else score = 1;\n            if (person.has_email === true || person.has_email === 'true') score += 1;\n            if (score > bestScore) { bestScore = score; bestPerson = person; }\n          }\n\n          // Enrich if enabled\n          if (APOLLO_ENRICH_ENABLED && bestPerson.id) {\n            try {\n              const enrichResp = await this.helpers.httpRequest({\n                method: 'POST',\n                url: 'https://api.apollo.io/api/v1/people/match',\n                headers: {\n                  'Content-Type': 'application/json', 'Cache-Control': 'no-cache',\n                  'X-Api-Key': apolloApiKey\n                },\n                body: { id: bestPerson.id, reveal_personal_emails: true, reveal_phone_number: false },\n                json: true\n              });\n\n              const person = enrichResp.person || enrichResp.match || enrichResp;\n              if (person && person.first_name) {\n                const title = (person.title || '').toLowerCase();\n                let role = 'unknown', isOwner = false;\n                if (['owner','founder','ceo','proprietor','principal','co-founder'].some(k => title.includes(k))) { role = 'owner'; isOwner = true; }\n                else if (['manager','director','gm','general manager'].some(k => title.includes(k))) role = 'manager';\n                else if (['massage','therapist','lmt','cmt','rmt','esthetician'].some(k => title.includes(k))) role = 'practitioner';\n\n                let phoneNumber = null;\n                if (person.phone_numbers && person.phone_numbers.length > 0) {\n                  phoneNumber = person.phone_numbers[0].sanitized_number || person.phone_numbers[0].raw_number || null;\n                }\n\n                contact = {\n                  company_id: company.id, first_name: person.first_name || null,\n                  last_name: person.last_name || null, role, is_owner: isOwner,\n                  email_business: person.email || null,\n                  email_personal: (person.personal_emails && person.personal_emails[0]) || null,\n                  phone_direct: phoneNumber, linkedin_url: person.linkedin_url || null,\n                  location: [person.city, person.state].filter(Boolean).join(', ') || [company.city, company.state].filter(Boolean).join(', ') || null,\n                  cultural_affinity: null, source: 'apollo'\n                };\n                sourceMethod = 'apollo_enriched';\n                stats.apolloEnriched++;\n              } else {\n                // Enrichment returned no usable data — use search-only\n                contact = {\n                  company_id: company.id, first_name: bestPerson.first_name || null,\n                  last_name: null, role: (bestPerson.title || '').toLowerCase().includes('owner') ? 'owner' : 'unknown',\n                  is_owner: (bestPerson.title || '').toLowerCase().includes('owner'),\n                  email_business: null, email_personal: null, phone_direct: null, linkedin_url: null,\n                  location: [company.city, company.state].filter(Boolean).join(', ') || null,\n                  cultural_affinity: null, source: 'apollo'\n                };\n                sourceMethod = 'apollo_search_only';\n                stats.apolloEnriched++;\n              }\n            } catch(e) {\n              // Enrich failed — use search-only data\n              contact = {\n                company_id: company.id, first_name: bestPerson.first_name || null,\n                last_name: null, role: (bestPerson.title || '').toLowerCase().includes('owner') ? 'owner' : 'unknown',\n                is_owner: (bestPerson.title || '').toLowerCase().includes('owner'),\n                email_business: null, email_personal: null, phone_direct: null, linkedin_url: null,\n                location: [company.city, company.state].filter(Boolean).join(', ') || null,\n                cultural_affinity: null, source: 'apollo'\n              };\n              sourceMethod = 'apollo_search_only';\n              stats.apolloEnriched++;\n            }\n          } else {\n            // Enrichment disabled — use search-only\n            contact = {\n              company_id: company.id, first_name: bestPerson.first_name || null,\n              last_name: null, role: (bestPerson.title || '').toLowerCase().includes('owner') ? 'owner' : 'unknown',\n              is_owner: (bestPerson.title || '').toLowerCase().includes('owner'),\n              email_business: null, email_personal: null, phone_direct: null, linkedin_url: null,\n              location: [company.city, company.state].filter(Boolean).join(', ') || null,\n              cultural_affinity: null, source: 'apollo'\n            };\n            sourceMethod = 'apollo_search_only';\n            stats.apolloEnriched++;\n          }\n        } else {\n          // Apollo found nobody — try about page\n          if (company.domain && !SKIP_WEBSITE_SCRAPE) {\n            const additionalPaths = ['/about', '/about-us', '/about-me', '/our-team', '/team', '/our-story'];\n            let nameResult = null;\n            let usedPath = '';\n\n            for (const path of additionalPaths) {\n              try {\n                const resp = await this.helpers.httpRequest({\n                  method: 'GET',\n                  url: `https://${company.domain}${path}`,\n                  headers: { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36' },\n                  returnFullResponse: true, timeout: 10000, json: false,\n                });\n                const html = resp.body || '';\n                if (typeof html === 'string' && html.length > 500) {\n                  const found = extractNameFromHtml(html);\n                  if (found) { nameResult = found; usedPath = path; break; }\n                }\n              } catch(e) { /* Path doesn't exist or timed out */ }\n            }\n\n            stats.websiteScraped++;\n            if (nameResult) {\n              stats.websiteFoundName++;\n              contact = {\n                company_id: company.id, first_name: nameResult.firstName, last_name: nameResult.lastName,\n                role: 'owner', is_owner: true, email_business: null, email_personal: null,\n                phone_direct: null, linkedin_url: null,\n                location: [company.city, company.state].filter(Boolean).join(', ') || null,\n                cultural_affinity: null, source: 'website'\n              };\n              sourceMethod = 'website_scrape_' + usedPath.replace('/', '');\n            }\n          }\n        }\n      } catch(e) {\n        console.log(`Apollo error for ${company.name} (${company.domain}): ${e.message}`);\n      }\n    }\n\n    // ── 3. No domain fallback — extract name from business name ──\n    if (!contact && !company.domain) {\n      stats.noDomainFallback++;\n      const nameResult = extractNameFromBusinessName(company);\n      if (nameResult) {\n        stats.noDomainFoundName++;\n        contact = {\n          company_id: company.id, first_name: nameResult.firstName, last_name: nameResult.lastName,\n          role: 'owner', is_owner: true, email_business: null, email_personal: null,\n          phone_direct: null, linkedin_url: null,\n          location: [company.city, company.state].filter(Boolean).join(', ') || null,\n          cultural_affinity: null, source: 'manual'\n        };\n        sourceMethod = 'no_domain_name_extraction';\n      }\n    }\n\n    // ── 4. Validate & clean contact ──\n    if (contact) {\n      const { contact: cleanedContact, flags, hasValidContact } = validateAndCleanContact(contact);\n      if (flags.length > 0) stats.validationIssues++;\n\n      // ── 5. Insert to Supabase (with dedup) ──\n      if (hasValidContact) {\n        try {\n          await this.helpers.httpRequest({\n            method: 'POST',\n            url: `${supabaseUrl}/rest/v1/contacts?on_conflict=company_id,first_name,last_name,source`,\n            headers: { ...sbHeaders, 'Content-Type': 'application/json', 'Prefer': 'resolution=ignore-duplicates,return=minimal' },\n            body: cleanedContact,\n            json: true\n          });\n          stats.contactsInserted++;\n        } catch(e) {\n          console.log(`Contact insert error for ${company.name}: ${e.message}`);\n        }\n      }\n    }\n\n    stats.processed++;\n    if (stats.processed % 25 === 0) {\n      console.log(`  Progress: ${stats.processed}/${needsContacts.length} companies checked for contacts`);\n    }\n  } catch(e) {\n    console.log(`FATAL error finding contacts for ${company.name}: ${e.message}`);\n    stats.errors++;\n  }\n}\n\n// ═══ SUMMARY ═══\nconst summary = {\n  step: 'find_contacts',\n  metro,\n  run_completed_at: new Date().toISOString(),\n  companies_processed: stats.processed,\n  solo_detected: stats.soloDetected,\n  solo_with_name: stats.soloWithName,\n  apollo_searched: stats.apolloSearched,\n  apollo_found_people: stats.apolloFound,\n  apollo_contacts_created: stats.apolloEnriched,\n  website_scraped: stats.websiteScraped,\n  website_names_found: stats.websiteFoundName,\n  no_domain_fallback: stats.noDomainFallback,\n  no_domain_names_found: stats.noDomainFoundName,\n  contacts_inserted: stats.contactsInserted,\n  validation_issues: stats.validationIssues,\n  fatal_errors: stats.errors,\n  message: `Found contacts for ${stats.contactsInserted} of ${stats.processed} companies. Sources: ${stats.soloWithName} solo, ${stats.apolloEnriched} Apollo, ${stats.websiteFoundName} website, ${stats.noDomainFoundName} name extraction. Validation issues: ${stats.validationIssues}.`\n};\n\nconsole.log('=== STEP 3a: FIND CONTACTS SUMMARY ===');\nconsole.log(JSON.stringify(summary, null, 2));\n\n// Pass metro + company_ids through for the next node in the chain\nreturn [{ json: { ...summary, metro, company_ids: companyIds } }];"
      }
    },
    {
      "id": "sw-enrich-contacts-0001",
      "name": "Enrich Contacts",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2000,
        192
      ],
      "parameters": {
        "jsCode": "// Enrich Contacts — Modified to include inline Supabase fetch/merge\n// Mode: runOnceForAllItems\n// Input: { metro, company_ids } from upstream Find Contacts, OR main workflow trigger\n// Output: enrichment results → Mark Fully Enriched (sub-workflow) or Run Summary4 (legacy)\n//\n// Previously depended on: Step 4 Config, Fetch Contacts, Fetch Companies1,\n// Filter & Merge Contacts, Collapse to Single. Now handles all of that inline.\n\nconst inputData = $input.first().json;\n// n8n Webhook v2 wraps POST body under .body; unwrap defensively\nconst payload = inputData.body || inputData;\nconst metro = payload.metro || payload.metro_name;\nconst companyIds = payload.company_ids || null;\nif (!metro) {\n  throw new Error('Enrich Contacts: missing metro in input. Expected metro or metro_name field.');\n}\nconst supabaseUrl = $env.SUPABASE_URL;\nconst supabaseKey = $env.SUPABASE_SERVICE_KEY;\nconst sbHeaders = { 'apikey': supabaseKey, 'Authorization': 'Bearer ' + supabaseKey };\n\n// ═══ CONFIG (previously in Step 4 Config Set node) ═══\nconst config = {\n  skip_hunter: 'false',\n  skip_snovio: 'true',\n  skip_hunter_verifier: 'false',\n  skip_namsor: 'false',\n  skip_phone_verifier: 'false',\n  batch_size: '1000',\n  batch_offset: '0'\n};\n\n// ═══ INLINE FETCH: Contacts needing enrichment ═══\n// Batch mode: filter contacts to those belonging to batch companies\n// Legacy mode: fetch all contacts globally (metro filtering happens downstream)\nlet contactsUrl;\nif (companyIds && companyIds.length > 0) {\n  contactsUrl = `${supabaseUrl}/rest/v1/contacts?company_id=in.(${companyIds.join(',')})&select=id,company_id,first_name,last_name,role,is_owner,email_business,email_personal,phone_direct,linkedin_url,cultural_affinity,source,email_status,phone_status,phone_line_type,phone_carrier&or=(email_status.is.null,email_status.eq.unverified,and(phone_direct.not.is.null,phone_status.is.null))&order=created_at.asc`;\n} else {\n  contactsUrl = `${supabaseUrl}/rest/v1/contacts?select=id,company_id,first_name,last_name,role,is_owner,email_business,email_personal,phone_direct,linkedin_url,cultural_affinity,source,email_status,phone_status,phone_line_type,phone_carrier&or=(email_status.is.null,email_status.eq.unverified,and(phone_direct.not.is.null,phone_status.is.null))&order=created_at.asc&limit=${config.batch_size}&offset=${config.batch_offset}`;\n}\n\nconst rawContacts = await this.helpers.httpRequest({\n  method: 'GET',\n  url: contactsUrl,\n  headers: sbHeaders,\n  json: true\n});\n\n// ═══ INLINE FETCH: Companies for this metro/batch ═══\nlet companiesUrl;\nif (companyIds && companyIds.length > 0) {\n  companiesUrl = `${supabaseUrl}/rest/v1/companies?id=in.(${companyIds.join(',')})&select=id,name,phone,domain,email,email_status,phone_status,phone_line_type,city,state`;\n} else {\n  companiesUrl = `${supabaseUrl}/rest/v1/companies?select=id,name,phone,domain,email,email_status,phone_status,phone_line_type,city,state&enrichment_status=in.(partially_enriched,fully_enriched)&discovery_metro=eq.${encodeURIComponent(metro)}`;\n}\n\nconst rawCompanies = await this.helpers.httpRequest({\n  method: 'GET',\n  url: companiesUrl,\n  headers: sbHeaders,\n  json: true\n});\n\n// ═══ INLINE: Filter & Merge Contacts ═══\n// Deduplicate contacts by id\nconst seenIds = new Set();\nlet uniqueContacts = [];\nif (Array.isArray(rawContacts)) {\n  for (const c of rawContacts) {\n    if (c.id && !seenIds.has(c.id)) {\n      seenIds.add(c.id);\n      uniqueContacts.push(c);\n    }\n  }\n}\n\n// Build company lookup map (metro-scoped)\nconst companyMap = {};\nif (Array.isArray(rawCompanies)) {\n  for (const co of rawCompanies) {\n    if (co.id) companyMap[co.id] = co;\n  }\n}\n\n// Filter contacts that need enrichment\nconst needsEnrichment = uniqueContacts.filter(c => {\n  const missingEmail = !c.email_business;\n  const missingCulturalAffinity = !c.cultural_affinity;\n  const missingPhone = !c.phone_direct;\n  const missingLinkedin = !c.linkedin_url;\n  const verifiedStatuses = ['verified', 'invalid', 'risky', 'accept_all'];\n  const emailNeedsVerification = c.email_business && !verifiedStatuses.includes(c.email_status);\n  const phoneNeedsVerification = c.phone_direct && !c.phone_status;\n  return missingEmail || missingCulturalAffinity || missingPhone || missingLinkedin || emailNeedsVerification || phoneNeedsVerification;\n});\n\n// Metro filter: only keep contacts whose company is in the metro-scoped companyMap\nconst metroFiltered = needsEnrichment.filter(c => companyMap[c.company_id]);\nconst crossMetroSkipped = needsEnrichment.length - metroFiltered.length;\n\nconsole.log(`Contacts: ${uniqueContacts.length} unique, ${needsEnrichment.length} need enrichment, ${crossMetroSkipped} skipped (other metro), ${metroFiltered.length} in current metro`);\n\nif (metroFiltered.length === 0) {\n  return [{ json: { _empty: true, _count: 0, _message: 'All contacts are already enriched or belong to other metros', metro, company_ids: companyIds } }];\n}\n\n// Merge company data into each contact\nconst contacts = metroFiltered.map(c => {\n  const company = companyMap[c.company_id];\n  return {\n    json: {\n      ...c,\n      _company_name: company.name || null,\n      _company_domain: company.domain || null,\n      _company_phone: company.phone || null,\n      _company_email: company.email || null,\n      _company_email_status: company.email_status || null,\n      _company_phone_status: company.phone_status || null,\n      _company_phone_line_type: company.phone_line_type || null,\n      _company_city: company.city || null,\n      _company_state: company.state || null\n    }\n  };\n});\n\n// ═══ ENRICHMENT PIPELINE (unchanged from original Enrich Contacts node) ═══\n\nconst results = [];\n\n// Helper: delay between API calls for rate limiting\nconst delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));\n\n// Dedup guard: track companies that already had email set/verified this execution\n// Batch mode: use local object (parallel sub-workflow executions don't share state safely)\n// Legacy mode: use static data with BUG-F019 cleanup\nlet companyEmailsSet;\nif (companyIds && companyIds.length > 0) {\n  // Batch mode: local dedup — each sub-workflow execution is independent\n  companyEmailsSet = {};\n} else {\n  // Legacy mode: static data dedup (ADR-015)\n  const staticData = $getWorkflowStaticData('global');\n  if (!staticData._companyEmailsSet) staticData._companyEmailsSet = {};\n  companyEmailsSet = staticData._companyEmailsSet;\n  // BUG-F019 FIX: Clear ALL stale keys from previous executions.\n  for (const key of Object.keys(companyEmailsSet)) {\n    delete companyEmailsSet[key];\n  }\n}\n\n// Phone validation (from Prepare Contact Update)\nfunction validatePhone(phone) {\n  if (!phone) return null;\n  if (typeof phone === 'object' && phone !== null) {\n    phone = phone.sanitized_number || phone.raw_number || phone.number || '';\n  }\n  let cleaned = phone.toString().trim().replace(/[^\\d]/g, '');\n  if (!cleaned || cleaned.length === 0) return null;\n  if (cleaned.length === 11 && cleaned.startsWith('1')) { /* ok */ }\n  else if (cleaned.length === 10) { cleaned = '1' + cleaned; }\n  else if (cleaned.length < 10) { return null; }\n  else if (cleaned.length > 11 && cleaned.length <= 15) {\n    if (cleaned.startsWith('1')) return null;\n    return '+' + cleaned;\n  }\n  else if (cleaned.length > 15) { return null; }\n  const areaCode = cleaned.substring(1, 4);\n  if (areaCode.startsWith('0') || areaCode.startsWith('1')) return null;\n  return '+' + cleaned;\n}\n\n// Role-based email detection\nconst rolePatterns = [\n  /^info@/i, /^contact@/i, /^hello@/i, /^support@/i, /^sales@/i,\n  /^office@/i, /^billing@/i, /^reception@/i, /^frontdesk@/i, /^front\\.desk@/i,\n  /^appointments@/i, /^booking@/i, /^bookings@/i, /^schedule@/i, /^scheduling@/i,\n  /^inquiries@/i, /^inquiry@/i, /^general@/i, /^team@/i, /^staff@/i\n];\n\nfunction isRoleBased(email) {\n  if (!email) return false;\n  return rolePatterns.some(p => p.test(email));\n}\n\nconst freeWebmailDomains = [\n  'gmail.com', 'yahoo.com', 'outlook.com', 'hotmail.com', 'aol.com',\n  'icloud.com', 'me.com', 'mac.com', 'live.com', 'msn.com',\n  'protonmail.com', 'proton.me', 'zoho.com', 'yandex.com',\n  'mail.com', 'gmx.com', 'fastmail.com', 'tutanota.com'\n];\n\nfunction isFreeWebmail(email) {\n  if (!email) return false;\n  const domain = email.split('@')[1];\n  return freeWebmailDomains.includes(domain);\n}\n\n// Helper: verify an email via Hunter Verifier API\nasync function verifyEmail(email) {\n  try {\n    const verifyUrl = `https://api.hunter.io/v2/email-verifier?email=${encodeURIComponent(email)}&api_key=${$env.HUNTER_API_KEY}`;\n    const verifyResp = await this.helpers.httpRequest({ method: 'GET', url: verifyUrl, headers: { 'Accept': 'application/json' }, json: true });\n    const vBody = verifyResp.data || verifyResp;\n    if (vBody && vBody.status) {\n      let status;\n      switch (vBody.status) {\n        case 'valid': status = 'verified'; break;\n        case 'invalid': status = 'invalid'; break;\n        case 'accept_all': status = 'accept_all'; break;\n        case 'disposable': status = 'invalid'; break;\n        case 'webmail': status = 'verified'; break;\n        default: status = 'risky'; break;\n      }\n      return { status, score: vBody.score || null, verified_at: new Date().toISOString() };\n    }\n  } catch(e) {\n    console.log(`Verifier error for ${email}: ${e.message}`);\n  }\n  return null;\n}\n\n// Helper: verify a phone number via Telnyx Number Lookup API\nasync function verifyPhone(phoneNumber) {\n  try {\n    const resp = await this.helpers.httpRequest({\n      method: 'GET',\n      url: `https://api.telnyx.com/v2/number_lookup/${encodeURIComponent(phoneNumber)}?type=carrier`,\n      headers: {\n        'Authorization': `Bearer ${$env.TELNYX_API_KEY}`,\n        'Accept': 'application/json'\n      },\n      json: true\n    });\n    const data = resp.data || resp;\n    if (data && data.valid === false) {\n      return { phone_status: 'invalid', phone_line_type: null, phone_carrier: null };\n    }\n    let lineType = null;\n    const carrierType = (data.carrier && data.carrier.type) || null;\n    if (carrierType) {\n      const typeMap = { 'mobile': 'mobile', 'landline': 'landline', 'fixed line': 'landline', 'voip': 'voip', 'toll free': 'toll_free', 'toll_free': 'toll_free' };\n      lineType = typeMap[carrierType.toLowerCase()] || null;\n    }\n    const carrierName = (data.carrier && data.carrier.name) || null;\n    const phoneStatus = lineType === 'voip' ? 'voip' : 'valid';\n    return {\n      phone_status: phoneStatus,\n      phone_line_type: lineType,\n      phone_carrier: carrierName\n    };\n  } catch(e) {\n    if (e.statusCode === 404 || e.statusCode === 422) {\n      return { phone_status: 'invalid', phone_line_type: null, phone_carrier: null };\n    }\n    console.log(`Telnyx error for ${phoneNumber}: ${e.message} (status: ${e.statusCode || 'unknown'})`);\n    return { phone_status: null, phone_line_type: null, phone_carrier: null, _error: `${e.statusCode || 'unknown'}: ${e.message}` };\n  }\n}\n\nfor (const item of contacts) {\n  const contact = { ...item.json };\n\n  // Initialize enrichment fields\n  contact._hunter_email = null;\n  contact._hunter_score = 0;\n  contact._hunter_linkedin = null;\n  contact._hunter_phone = null;\n  contact._snovio_email = null;\n  contact._email_source = null;\n  contact._best_email = contact.email_business || null;\n  contact._best_phone = contact.phone_direct || contact._company_phone || null;\n  contact._best_linkedin = contact.linkedin_url || null;\n  contact._email_status = null;\n  contact._email_verified_at = null;\n  contact._verifier_score = null;\n  contact._cultural_affinity = contact.cultural_affinity || null;\n  contact._namsor_country = null;\n  contact._namsor_region = null;\n  contact._namsor_probability = null;\n  contact._company_email_routed = false;\n  contact._company_email_verified = false;\n  contact._phone_status = null;\n  contact._phone_line_type = null;\n  contact._phone_carrier = null;\n  contact._company_phone_verified = false;\n  contact._phone_error = null;\n\n  const needsEmail = !contact.email_business;\n  const hasDomainAndName = contact._company_domain && contact.first_name;\n  const verifiedStatuses = ['verified', 'invalid', 'risky', 'accept_all'];\n  const emailNeedsVerification = contact.email_business && !verifiedStatuses.includes(contact.email_status);\n\n  // EMAIL WATERFALL\n\n  if (needsEmail && hasDomainAndName) {\n    // --- HUNTER EMAIL FINDER ---\n    if (config.skip_hunter !== 'true') {\n      try {\n        const hunterUrl = `https://api.hunter.io/v2/email-finder?domain=${encodeURIComponent(contact._company_domain)}&first_name=${encodeURIComponent(contact.first_name)}&last_name=${encodeURIComponent(contact.last_name || '')}&api_key=${$env.HUNTER_API_KEY}`;\n        const hunterResp = await this.helpers.httpRequest({ method: 'GET', url: hunterUrl, headers: { 'Accept': 'application/json' }, json: true });\n        const hData = hunterResp.data || hunterResp;\n        if (hData && hData.email && (hData.score === undefined || hData.score >= 50)) {\n          contact._hunter_email = hData.email;\n          contact._hunter_score = hData.score || 0;\n          contact._hunter_linkedin = hData.linkedin_url || null;\n          contact._hunter_phone = hData.phone_number || null;\n          contact._email_source = 'hunter';\n        }\n        await delay(200);\n      } catch(e) {\n        console.log(`Hunter error for ${contact.first_name}: ${e.message}`);\n      }\n    }\n\n    // --- SNOV.IO EMAIL FINDER (fallback) ---\n    if (!contact._hunter_email && config.skip_snovio !== 'true') {\n      try {\n        const snovResp = await this.helpers.httpRequest({\n          method: 'POST',\n          url: 'https://api.snov.io/v1/get-emails-from-names',\n          headers: { 'Content-Type': 'application/json' },\n          body: {\n            firstName: contact.first_name,\n            lastName: contact.last_name || '',\n            domain: contact._company_domain\n          },\n          json: true\n        });\n        const emails = snovResp.emails || snovResp.data?.emails || [];\n        if (Array.isArray(emails) && emails.length > 0) {\n          const valid = emails.find(e => e.emailStatus === 'valid' || e.status === 'valid') || emails[0];\n          contact._snovio_email = valid.email || valid.value || null;\n          if (contact._snovio_email) contact._email_source = 'snovio';\n        }\n        await delay(500);\n      } catch(e) {\n        console.log(`Snov.io error for ${contact.first_name}: ${e.message}`);\n      }\n    }\n\n    contact._best_email = contact._hunter_email || contact._snovio_email || null;\n    contact._best_phone = contact.phone_direct || contact._hunter_phone || contact._company_phone || null;\n    contact._best_linkedin = contact.linkedin_url || contact._hunter_linkedin || null;\n  } else if (contact.email_business) {\n    contact._best_email = contact.email_business;\n    contact._email_source = 'existing';\n  }\n\n  // COMPANY EMAIL ROUTING\n  if (contact._best_email && isRoleBased(contact._best_email) && !isFreeWebmail(contact._best_email)) {\n    const companyId = contact.company_id;\n    const companyHasEmail = !!(contact._company_email);\n\n    if (!companyHasEmail && !companyEmailsSet[companyId]) {\n      contact._routed_company_email = contact._best_email;\n      contact._company_email_routed = true;\n      companyEmailsSet[companyId] = contact._best_email;\n      console.log(`Routed role-based email ${contact._best_email} to company ${contact._company_name || companyId}`);\n    }\n\n    if (contact.email_personal) {\n      contact._best_email = contact.email_personal;\n      contact._email_source = 'personal_promoted';\n      console.log(`Promoted personal email ${contact.email_personal} for ${contact.first_name} (role-based went to company)`);\n    }\n  }\n\n  // EMAIL VERIFICATION (contact email)\n  if (contact._best_email && config.skip_hunter_verifier !== 'true') {\n    const shouldVerify = !contact.email_business || emailNeedsVerification || contact._email_source === 'hunter' || contact._email_source === 'snovio' || contact._email_source === 'personal_promoted';\n    if (shouldVerify) {\n      const vResult = await verifyEmail.call(this, contact._best_email);\n      if (vResult) {\n        contact._email_status = vResult.status;\n        contact._email_verified_at = vResult.verified_at;\n        contact._verifier_score = vResult.score;\n      }\n      await delay(700);\n    }\n  } else if (contact._best_email) {\n    contact._email_status = 'unverified';\n  }\n\n  // COMPANY EMAIL VERIFICATION\n  const companyEmailToVerify = contact._routed_company_email || contact._company_email;\n  const companyEmailNeedsVerification = companyEmailToVerify && !contact._company_email_status;\n  const companyId = contact.company_id;\n\n  if (companyEmailNeedsVerification && config.skip_hunter_verifier !== 'true' && !companyEmailsSet[companyId + '_verified']) {\n    const vResult = await verifyEmail.call(this, companyEmailToVerify);\n    let companyPatch = {};\n\n    if (contact._routed_company_email) {\n      companyPatch.email = contact._routed_company_email;\n    }\n\n    if (vResult) {\n      companyPatch.email_status = vResult.status;\n      contact._company_email_verified = true;\n      console.log(`Verified company email ${companyEmailToVerify}: ${vResult.status}`);\n    }\n\n    if (Object.keys(companyPatch).length > 0) {\n      try {\n        await this.helpers.httpRequest({\n          method: 'PATCH',\n          url: `${supabaseUrl}/rest/v1/companies?id=eq.${companyId}`,\n          headers: {\n            'apikey': supabaseKey,\n            'Authorization': `Bearer ${supabaseKey}`,\n            'Content-Type': 'application/json',\n            'Prefer': 'return=minimal'\n          },\n          body: companyPatch,\n          json: true\n        });\n        console.log(`PATCHed company ${contact._company_name || companyId}: ${JSON.stringify(companyPatch)}`);\n      } catch(e) {\n        console.log(`Company PATCH error for ${companyId}: ${e.message}`);\n      }\n    }\n\n    companyEmailsSet[companyId + '_verified'] = true;\n    await delay(700);\n  } else if (contact._routed_company_email && !companyEmailsSet[companyId + '_verified']) {\n    try {\n      await this.helpers.httpRequest({\n        method: 'PATCH',\n        url: `${supabaseUrl}/rest/v1/companies?id=eq.${companyId}`,\n        headers: {\n          'apikey': supabaseKey,\n          'Authorization': `Bearer ${supabaseKey}`,\n          'Content-Type': 'application/json',\n          'Prefer': 'return=minimal'\n        },\n        body: { email: contact._routed_company_email },\n        json: true\n      });\n      console.log(`PATCHed company email (unverified) ${contact._company_name || companyId}: ${contact._routed_company_email}`);\n    } catch(e) {\n      console.log(`Company PATCH error for ${companyId}: ${e.message}`);\n    }\n    companyEmailsSet[companyId + '_verified'] = true;\n    await delay(50);\n  }\n\n  // NAMSOR CULTURAL AFFINITY\n  if (!contact.cultural_affinity && contact.first_name && config.skip_namsor !== 'true') {\n    try {\n      const namsorUrl = `https://v2.namsor.com/NamSorAPIv2/api2/json/origin/${encodeURIComponent(contact.first_name)}/${encodeURIComponent(contact.last_name || 'Unknown')}`;\n      const namsorResp = await this.helpers.httpRequest({ method: 'GET', url: namsorUrl, headers: { 'X-API-KEY': $env.NAMSOR_API_KEY, 'Accept': 'application/json' }, json: true });\n      if (namsorResp && namsorResp.countryOrigin) {\n        const parts = [];\n        if (namsorResp.regionOrigin) parts.push(namsorResp.regionOrigin);\n        if (namsorResp.subRegionOrigin && namsorResp.subRegionOrigin !== namsorResp.regionOrigin) parts.push(namsorResp.subRegionOrigin);\n        if (namsorResp.countryOrigin) parts.push(namsorResp.countryOrigin);\n        contact._cultural_affinity = parts.join(' / ');\n        if (namsorResp.probabilityCalibrated && namsorResp.probabilityCalibrated < 0.3) {\n          contact._cultural_affinity += ' (low confidence)';\n        }\n        contact._namsor_country = namsorResp.countryOrigin;\n        contact._namsor_region = namsorResp.regionOrigin;\n        contact._namsor_probability = namsorResp.probabilityCalibrated;\n      }\n      await delay(100);\n    } catch(e) {\n      console.log(`NamSor error for ${contact.first_name}: ${e.message}`);\n    }\n  }\n\n  // PHONE VERIFICATION (Telnyx Number Lookup)\n  if (contact._best_phone && !contact.phone_status && config.skip_phone_verifier !== 'true') {\n    const phoneResult = await verifyPhone.call(this, contact._best_phone);\n    if (phoneResult) {\n      contact._phone_status = phoneResult.phone_status;\n      contact._phone_line_type = phoneResult.phone_line_type;\n      contact._phone_carrier = phoneResult.phone_carrier;\n      if (phoneResult._error) {\n        contact._phone_error = phoneResult._error;\n      } else {\n        console.log(`Phone verified ${contact._best_phone}: ${phoneResult.phone_status} (${phoneResult.phone_line_type || 'unknown type'}, ${phoneResult.phone_carrier || 'unknown carrier'})`);\n      }\n    }\n    await delay(100);\n  }\n\n  // COMPANY PHONE VERIFICATION (Telnyx)\n  if (contact._company_phone && !contact._company_phone_status && config.skip_phone_verifier !== 'true' && !companyEmailsSet[companyId + '_phone_verified']) {\n    const compPhoneResult = await verifyPhone.call(this, contact._company_phone);\n    if (compPhoneResult && !compPhoneResult._error) {\n      try {\n        await this.helpers.httpRequest({\n          method: 'PATCH',\n          url: `${supabaseUrl}/rest/v1/companies?id=eq.${companyId}`,\n          headers: {\n            'apikey': supabaseKey,\n            'Authorization': `Bearer ${supabaseKey}`,\n            'Content-Type': 'application/json',\n            'Prefer': 'return=minimal'\n          },\n          body: {\n            phone_status: compPhoneResult.phone_status,\n            phone_line_type: compPhoneResult.phone_line_type\n          },\n          json: true\n        });\n        contact._company_phone_verified = true;\n        console.log(`Company phone verified ${contact._company_phone}: ${compPhoneResult.phone_status} (${compPhoneResult.phone_line_type || 'unknown'})`);\n      } catch(e) {\n        console.log(`Company phone PATCH error for ${companyId}: ${e.message}`);\n      }\n    } else if (compPhoneResult && compPhoneResult._error) {\n      contact._phone_error = contact._phone_error || compPhoneResult._error;\n    }\n    companyEmailsSet[companyId + '_phone_verified'] = true;\n    await delay(100);\n  }\n\n  // BUILD UPDATE PAYLOAD\n  const update = {};\n  if (contact._best_email && !contact.email_business) {\n    update.email_business = contact._best_email;\n  }\n  if (contact._email_status && contact._email_status !== 'unverified') {\n    update.email_status = contact._email_status;\n    update.email_verified_at = contact._email_verified_at;\n    if (contact._email_status === 'invalid') {\n      update.email_business = null;\n    }\n  } else if (contact._best_email || contact.email_business) {\n    update.email_status = 'unverified';\n  }\n\n  const newPhone = validatePhone(contact._best_phone);\n  if (newPhone && !contact.phone_direct) update.phone_direct = newPhone;\n  if (contact._best_linkedin && !contact.linkedin_url) update.linkedin_url = contact._best_linkedin;\n  if (contact._cultural_affinity && !contact.cultural_affinity) update.cultural_affinity = contact._cultural_affinity;\n\n  // Phone verification fields\n  if (contact._phone_status) {\n    update.phone_status = contact._phone_status;\n    update.phone_verified_at = new Date().toISOString();\n    update.phone_line_type = contact._phone_line_type;\n    update.phone_carrier = contact._phone_carrier;\n    if (contact._phone_status === 'invalid' || contact._phone_status === 'disconnected') {\n      update.phone_direct = null;\n    }\n  }\n\n  contact._update_payload = Object.keys(update).length > 0 ? update : null;\n  contact._has_updates = Object.keys(update).length > 0;\n\n  // SUPABASE UPDATE (inline)\n  if (contact._has_updates) {\n    try {\n      await this.helpers.httpRequest({\n        method: 'PATCH',\n        url: `${supabaseUrl}/rest/v1/contacts?id=eq.${contact.id}`,\n        headers: {\n          'apikey': supabaseKey,\n          'Authorization': `Bearer ${supabaseKey}`,\n          'Content-Type': 'application/json',\n          'Prefer': 'return=minimal'\n        },\n        body: update,\n        json: true\n      });\n      console.log(`Updated ${contact.first_name} ${contact.last_name || ''}: ${JSON.stringify(update)}`);\n    } catch(e) {\n      console.log(`Supabase update error for ${contact.id}: ${e.message}`);\n      contact._update_error = e.message;\n    }\n    await delay(50);\n  }\n\n  results.push({\n    json: {\n      _contact_id: contact.id,\n      _company_id: contact.company_id,\n      _first_name: contact.first_name,\n      _last_name: contact.last_name,\n      _company_name: contact._company_name,\n      _update_payload: contact._update_payload,\n      _has_updates: contact._has_updates,\n      _email_source: contact._email_source,\n      _email_status: contact._email_status,\n      _verifier_score: contact._verifier_score,\n      _namsor_country: contact._namsor_country,\n      _namsor_probability: contact._namsor_probability,\n      _company_email_routed: contact._company_email_routed,\n      _company_email_verified: contact._company_email_verified,\n      _routed_company_email: contact._routed_company_email || null,\n      _phone_status: contact._phone_status,\n      _phone_line_type: contact._phone_line_type,\n      _phone_carrier: contact._phone_carrier,\n      _company_phone_verified: contact._company_phone_verified,\n      _phone_error: contact._phone_error,\n      _update_error: contact._update_error || null\n    }\n  });\n}\n\nif (results.length === 0) {\n  return [{ json: { _empty: true, _count: 0, metro, company_ids: companyIds } }];\n}\n\n// Inject metro + company_ids into the first result item so downstream nodes can access them\nif (results.length > 0) {\n  results[0].json.metro = metro;\n  results[0].json.company_ids = companyIds;\n}\n\nreturn results;"
      }
    },
    {
      "id": "sw-mark-enriched-0001",
      "name": "Mark Fully Enriched",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2500,
        192
      ],
      "parameters": {
        "jsCode": "// Mark Fully Enriched — Final node in sub-workflow batch enrichment chain\n// Mode: runOnceForAllItems\n// Input: results from Enrich Contacts (carries metro + company_ids)\n// Output: confirmation of status update\n//\n// PATCHes all companies in the batch to enrichment_status = 'fully_enriched'.\n\nconst inputData = $input.first().json;\nconst companyIds = inputData.company_ids || [];\nconst metro = inputData.metro || 'unknown';\n\nconst supabaseUrl = $env.SUPABASE_URL;\nconst supabaseKey = $env.SUPABASE_SERVICE_KEY;\n\nif (companyIds.length === 0) {\n  console.log('Mark Fully Enriched: no company IDs in input, skipping');\n  return [{ json: { step: 'mark_fully_enriched', metro, updated: 0 } }];\n}\n\nconsole.log(`Mark Fully Enriched: marking ${companyIds.length} companies as fully_enriched for ${metro}`);\n\ntry {\n  await this.helpers.httpRequest({\n    method: 'PATCH',\n    url: `${supabaseUrl}/rest/v1/companies?id=in.(${companyIds.join(',')})`,\n    headers: {\n      'apikey': supabaseKey,\n      'Authorization': 'Bearer ' + supabaseKey,\n      'Content-Type': 'application/json',\n      'Prefer': 'return=minimal'\n    },\n    body: { enrichment_status: 'fully_enriched' },\n    json: true\n  });\n  console.log(`  Successfully marked ${companyIds.length} companies as fully_enriched`);\n} catch(e) {\n  console.log(`  ERROR marking companies as fully_enriched: ${e.message}`);\n  return [{ json: { step: 'mark_fully_enriched', metro, updated: 0, error: e.message, company_ids: companyIds } }];\n}\n\nreturn [{ json: { step: 'mark_fully_enriched', metro, updated: companyIds.length, company_ids: companyIds } }];\n",
        "mode": "runOnceForAllItems"
      }
    },
    {
      "id": "a4-track-batch-0001",
      "name": "Track Batch Completion",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3000,
        192
      ],
      "parameters": {
        "jsCode": "// Track Batch Completion - Final node in sub-workflow (after Mark Fully Enriched)\n// Mode: runOnceForAllItems\n// Increments completed_batches atomically. If last batch, marks run as completed.\n// Skips if no run_id (legacy trigger).\n\nconst inputData = $input.first().json;\nconst companyIds = inputData.company_ids || [];\nconst metro = inputData.metro || 'unknown';\n\n// Read run_id from webhook body (sub-workflow receives it via POST from Batch Dispatcher)\nlet runId = null;\ntry {\n  const webhookData = $('Webhook').first().json;\n  const payload = webhookData.body || webhookData;\n  runId = payload.run_id || null;\n} catch(e) {\n  // Webhook reference failed - try from input chain\n  runId = inputData.run_id || null;\n}\n\nif (!runId) {\n  console.log('Track Batch Completion: no run_id, skipping (legacy trigger)');\n  return [{ json: { step: 'track_batch_completion', metro, skipped: true, reason: 'no_run_id' } }];\n}\n\nconst supabaseUrl = $env.SUPABASE_URL;\nconst supabaseKey = $env.SUPABASE_SERVICE_KEY;\nconst sbHeaders = {\n  'apikey': supabaseKey,\n  'Authorization': 'Bearer ' + supabaseKey,\n  'Content-Type': 'application/json'\n};\n\ntry {\n  // Atomically increment completed_batches\n  const result = await this.helpers.httpRequest({\n    method: 'POST',\n    url: `${supabaseUrl}/rest/v1/rpc/increment_completed_batches`,\n    headers: sbHeaders,\n    body: { p_run_id: runId },\n    json: true\n  });\n\n  console.log(`Track Batch Completion: ${metro} batch done - ${JSON.stringify(result)}`);\n\n  if (result && result.is_last_batch) {\n    console.log('Track Batch Completion: LAST BATCH - marking run as completed');\n\n    // Query totals for this metro\n    let totalDiscovered = 0;\n    let contactsFound = 0;\n    try {\n      const companies = await this.helpers.httpRequest({\n        method: 'GET',\n        url: `${supabaseUrl}/rest/v1/companies?discovery_metro=eq.${encodeURIComponent(metro)}&select=id`,\n        headers: { 'apikey': supabaseKey, 'Authorization': 'Bearer ' + supabaseKey },\n        json: true\n      });\n      totalDiscovered = Array.isArray(companies) ? companies.length : 0;\n\n      // Count contacts for companies in this metro\n      const companyIdsStr = (Array.isArray(companies) ? companies : []).map(c => c.id).join(',');\n      if (companyIdsStr) {\n        const contacts = await this.helpers.httpRequest({\n          method: 'GET',\n          url: `${supabaseUrl}/rest/v1/contacts?company_id=in.(${companyIdsStr})&select=id`,\n          headers: { 'apikey': supabaseKey, 'Authorization': 'Bearer ' + supabaseKey },\n          json: true\n        });\n        contactsFound = Array.isArray(contacts) ? contacts.length : 0;\n      }\n    } catch(e) {\n      console.log(`  WARNING: Failed to query totals: ${e.message}`);\n    }\n\n    // Mark run as completed\n    try {\n      await this.helpers.httpRequest({\n        method: 'PATCH',\n        url: `${supabaseUrl}/rest/v1/pipeline_runs?id=eq.${runId}`,\n        headers: { ...sbHeaders, 'Prefer': 'return=minimal' },\n        body: {\n          status: 'completed',\n          completed_at: new Date().toISOString(),\n          total_discovered: totalDiscovered,\n          contacts_found: contactsFound\n        },\n        json: true\n      });\n      console.log(`Track Batch Completion: pipeline_runs ${runId} -> completed (${totalDiscovered} companies, ${contactsFound} contacts)`);\n    } catch(e) {\n      console.log(`  WARNING: Failed to mark run as completed: ${e.message}`);\n    }\n  }\n\n  return [{ json: {\n    step: 'track_batch_completion',\n    metro,\n    run_id: runId,\n    completed_batches: result ? result.completed_batches : null,\n    total_batches: result ? result.total_batches : null,\n    is_last_batch: result ? result.is_last_batch : false,\n    companies_in_batch: companyIds.length\n  }}];\n\n} catch(e) {\n  console.log(`Track Batch Completion: ERROR - ${e.message}`);\n  // Non-blocking - enrichment succeeded even if tracking fails\n  return [{ json: { step: 'track_batch_completion', metro, run_id: runId, error: e.message } }];\n}"
      }
    }
  ],
  "connections": {
    "Webhook": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Respond to Webhook": {
      "main": [
        [
          {
            "node": "Enrich Companies",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Enrich Companies": {
      "main": [
        [
          {
            "node": "Find Contacts",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Find Contacts": {
      "main": [
        [
          {
            "node": "Enrich Contacts",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Enrich Contacts": {
      "main": [
        [
          {
            "node": "Mark Fully Enriched",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Mark Fully Enriched": {
      "main": [
        [
          {
            "node": "Track Batch Completion",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "callerPolicy": "workflowsFromSameOwner",
    "availableInMCP": false
  },
  "staticData": null,
  "meta": null,
  "pinData": null,
  "versionId": "b845ef7e-d863-4744-9084-55ad343d0c80",
  "activeVersionId": "b845ef7e-d863-4744-9084-55ad343d0c80",
  "versionCounter": 23,
  "triggerCount": 1,
  "shared": [
    {
      "updatedAt": "2026-02-20T16:45:58.923Z",
      "createdAt": "2026-02-20T16:45:58.923Z",
      "role": "workflow:owner",
      "workflowId": "fGm4IP0rWxgHptN8",
      "projectId": "333cvByoNUNJEvRJ",
      "project": {
        "updatedAt": "2026-02-14T18:27:04.985Z",
        "createdAt": "2026-02-14T18:04:34.656Z",
        "id": "333cvByoNUNJEvRJ",
        "name": "Phillip Schuman <2fa@spamarketing.com>",
        "type": "personal",
        "icon": null,
        "description": null,
        "creatorId": "a0f6ea10-aac2-4dd7-a7bc-df1184531a06",
        "projectRelations": [
          {
            "updatedAt": "2026-02-14T18:04:34.656Z",
            "createdAt": "2026-02-14T18:04:34.656Z",
            "userId": "a0f6ea10-aac2-4dd7-a7bc-df1184531a06",
            "projectId": "333cvByoNUNJEvRJ",
            "user": {
              "updatedAt": "2026-02-21T00:00:02.597Z",
              "createdAt": "2026-02-14T18:04:33.805Z",
              "id": "a0f6ea10-aac2-4dd7-a7bc-df1184531a06",
              "email": "2fa@spamarketing.com",
              "firstName": "Phillip",
              "lastName": "Schuman",
              "personalizationAnswers": {
                "version": "v4",
                "personalization_survey_submitted_at": "2026-02-14T18:27:56.226Z",
                "personalization_survey_n8n_version": "2.1.5",
                "companyIndustryExtended": [
                  "other"
                ],
                "otherCompanyIndustryExtended": "Agency - Massage Clinics",
                "companySize": "<20",
                "companyType": "other",
                "role": "business-owner",
                "reportedSource": "friend"
              },
              "settings": {
                "userActivated": true,
                "firstSuccessfulWorkflowId": "fGm4IP0rWxgHptN8",
                "userActivatedAt": 1771614367777
              },
              "disabled": false,
              "mfaEnabled": false,
              "lastActiveAt": "2026-02-21",
              "isPending": false
            }
          }
        ]
      }
    }
  ],
  "tags": [],
  "activeVersion": {
    "updatedAt": "2026-02-21T18:15:05.005Z",
    "createdAt": "2026-02-21T18:15:05.005Z",
    "versionId": "b845ef7e-d863-4744-9084-55ad343d0c80",
    "workflowId": "fGm4IP0rWxgHptN8",
    "nodes": [
      {
        "id": "sw-webhook-0001",
        "name": "Webhook",
        "type": "n8n-nodes-base.webhook",
        "typeVersion": 2,
        "position": [
          0,
          192
        ],
        "webhookId": "batch-enrichment-v1",
        "parameters": {
          "httpMethod": "POST",
          "path": "batch-enrichment-v1",
          "responseMode": "responseNode",
          "options": {}
        }
      },
      {
        "id": "sw-respond-0001",
        "name": "Respond to Webhook",
        "type": "n8n-nodes-base.respondToWebhook",
        "typeVersion": 1.1,
        "position": [
          500,
          192
        ],
        "parameters": {
          "respondWith": "json",
          "responseBody": "={{ JSON.stringify({ status: \"accepted\", company_count: $json.body.company_ids.length }) }}",
          "options": {}
        }
      },
      {
        "id": "sw-enrich-companies-0001",
        "name": "Enrich Companies",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          1000,
          192
        ],
        "parameters": {
          "jsCode": "// Enrich Companies — Single Code node replacing entire Step 2 + Step 3b pipeline\n// Mode: runOnceForAllItems\n// Input: { metro, company_ids } from sub-workflow webhook, OR trigger from main workflow\n// Output: summary → Find Contacts (includes metro + company_ids for chain)\n//\n// For each discovered company: domain backfill, website scrape, Google Details,\n// company update, social profiles insert. All via this.helpers.httpRequest().\n\nconst inputData = $input.first().json;\n// n8n Webhook v2 wraps POST body under .body; unwrap for sub-workflow mode\nconst payload = inputData.body || inputData;\nconst metro = payload.metro || payload.metro_name;\nconst companyIds = payload.company_ids || null;\nif (!metro) {\n  throw new Error('Enrich Companies: missing metro in input. Expected metro or metro_name field.');\n}\nconst supabaseUrl = $env.SUPABASE_URL;\nconst supabaseKey = $env.SUPABASE_SERVICE_KEY;\nconst googleApiKey = $env.GOOGLE_PLACES_API_KEY;\nconst sbHeaders = { 'apikey': supabaseKey, 'Authorization': 'Bearer ' + supabaseKey };\nconst sbWriteHeaders = { ...sbHeaders, 'Content-Type': 'application/json', 'Prefer': 'return=minimal' };\n\n// ═══ CONFIG (previously in Enrichment Config Set node) ═══\nconst SKIP_GOOGLE_DETAILS = false;\nconst HTTP_TIMEOUT = 15000;\n\n// ═══ CONSTANTS ═══\n\nconst BLOCKED_DOMAINS = ['wixsite.com','wix.com','setmore.com','schedulista.com','glossgenius.com','square.site','genbook.com','jane.app','acuityscheduling.com','mindbodyonline.com','mindbody.io','vagaro.com','fresha.com','schedulicity.com','booksy.com','massagebook.com','noterro.com','clinicsense.com','calendly.com','squarespace.com'];\n\nconst bookingSignatures = {\n  'jane_app': ['jane.app', 'janeapp.com'],\n  'acuity': ['acuityscheduling.com', 'squareup.com/appointments', 'app.acuityscheduling.com'],\n  'mindbody': ['mindbodyonline.com', 'clients.mindbodyonline.com', 'mindbody.io', 'healcode.com'],\n  'square': ['square.site', 'squareup.com'],\n  'vagaro': ['vagaro.com'],\n  'fresha': ['fresha.com', 'shedul.com'],\n  'schedulicity': ['schedulicity.com'],\n  'schedulista': ['schedulista.com'],\n  'booksy': ['booksy.com'],\n  'massagebook': ['massagebook.com'],\n  'genbook': ['genbook.com'],\n  'noterro': ['noterro.com'],\n  'clinicsense': ['clinicsense.com'],\n  'wix_bookings': ['wix.com/booking', 'bookings.wixapps.net'],\n  'calendly': ['calendly.com']\n};\n\nconst bookingPatterns = ['book now', 'book online', 'book appointment', 'schedule now', 'schedule online', 'book a massage', 'online booking'];\n\nconst adSignatures = [\n  'googleadservices.com', 'googlesyndication.com', 'googleads.g.doubleclick.net',\n  'google_conversion', 'conversion_async', 'ads/ga-audiences',\n  'fbevents.js', 'fbq(', 'snap.licdn.com', 'linkedin.com/insight',\n  'analytics.tiktok.com', 'tiktok.com/i18n/pixel', 'ads-twitter.com', 'static.ads-twitter.com'\n];\n\nconst socialPatterns = {\n  facebook: /https?:\\/\\/(?:www\\.)?facebook\\.com\\/[a-zA-Z0-9._-]+/gi,\n  instagram: /https?:\\/\\/(?:www\\.)?instagram\\.com\\/[a-zA-Z0-9._-]+/gi,\n  tiktok: /https?:\\/\\/(?:www\\.)?tiktok\\.com\\/@[a-zA-Z0-9._-]+/gi,\n  linkedin: /https?:\\/\\/(?:www\\.)?linkedin\\.com\\/(?:company|in)\\/[a-zA-Z0-9._-]+/gi,\n  x: /https?:\\/\\/(?:www\\.)?(?:twitter\\.com|x\\.com)\\/[a-zA-Z0-9._-]+/gi,\n  youtube: /https?:\\/\\/(?:www\\.)?youtube\\.com\\/(?:c\\/|channel\\/|@)[a-zA-Z0-9._-]+/gi\n};\n\nconst junkEmailDomains = [\n  'sentry.io', 'schema.org', 'w3.org', 'wordpress.com', 'wordpress.org',\n  'squarespace.com', 'wix.com', 'gravatar.com', 'facebook.com', 'twitter.com',\n  'instagram.com', 'youtube.com', 'linkedin.com', 'pinterest.com', 'tiktok.com',\n  'cloudflare.com', 'googleapis.com', 'googletagmanager.com', 'google-analytics.com',\n  'gstatic.com', 'jsdelivr.net', 'cdnjs.cloudflare.com', 'unpkg.com',\n  'bootstrapcdn.com', 'fontawesome.com', 'typekit.net', 'fonts.googleapis.com',\n  'example.com', 'example.org', 'test.com', 'localhost',\n  'mailinator.com', 'guerrillamail.com', 'tempmail.com', 'yopmail.com'\n];\n\nconst junkLocalPatterns = [\n  /^noreply$/i, /^no-reply$/i, /^donotreply$/i, /^do-not-reply$/i,\n  /^postmaster$/i, /^mailer-daemon$/i, /^webmaster$/i, /^root$/i,\n  /^null$/i, /^test$/i, /^admin$/i, /^abuse$/i\n];\n\nconst roleBasedPrefixes = ['info', 'contact', 'hello', 'office', 'reception',\n  'frontdesk', 'front.desk', 'appointments', 'booking', 'bookings',\n  'schedule', 'scheduling', 'inquiries', 'inquiry', 'general', 'team', 'staff',\n  'support', 'sales', 'billing'];\n\nconst emailRegex = /[a-zA-Z0-9._%+\\-]+@[a-zA-Z0-9.\\-]+\\.[a-zA-Z]{2,}/g;\nconst mailtoRegex = /mailto:([a-zA-Z0-9._%+\\-]+@[a-zA-Z0-9.\\-]+\\.[a-zA-Z]{2,})/gi;\n\nconst teamPatterns = [\n  /our\\s+team/i, /meet\\s+(?:the\\s+)?team/i, /our\\s+(?:therapists|practitioners|staff|massage\\s+therapists)/i,\n  /meet\\s+(?:our|the)\\s+(?:therapists|practitioners|staff)/i\n];\n\nconst soloSignals = ['sole proprietor', 'solo practice', 'independent massage',\n  'i am a licensed', \"i'm a licensed\", 'about me', 'my practice', 'my approach',\n  'my services', 'i specialize', 'i provide'];\n\n// ═══ HELPER FUNCTIONS ═══\n\nfunction isDomainBlocked(domain) {\n  if (!domain) return false;\n  const lower = domain.toLowerCase();\n  return BLOCKED_DOMAINS.some(b => lower === b || lower.endsWith('.' + b));\n}\n\nfunction detectBookingFromDomain(domain) {\n  if (!domain) return { has_online_booking: false, booking_platform: null };\n  const lower = domain.toLowerCase();\n  for (const [platform, sigs] of Object.entries(bookingSignatures)) {\n    for (const sig of sigs) {\n      if (lower.includes(sig)) return { has_online_booking: true, booking_platform: platform };\n    }\n  }\n  return { has_online_booking: false, booking_platform: null };\n}\n\nfunction analyzeWebsiteHtml(rawHtml, domain) {\n  const result = {\n    has_online_booking: false, booking_platform: null, has_paid_ads: false,\n    estimated_size: null, social_links_found: [], emails_found: [], best_email: null,\n    _website_fetch_status: 'success'\n  };\n\n  // Domain-based booking detection first\n  const domainBooking = detectBookingFromDomain(domain);\n  result.has_online_booking = domainBooking.has_online_booking;\n  result.booking_platform = domainBooking.booking_platform;\n\n  if (!rawHtml || typeof rawHtml !== 'string') {\n    result._website_fetch_status = 'empty_response';\n    return result;\n  }\n\n  const html = rawHtml.toLowerCase();\n  const htmlOriginal = rawHtml;\n\n  // Email extraction\n  const allEmailMatches = htmlOriginal.match(emailRegex) || [];\n  mailtoRegex.lastIndex = 0;\n  const mailtoEmails = new Set();\n  let mailtoMatch;\n  while ((mailtoMatch = mailtoRegex.exec(htmlOriginal)) !== null) {\n    mailtoEmails.add(mailtoMatch[1].toLowerCase());\n  }\n\n  const uniqueEmails = [...new Set(allEmailMatches.map(e => e.toLowerCase()))];\n  const scoredEmails = [];\n\n  for (const email of uniqueEmails) {\n    const [localPart, emailDomain] = email.split('@');\n    if (!emailDomain) continue;\n    if (junkEmailDomains.some(d => emailDomain.includes(d))) continue;\n    if (junkLocalPatterns.some(p => p.test(localPart))) continue;\n    if (/^\\d+$/.test(localPart)) continue;\n\n    let score = 0;\n    if (domain && emailDomain.includes(domain.replace('www.', ''))) score += 20;\n    if (mailtoEmails.has(email)) score += 10;\n    if (roleBasedPrefixes.some(p => localPart === p || localPart.startsWith(p + '.'))) score += 5;\n    scoredEmails.push({ email, score, from_mailto: mailtoEmails.has(email) });\n  }\n\n  scoredEmails.sort((a, b) => b.score - a.score);\n  result.emails_found = scoredEmails.slice(0, 5);\n  result.best_email = scoredEmails.length > 0 ? scoredEmails[0].email : null;\n\n  // HTML-based booking detection\n  if (!result.has_online_booking) {\n    for (const [platform, sigs] of Object.entries(bookingSignatures)) {\n      for (const sig of sigs) {\n        if (html.includes(sig)) {\n          result.booking_platform = platform;\n          result.has_online_booking = true;\n          break;\n        }\n      }\n      if (result.has_online_booking) break;\n    }\n  }\n  if (!result.has_online_booking) {\n    for (const pattern of bookingPatterns) {\n      if (html.includes(pattern)) {\n        result.has_online_booking = true;\n        result.booking_platform = 'unknown';\n        break;\n      }\n    }\n  }\n\n  // Paid ads detection\n  for (const sig of adSignatures) {\n    if (html.includes(sig)) { result.has_paid_ads = true; break; }\n  }\n\n  // Social links extraction\n  const seenPlatforms = new Set();\n  for (const [platform, regex] of Object.entries(socialPatterns)) {\n    regex.lastIndex = 0;\n    const matches = htmlOriginal.match(regex) || [];\n    for (const url of matches) {\n      const lowerUrl = url.toLowerCase();\n      if (lowerUrl.includes('/sharer') || lowerUrl.includes('/share') ||\n          lowerUrl.includes('/intent') || lowerUrl.includes('/login') ||\n          lowerUrl.includes('/help') || lowerUrl.includes('/about') ||\n          lowerUrl.includes('/policies') || lowerUrl.includes('/privacy')) continue;\n      if (!seenPlatforms.has(platform)) {\n        result.social_links_found.push({ platform, url: url.replace(/\\/+$/, '') });\n        seenPlatforms.add(platform);\n      }\n    }\n  }\n\n  // Team size estimation\n  let hasTeamPage = false;\n  for (const p of teamPatterns) { if (p.test(htmlOriginal)) { hasTeamPage = true; break; } }\n  if (hasTeamPage) {\n    const namePatterns = htmlOriginal.match(/<h[2-4][^>]*>[^<]{2,40}<\\/h[2-4]>/gi) || [];\n    const staffLinks = htmlOriginal.match(/\\/(?:team|staff|therapist|practitioner)s?\\/[a-z-]+/gi) || [];\n    const memberCount = Math.max(namePatterns.length, staffLinks.length);\n    if (memberCount <= 1) result.estimated_size = 'solo';\n    else if (memberCount <= 5) result.estimated_size = 'small';\n    else result.estimated_size = 'medium';\n  } else {\n    if (soloSignals.some(s => html.includes(s))) result.estimated_size = 'solo';\n  }\n\n  return result;\n}\n\nfunction extractDomainFromPlaces(company, places) {\n  if (!places || places.length === 0) return null;\n\n  const companyName = (company.name || '').toLowerCase().replace(/[^a-z0-9\\s]/g, '');\n  const companyPhone = (company.phone || '').replace(/[^\\d]/g, '');\n\n  let bestMatch = null;\n  let bestScore = 0;\n\n  for (const place of places) {\n    const placeName = ((place.displayName && place.displayName.text) || '').toLowerCase().replace(/[^a-z0-9\\s]/g, '');\n    let score = 0;\n\n    const companyWords = companyName.split(/\\s+/).filter(w => w.length > 2);\n    const placeWords = placeName.split(/\\s+/).filter(w => w.length > 2);\n    const matchingWords = companyWords.filter(w => placeWords.some(pw => pw.includes(w) || w.includes(pw)));\n    score = companyWords.length > 0 ? matchingWords.length / companyWords.length : 0;\n\n    const placePhone = (place.internationalPhoneNumber || place.nationalPhoneNumber || '').replace(/[^\\d]/g, '');\n    if (companyPhone && placePhone && (placePhone.includes(companyPhone.slice(-10)) || companyPhone.includes(placePhone.slice(-10)))) {\n      score += 0.5;\n    }\n\n    if (score > bestScore && score >= 0.4) { bestScore = score; bestMatch = place; }\n  }\n\n  if (!bestMatch) return null;\n\n  const website = bestMatch.websiteUri || '';\n  let domain = null;\n  if (website) {\n    const match = website.match(/^https?:\\/\\/(?:www\\.)?([^\\/]+)/i);\n    if (match) domain = match[1];\n  }\n\n  // Check domain against blocklist\n  if (domain && isDomainBlocked(domain)) domain = null;\n\n  return {\n    domain,\n    google_place_id: bestMatch.id || null,\n    google_rating: bestMatch.rating || null,\n    google_review_count: bestMatch.userRatingCount || null,\n    _match_score: bestScore\n  };\n}\n\nconst delay = (ms) => new Promise(r => setTimeout(r, ms));\n\n// ═══ FETCH COMPANIES ═══\n\n// Batch mode: query by company IDs; Legacy mode: query by metro + status\nlet companyQueryParams;\nif (companyIds && companyIds.length > 0) {\n  companyQueryParams = `id=in.(${companyIds.join(',')})`;\n} else {\n  companyQueryParams = `enrichment_status=in.(discovered,partially_enriched)&discovery_metro=eq.${encodeURIComponent(metro)}`;\n}\n\nconst companies = await this.helpers.httpRequest({\n  method: 'GET',\n  url: `${supabaseUrl}/rest/v1/companies?${companyQueryParams}&order=discovered_at.asc&limit=1000&select=id,name,phone,domain,address,city,state,country,google_place_id,category,has_website,google_review_count,google_rating,source_urls,on_yelp,on_groupon`,\n  headers: sbHeaders,\n  json: true\n});\n\nif (!Array.isArray(companies) || companies.length === 0) {\n  console.log('No companies to enrich for metro: ' + metro);\n  return [{ json: { step: 'enrich_companies', processed: 0, message: 'No companies to enrich', metro, company_ids: companyIds } }];\n}\n\nconsole.log(`Enrich Companies: ${companies.length} companies to process for ${metro}`);\n\n// ═══ STATS ═══\nconst stats = {\n  processed: 0, domainBackfilled: 0, websitesFetched: 0, websiteErrors: 0,\n  bookingDetected: 0, paidAdsDetected: 0, socialFromWebsite: 0, socialProfilesInserted: 0,\n  googleDetailsProcessed: 0, companyUpdates: 0, updateErrors: 0, errors: 0\n};\n\n// ═══ MAIN LOOP ═══\n\nfor (const company of companies) {\n  try {\n    let domain = company.domain;\n    let backfillPatch = {};\n    let has_website = company.has_website;\n\n    // ── 1. Domain backfill if needed ──\n    if (!domain && has_website) {\n      try {\n        const placesResp = await this.helpers.httpRequest({\n          method: 'POST',\n          url: 'https://places.googleapis.com/v1/places:searchText',\n          headers: {\n            'X-Goog-FieldMask': 'places.id,places.displayName,places.nationalPhoneNumber,places.internationalPhoneNumber,places.websiteUri,places.rating,places.userRatingCount',\n            'X-Goog-Api-Key': googleApiKey,\n            'Content-Type': 'application/json'\n          },\n          body: { textQuery: `${company.name} ${company.city} ${company.state}`, maxResultCount: 3 },\n          json: true\n        });\n\n        const result = extractDomainFromPlaces(company, placesResp.places || []);\n        if (result) {\n          if (result.domain) {\n            domain = result.domain;\n            has_website = true;\n            backfillPatch.domain = domain;\n            backfillPatch.has_website = true;\n          }\n          if (result.google_place_id && !company.google_place_id) backfillPatch.google_place_id = result.google_place_id;\n          if (result.google_rating && !company.google_rating) backfillPatch.google_rating = result.google_rating;\n          if (result.google_review_count && !company.google_review_count) backfillPatch.google_review_count = result.google_review_count;\n          stats.domainBackfilled++;\n        }\n        await delay(200);\n      } catch(e) {\n        console.log(`Domain backfill error for ${company.name}: ${e.message}`);\n      }\n    }\n\n    // ── 2. Website scrape ──\n    let websiteData = {\n      has_online_booking: false, booking_platform: null, has_paid_ads: false,\n      estimated_size: null, social_links_found: [], emails_found: [], best_email: null,\n      _website_fetch_status: 'skipped'\n    };\n\n    if (domain && !isDomainBlocked(domain)) {\n      try {\n        const resp = await this.helpers.httpRequest({\n          method: 'GET',\n          url: `https://${domain}`,\n          headers: {\n            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36',\n            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8'\n          },\n          returnFullResponse: true,\n          timeout: HTTP_TIMEOUT,\n          json: false,\n        });\n        const rawHtml = resp.body || '';\n        if (typeof rawHtml === 'string' && rawHtml.length > 100) {\n          websiteData = analyzeWebsiteHtml(rawHtml, domain);\n          stats.websitesFetched++;\n        } else {\n          websiteData._website_fetch_status = 'empty_response';\n          stats.websiteErrors++;\n        }\n      } catch(e) {\n        websiteData._website_fetch_status = 'error';\n        // Still check domain for booking platform signals\n        const domainBooking = detectBookingFromDomain(domain);\n        websiteData.has_online_booking = domainBooking.has_online_booking;\n        websiteData.booking_platform = domainBooking.booking_platform;\n        stats.websiteErrors++;\n      }\n    } else if (domain && isDomainBlocked(domain)) {\n      // Blocked domain — still detect booking platform from domain\n      const domainBooking = detectBookingFromDomain(domain);\n      websiteData.has_online_booking = domainBooking.has_online_booking;\n      websiteData.booking_platform = domainBooking.booking_platform;\n      websiteData._website_fetch_status = 'skipped_blocked_domain';\n    } else {\n      // No domain — check company's existing domain for booking signals\n      const domainBooking = detectBookingFromDomain(company.domain);\n      websiteData.has_online_booking = domainBooking.has_online_booking;\n      websiteData.booking_platform = domainBooking.booking_platform;\n      websiteData._website_fetch_status = 'skipped_no_website';\n    }\n\n    if (websiteData.has_online_booking) stats.bookingDetected++;\n    if (websiteData.has_paid_ads) stats.paidAdsDetected++;\n    stats.socialFromWebsite += websiteData.social_links_found.length;\n\n    // ── 3. Google Places Details ──\n    let googleDetails = {\n      opening_hours: null, business_status: null, photo_count: 0,\n      price_level: null, additional_types: [], _fetch_status: 'skipped'\n    };\n\n    const placeId = company.google_place_id || backfillPatch.google_place_id;\n    if (placeId && !SKIP_GOOGLE_DETAILS) {\n      try {\n        const details = await this.helpers.httpRequest({\n          method: 'GET',\n          url: `https://places.googleapis.com/v1/places/${placeId}`,\n          headers: {\n            'X-Goog-FieldMask': 'currentOpeningHours,regularOpeningHours,types,photos,priceLevel,businessStatus',\n            'X-Goog-Api-Key': googleApiKey\n          },\n          json: true\n        });\n\n        if (details && !details.error) {\n          if (details.regularOpeningHours && details.regularOpeningHours.periods) {\n            googleDetails.opening_hours = details.regularOpeningHours;\n          } else if (details.currentOpeningHours && details.currentOpeningHours.periods) {\n            googleDetails.opening_hours = details.currentOpeningHours;\n          }\n          googleDetails.business_status = details.businessStatus || null;\n          if (details.photos && Array.isArray(details.photos)) googleDetails.photo_count = details.photos.length;\n          googleDetails.price_level = details.priceLevel || null;\n          if (details.types && Array.isArray(details.types)) googleDetails.additional_types = details.types;\n          googleDetails._fetch_status = 'success';\n          stats.googleDetailsProcessed++;\n        }\n        await delay(100);\n      } catch(e) {\n        googleDetails._fetch_status = 'error';\n        console.log(`Google Details error for ${company.name}: ${e.message}`);\n      }\n    }\n\n    // ── 4. Build update payload ──\n    const now = new Date().toISOString();\n    const updatePayload = {\n      has_online_booking: websiteData.has_online_booking || false,\n      booking_platform: websiteData.booking_platform || null,\n      has_paid_ads: websiteData.has_paid_ads || false,\n      estimated_size: websiteData.estimated_size || null,\n      enrichment_status: 'partially_enriched',\n      enriched_at: now\n    };\n\n    // Backfill data\n    if (backfillPatch.domain) updatePayload.domain = backfillPatch.domain;\n    if (backfillPatch.google_place_id) updatePayload.google_place_id = backfillPatch.google_place_id;\n    if (backfillPatch.google_rating) updatePayload.google_rating = backfillPatch.google_rating;\n    if (backfillPatch.google_review_count) updatePayload.google_review_count = backfillPatch.google_review_count;\n    if (backfillPatch.has_website) updatePayload.has_website = backfillPatch.has_website;\n    if (has_website && !company.has_website) updatePayload.has_website = has_website;\n\n    // Website-scraped email\n    if (websiteData.best_email) updatePayload.email = websiteData.best_email;\n\n    // ── 5. PATCH company in Supabase ──\n    try {\n      await this.helpers.httpRequest({\n        method: 'PATCH',\n        url: `${supabaseUrl}/rest/v1/companies?id=eq.${company.id}`,\n        headers: sbWriteHeaders,\n        body: updatePayload,\n        json: true\n      });\n      stats.companyUpdates++;\n    } catch(e) {\n      console.log(`Company update error for ${company.name} (${company.id}): ${e.message}`);\n      stats.updateErrors++;\n    }\n\n    // ── 6. Insert social profiles if found ──\n    if (websiteData.social_links_found.length > 0) {\n      const rows = websiteData.social_links_found.map(link => ({\n        company_id: company.id,\n        platform: link.platform,\n        profile_url: link.url,\n        follower_count: null,\n        post_count: null,\n        last_post_date: null,\n        scraped_at: now\n      }));\n\n      try {\n        await this.helpers.httpRequest({\n          method: 'POST',\n          url: `${supabaseUrl}/rest/v1/social_profiles`,\n          headers: { ...sbHeaders, 'Content-Type': 'application/json', 'Prefer': 'resolution=merge-duplicates,return=minimal' },\n          body: rows,\n          json: true\n        });\n        stats.socialProfilesInserted += rows.length;\n      } catch(e) {\n        console.log(`Social profiles insert error for ${company.name}: ${e.message}`);\n      }\n    }\n\n    stats.processed++;\n    if (stats.processed % 25 === 0) {\n      console.log(`  Progress: ${stats.processed}/${companies.length} companies enriched`);\n    }\n  } catch(e) {\n    console.log(`FATAL error enriching ${company.name}: ${e.message}`);\n    stats.errors++;\n  }\n}\n\n// ═══ SUMMARY ═══\nconst summary = {\n  step: 'enrich_companies',\n  metro,\n  run_completed_at: new Date().toISOString(),\n  companies_processed: stats.processed,\n  domain_backfilled: stats.domainBackfilled,\n  websites_fetched: stats.websitesFetched,\n  website_errors: stats.websiteErrors,\n  booking_platforms_detected: stats.bookingDetected,\n  paid_ads_detected: stats.paidAdsDetected,\n  social_links_from_websites: stats.socialFromWebsite,\n  social_profiles_inserted: stats.socialProfilesInserted,\n  google_details_processed: stats.googleDetailsProcessed,\n  company_updates: stats.companyUpdates,\n  update_errors: stats.updateErrors,\n  fatal_errors: stats.errors,\n  message: `Enriched ${stats.processed} companies. ${stats.websitesFetched} websites fetched, ${stats.socialProfilesInserted} social profiles, ${stats.bookingDetected} booking platforms, ${stats.paidAdsDetected} paid ads. ${stats.updateErrors} update errors, ${stats.errors} fatal errors.`\n};\n\nconsole.log('=== STEP 2: ENRICH COMPANIES SUMMARY ===');\nconsole.log(JSON.stringify(summary, null, 2));\n\n// Pass metro + company_ids through for the next node in the chain\nreturn [{ json: { ...summary, metro, company_ids: companyIds } }];"
        }
      },
      {
        "id": "sw-find-contacts-0001",
        "name": "Find Contacts",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          1500,
          192
        ],
        "parameters": {
          "jsCode": "// Find Contacts — Single Code node replacing entire Step 3a pipeline\n// Mode: runOnceForAllItems\n// Input: { metro, company_ids } from upstream Enrich Companies, OR main workflow trigger\n// Output: summary → Enrich Contacts (includes metro + company_ids for chain)\n//\n// For each company without contacts: solo detection, Apollo search/enrich,\n// about page scraping, name extraction, validation, Supabase insert.\n\nconst inputData = $input.first().json;\n// n8n Webhook v2 wraps POST body under .body; unwrap defensively\nconst payload = inputData.body || inputData;\nconst metro = payload.metro || payload.metro_name;\nconst companyIds = payload.company_ids || null;\nif (!metro) {\n  throw new Error('Find Contacts: missing metro in input. Expected metro or metro_name field.');\n}\nconst supabaseUrl = $env.SUPABASE_URL;\nconst supabaseKey = $env.SUPABASE_SERVICE_KEY;\nconst apolloApiKey = $env.APOLLO_API_KEY;\nconst sbHeaders = { 'apikey': supabaseKey, 'Authorization': 'Bearer ' + supabaseKey };\n\n// ═══ CONFIG (previously in Step 3a Config Set node) ═══\nconst SKIP_APOLLO = false;\nconst SKIP_WEBSITE_SCRAPE = false;\nconst APOLLO_ENRICH_ENABLED = true;\n\nconst delay = (ms) => new Promise(r => setTimeout(r, ms));\n\n// ═══ COMMON FIRST NAMES ═══\nconst commonFirstNames = new Set([\n  'aaron','abby','abigail','adam','adrian','adriana','aiden','aimee','alana','albert',\n  'alec','alexa','alexander','alexandra','alexis','alice','alicia','alina','alison','allison',\n  'alyssa','amanda','amber','amelia','amy','ana','andrea','andrew','angela','angelica',\n  'angie','anita','ann','anna','anne','annie','anthony','april','aria','ariana',\n  'ashley','audrey','austin','autumn','ava','avery','bailey','barbara','beatrice','becky',\n  'bella','ben','benjamin','beth','bethany','betty','beverly','bianca','blake','bonnie',\n  'brad','bradley','brandi','brandon','brandy','breanna','brenda','brent','brett','brian',\n  'briana','brianna','bridget','brittany','brittney','brooke','bruce','bryan','caitlin','caleb',\n  'cameron','camila','candace','cara','carina','carl','carla','carlos','carly','carmen',\n  'carol','carolina','caroline','carolyn','carrie','casey','cassandra','cassidy','catherine','cathy',\n  'cecilia','celeste','celia','chad','charlene','charles','charlie','charlotte','chase','chelsea',\n  'cheryl','chloe','chris','christa','christian','christina','christine','christopher','cindy','claire',\n  'clara','claudia','cody','colleen','connor','constance','corey','corinne','courtney','craig',\n  'crystal','cynthia','daisy','dale','dana','daniel','daniela','danielle','daphne','darlene',\n  'darren','dave','david','dawn','dean','deanna','debbie','deborah','debra','denise',\n  'derek','desiree','destiny','diana','diane','dianne','dolores','dominic','donna','doris',\n  'dorothy','douglas','drew','dustin','dylan','eddie','edith','edward','eileen','elaine',\n  'elena','elisa','elizabeth','ella','ellen','ellie','emily','emma','eric','erica',\n  'erika','erin','ernest','esther','ethan','eugene','eva','evan','evelyn','faith',\n  'faye','felicia','fiona','florence','frances','frank','gabriel','gabriela','gabriella','gabrielle',\n  'gail','gary','gavin','genevieve','george','georgia','gerald','gina','giselle','gladys',\n  'glen','glenn','gloria','grace','grant','greg','gregory','gretchen','hailey','haley',\n  'hannah','harold','harriet','harry','hayden','hazel','heather','heidi','helen','henry',\n  'hillary','holly','hope','howard','hunter','ian','irene','iris','isaac','isabel',\n  'isabella','ivy','jack','jackie','jackson','jacob','jacqueline','jade','jaime','jake',\n  'james','jamie','jan','jane','janet','janice','jared','jasmine','jason','jay',\n  'jean','jeanette','jeanne','jeff','jeffrey','jenna','jennifer','jenny','jeremy','jerry',\n  'jesse','jessica','jill','jillian','jim','jimmy','jo','joan','joann','joanna',\n  'joanne','jocelyn','jodi','jody','joe','joel','johanna','john','johnny','jolene',\n  'jon','jonathan','jordan','jorge','jose','joseph','josephine','josh','joshua','joy',\n  'joyce','juan','judith','judy','julia','julian','juliana','julie','june','justin',\n  'kaitlyn','kara','karen','karina','karl','kate','katelyn','katherine','kathleen','kathryn',\n  'kathy','katie','katrina','kay','kayla','keith','kelley','kelli','kelly','kelsey',\n  'ken','kendra','kenneth','kenny','kerry','kevin','kim','kimberly','kirsten','krista',\n  'kristen','kristin','kristina','kristy','kyle','kylie','lacey','lana','lance','larry',\n  'laura','lauren','laurie','leah','lee','leigh','lena','leo','leon','leslie',\n  'lexy','liam','lillian','lily','linda','lindsay','lindsey','lisa','logan','lois',\n  'lora','lorena','lori','lorraine','louis','louise','lucia','luis','luke','lydia',\n  'lynn','mackenzie','madeline','madison','maggie','malik','mallory','mandy','marc','marcia',\n  'marco','marcus','margaret','maria','mariah','marie','marilyn','marina','mario','marisa',\n  'marissa','mark','marlene','marsha','martha','martin','mary','mason','matt','matthew',\n  'maureen','max','maya','megan','meghan','melanie','melinda','melissa','melody','meredith',\n  'mia','michael','michele','michelle','miguel','mike','mildred','mindy','miranda','misty',\n  'mitchell','molly','monica','monique','morgan','mya','nadia','nancy','naomi','natalia',\n  'natalie','natasha','nathan','nathaniel','neil','nelson','nicholas','nicole','nina','noah',\n  'noel','nora','norma','olivia','owen','paige','pam','pamela','patricia','patrick',\n  'patty','paul','paula','pauline','peggy','penny','peter','philip','phyllis','priscilla',\n  'rachel','ralph','ramona','randall','randy','ray','raymond','rebecca','regina','renee',\n  'rhonda','ricardo','richard','rick','ricky','riley','rita','rob','robert','roberta',\n  'robin','rochelle','rodney','roger','ronald','rosa','rosalie','rose','rosemary','roxanne',\n  'ruby','russell','ruth','ryan','sabrina','sally','samantha','samuel','sandra','sandy',\n  'sara','sarah','savannah','scott','sean','selena','serena','seth','shana','shane',\n  'shannon','sharon','shawn','sheila','shelby','shelley','shelly','sheri','sherri','sherry',\n  'shirley','sierra','silvia','simone','sofia','sonia','sonya','sophia','stacey','stacy',\n  'stella','stephanie','stephen','steve','steven','sue','summer','susan','suzanne','sydney',\n  'sylvia','tabitha','tamara','tammy','tanya','tara','tatiana','taylor','teresa','terri',\n  'terry','tess','tessa','theresa','thomas','tiffany','tim','timothy','tina','tito',\n  'todd','tom','tommy','toni','tony','tonya','tracey','traci','tracy','travis',\n  'tricia','trisha','troy','tyler','valerie','vanessa','vera','veronica','vicki','vicky',\n  'victoria','vincent','violet','virginia','vivian','wade','walter','wanda','warren','wayne',\n  'wendy','wesley','whitney','william','willie','wilma','xavier','yolanda','yvette','yvonne',\n  'zachary','zoe'\n]);\n\nfunction isLikelyFirstName(word) {\n  return commonFirstNames.has((word || '').toLowerCase());\n}\n\n// ═══ SOLO PRACTITIONER DETECTION ═══\n\nfunction checkSoloPractitioner(company) {\n  const name = (company.name || '').trim();\n  const estimatedSize = company.estimated_size;\n  let isSolo = false, firstName = null, lastName = null;\n\n  // Pattern 1: \"by Name\"\n  const byPattern = name.match(/\\bby\\s+([A-Z][a-z]+)(?:\\s+([A-Z][a-z]+))?/i);\n  if (byPattern) {\n    if (isLikelyFirstName(byPattern[1]) || estimatedSize === 'solo') {\n      isSolo = true; firstName = byPattern[1]; lastName = byPattern[2] || null;\n    }\n  }\n\n  // Pattern 2: \"with Name\"\n  if (!firstName) {\n    const withPattern = name.match(/\\bwith\\s+([A-Z][a-z]+)(?:\\s+([A-Z][a-z]+))?/i);\n    if (withPattern && (isLikelyFirstName(withPattern[1]) || estimatedSize === 'solo')) {\n      isSolo = true; firstName = withPattern[1]; lastName = withPattern[2] || null;\n    }\n  }\n\n  // Pattern 3: Possessive\n  if (!firstName) {\n    const possessiveMatch = name.match(/^([A-Z][a-z]+)'s\\s+/i);\n    if (possessiveMatch && isLikelyFirstName(possessiveMatch[1])) {\n      isSolo = true; firstName = possessiveMatch[1];\n    }\n  }\n\n  // Pattern 4: \"FirstName LastName, LMT/CMT/RMT\"\n  if (!firstName) {\n    const nameFirst = name.match(/^([A-Z][a-z]+)\\s+([A-Z][a-z]+)(?:\\s*[,|]\\s*|\\s+)(?:LMT|CMT|RMT|Licensed|Massage|Bodywork|Therapeutic|Wellness)/i);\n    if (nameFirst && isLikelyFirstName(nameFirst[1]) && !commonFirstNames.has(nameFirst[2].toLowerCase())) {\n      isSolo = true; firstName = nameFirst[1]; lastName = nameFirst[2];\n    }\n  }\n\n  // Pattern 5: \"FirstName LastName's Massage/Spa\"\n  if (!firstName) {\n    const possessiveFullName = name.match(/^([A-Z][a-z]+)\\s+([A-Z][a-z]+)'s\\s+(?:Massage|Bodywork|Wellness|Spa|Healing)/i);\n    if (possessiveFullName && isLikelyFirstName(possessiveFullName[1])) {\n      isSolo = true; firstName = possessiveFullName[1]; lastName = possessiveFullName[2];\n    }\n  }\n\n  // Pattern 6: Three-part name with title\n  if (!firstName) {\n    const threePartName = name.match(/^([A-Z][a-z]+)\\s+([A-Z][a-z]+)\\s+([A-Z][a-z]+),?\\s+(?:LMT|CMT|RMT|Licensed)/i);\n    if (threePartName && isLikelyFirstName(threePartName[1])) {\n      isSolo = true; firstName = threePartName[1]; lastName = threePartName[3];\n    }\n  }\n\n  // Pattern 7: Name after comma\n  if (!firstName) {\n    const commaNameMatch = name.match(/,\\s*([A-Z][a-z]+)\\s+([A-Z][a-z]+)(?:\\s*,?\\s*(?:LMT|CMT|RMT|Licensed))?/i);\n    if (commaNameMatch && isLikelyFirstName(commaNameMatch[1])) {\n      isSolo = true; firstName = commaNameMatch[1]; lastName = commaNameMatch[2];\n    }\n  }\n\n  if (estimatedSize === 'solo' && !isSolo) isSolo = true;\n\n  // Reject if extracted first name matches city\n  if (firstName && company.city && firstName.toLowerCase() === company.city.toLowerCase()) {\n    firstName = null; lastName = null;\n  }\n\n  return { isSolo, firstName, lastName };\n}\n\n// ═══ NAME EXTRACTION FROM HTML ═══\n\nfunction extractNameFromHtml(html) {\n  if (!html || html.length < 100) return null;\n  const textOnly = html.replace(/<[^>]+>/g, ' ').replace(/\\s+/g, ' ');\n\n  const patterns = [\n    /(?:owner|owned\\s+by|founded\\s+by|proprietor)[:\\s]+([A-Z][a-z]+)\\s+([A-Z][a-z]+)/i,\n    /(?:hi,?\\s+i'?m|hello,?\\s+i'?m|my\\s+name\\s+is|i\\s+am)\\s+([A-Z][a-z]+)\\s+([A-Z][a-z]+)/i,\n    /(?:^|\\s)about\\s+([A-Z][a-z]+)\\s+([A-Z][a-z]+)(?:\\s*[,|]|\\s+(?:LMT|CMT|RMT|Licensed))/i,\n    /(?:^|\\s)meet\\s+([A-Z][a-z]+)\\s+([A-Z][a-z]+)(?:\\s*[,|]|\\s+(?:LMT|CMT|RMT|Licensed|is\\s+a|has\\s+been))/i,\n    /([A-Z][a-z]+)\\s+([A-Z][a-z]+),?\\s+(?:LMT|CMT|RMT|Licensed\\s+Massage)/i\n  ];\n\n  for (const pattern of patterns) {\n    for (const source of [textOnly, html]) {\n      const match = source.match(pattern);\n      if (match) {\n        const fn = match[1], ln = match[2];\n        if (isLikelyFirstName(fn) && fn.length >= 2 && fn.length <= 20 && ln.length >= 2 && ln.length <= 20) {\n          return { firstName: fn, lastName: ln };\n        }\n      }\n    }\n  }\n  return null;\n}\n\n// ═══ NAME EXTRACTION FROM BUSINESS NAME (no domain fallback) ═══\n\nfunction extractNameFromBusinessName(company) {\n  const name = (company.name || '').trim();\n  let firstName = null, lastName = null;\n\n  const patterns = [\n    { re: /\\bby\\s+([A-Z][a-z]+)(?:\\s+([A-Z][a-z]+))?/i, fi: 1, li: 2 },\n    { re: /\\bwith\\s+([A-Z][a-z]+)(?:\\s+([A-Z][a-z]+))?/i, fi: 1, li: 2 },\n    { re: /^([A-Z][a-z]+)'s\\s+/i, fi: 1, li: null },\n    { re: /^([A-Z][a-z]+)\\s+([A-Z][a-z]+)(?:\\s*,?\\s*(?:LMT|CMT|RMT|Licensed))/i, fi: 1, li: 2 },\n    { re: /,\\s*([A-Z][a-z]+)\\s+([A-Z][a-z]+)/i, fi: 1, li: 2 },\n    { re: /^([A-Z][a-z]+)\\s+([A-Z][a-z]+)\\s+(?:Massage|Bodywork|Therapeutic|Wellness|Healing|Spa)/i, fi: 1, li: 2 },\n  ];\n\n  for (const p of patterns) {\n    const m = name.match(p.re);\n    if (m && isLikelyFirstName(m[p.fi])) {\n      firstName = m[p.fi];\n      lastName = p.li ? (m[p.li] || null) : null;\n      // For pattern 6, reject if lastName is also a common first name\n      if (p.re.source.includes('Massage|Bodywork') && lastName && isLikelyFirstName(lastName)) continue;\n      break;\n    }\n  }\n\n  return firstName ? { firstName, lastName } : null;\n}\n\n// ═══ CONTACT VALIDATION ═══\n\nfunction validateAndCleanContact(contact) {\n  const flags = [];\n\n  function validateEmail(email, fieldName) {\n    if (!email) return null;\n    let cleaned = email.trim().toLowerCase();\n    if (!/^[a-zA-Z0-9._%+\\-]+@[a-zA-Z0-9.\\-]+\\.[a-zA-Z]{2,}$/.test(cleaned)) {\n      flags.push(`${fieldName}_invalid_format`); return null;\n    }\n    const junkPatterns = [/^noreply@/, /^no-reply@/, /^donotreply@/, /^test@/, /^admin@example\\./, /^sample@/, /^fake@/, /^placeholder@/, /^null@/, /^none@/, /^unknown@/, /^abuse@/, /^postmaster@/, /^mailer-daemon@/];\n    if (junkPatterns.some(p => p.test(cleaned))) { flags.push(`${fieldName}_junk`); return null; }\n    const rolePatterns = [/^info@/, /^contact@/, /^hello@/, /^support@/, /^sales@/, /^office@/, /^billing@/, /^reception@/, /^frontdesk@/, /^front\\.desk@/, /^appointments@/, /^booking@/, /^bookings@/, /^schedule@/, /^scheduling@/, /^inquiries@/, /^inquiry@/, /^general@/, /^team@/, /^staff@/];\n    if (rolePatterns.some(p => p.test(cleaned))) flags.push(`${fieldName}_role_based_kept`);\n    const junkDomains = ['example.com', 'example.org', 'test.com', 'localhost', 'mailinator.com', 'guerrillamail.com', 'tempmail.com', 'yopmail.com'];\n    const domain = cleaned.split('@')[1];\n    if (junkDomains.includes(domain)) { flags.push(`${fieldName}_junk_domain`); return null; }\n    const localPart = cleaned.split('@')[0];\n    if (/^\\d+$/.test(localPart)) { flags.push(`${fieldName}_numeric_local`); return null; }\n    return cleaned;\n  }\n\n  function validatePhone(phone, fieldName) {\n    if (!phone) return null;\n    if (typeof phone === 'object') phone = phone.sanitized_number || phone.raw_number || phone.number || '';\n    let cleaned = phone.toString().trim().replace(/[^\\d]/g, '');\n    if (!cleaned || cleaned.length === 0) return null;\n    if (cleaned.length === 11 && cleaned.startsWith('1')) { /* ok */ }\n    else if (cleaned.length === 10) cleaned = '1' + cleaned;\n    else if (cleaned.length < 10) { flags.push(`${fieldName}_too_short`); return null; }\n    else if (cleaned.length > 11 && cleaned.length <= 15) {\n      if (cleaned.startsWith('1')) return null;\n      return '+' + cleaned;\n    }\n    else if (cleaned.length > 15) return null;\n    const areaCode = cleaned.substring(1, 4);\n    if (areaCode.startsWith('0') || areaCode.startsWith('1')) return null;\n    return '+' + cleaned;\n  }\n\n  function cleanName(name, fieldName) {\n    if (!name) return null;\n    let cleaned = name.trim().replace(/\\*+$/, '').trim();\n    if (cleaned.length <= 1) return null;\n    if (/^\\d+$/.test(cleaned) || /\\d/.test(cleaned)) return null;\n    const junkNames = ['unknown', 'n/a', 'na', 'none', 'null', 'test', 'owner', 'manager', 'admin', 'info', 'contact'];\n    if (junkNames.includes(cleaned.toLowerCase())) return null;\n    const credentials = ['lmt', 'cmt', 'rmt', 'lmbt', 'lmp', 'bctmb', 'nctmb', 'nctm', 'cpt', 'cst', 'mld', 'nmt', 'amt', 'abmp'];\n    if (credentials.includes(cleaned.toLowerCase())) return null;\n    if (cleaned === cleaned.toUpperCase() || cleaned === cleaned.toLowerCase()) {\n      cleaned = cleaned.charAt(0).toUpperCase() + cleaned.slice(1).toLowerCase();\n    }\n    return cleaned;\n  }\n\n  contact.email_business = validateEmail(contact.email_business, 'email_business');\n  contact.email_personal = validateEmail(contact.email_personal, 'email_personal');\n  contact.phone_direct = validatePhone(contact.phone_direct, 'phone_direct');\n  contact.first_name = cleanName(contact.first_name, 'first_name');\n  contact.last_name = cleanName(contact.last_name, 'last_name');\n  if (!contact.first_name) flags.push('contact_has_no_valid_first_name');\n\n  if (contact.linkedin_url) {\n    if (!/linkedin\\.com\\/in\\//i.test(contact.linkedin_url)) contact.linkedin_url = null;\n    else if (!contact.linkedin_url.startsWith('http')) contact.linkedin_url = 'https://' + contact.linkedin_url;\n  }\n\n  if (contact.location) {\n    contact.location = contact.location.trim();\n    if (!contact.location || contact.location === ',' || contact.location.length < 2) contact.location = null;\n  }\n\n  return { contact, flags, hasValidContact: !!(contact.first_name) };\n}\n\n// ═══ APOLLO ROLE SCORING ═══\n\nconst ownerKeywords = ['owner', 'founder', 'ceo', 'proprietor', 'principal', 'co-founder'];\nconst managerKeywords = ['manager', 'director', 'general manager', 'gm', 'head'];\nconst practitionerKeywords = ['massage', 'therapist', 'lmt', 'cmt', 'rmt', 'bodywork', 'esthetician'];\n\n// ═══ FETCH DATA FROM SUPABASE ═══\n\n// 1. Fetch enriched companies — batch mode (by IDs) or legacy mode (by metro)\nlet companyQueryParams;\nif (companyIds && companyIds.length > 0) {\n  companyQueryParams = `id=in.(${companyIds.join(',')})`;\n} else {\n  companyQueryParams = `enrichment_status=in.(partially_enriched,fully_enriched)&discovery_metro=eq.${encodeURIComponent(metro)}`;\n}\n\nconst companies = await this.helpers.httpRequest({\n  method: 'GET',\n  url: `${supabaseUrl}/rest/v1/companies?${companyQueryParams}&order=lead_score.desc,discovered_at.asc&limit=1000&select=id,name,phone,domain,address,city,state,country,google_place_id,category,estimated_size,has_website,google_review_count,google_rating`,\n  headers: sbHeaders,\n  json: true\n});\n\nif (!Array.isArray(companies) || companies.length === 0) {\n  console.log('No enriched companies found for metro: ' + metro);\n  return [{ json: { step: 'find_contacts', processed: 0, message: 'No companies to find contacts for', metro, company_ids: companyIds } }];\n}\n\n// 2. Fetch existing contacts (for dedup) — only company_id needed\nconst existingContacts = await this.helpers.httpRequest({\n  method: 'GET',\n  url: `${supabaseUrl}/rest/v1/contacts?select=company_id`,\n  headers: sbHeaders,\n  json: true\n});\n\nconst existingSet = new Set();\nif (Array.isArray(existingContacts)) {\n  for (const c of existingContacts) {\n    if (c.company_id) existingSet.add(c.company_id);\n  }\n}\n\n// 3. Filter to companies without contacts\nconst needsContacts = companies.filter(c => c.id && !existingSet.has(c.id));\n\nconsole.log(`Find Contacts: ${companies.length} companies total, ${existingSet.size} already have contacts, ${needsContacts.length} need people discovery for ${metro}`);\n\nif (needsContacts.length === 0) {\n  return [{ json: { step: 'find_contacts', processed: 0, message: 'All companies already have contacts', metro, company_ids: companyIds } }];\n}\n\n// ═══ STATS ═══\nconst stats = {\n  processed: 0, soloDetected: 0, soloWithName: 0,\n  apolloSearched: 0, apolloFound: 0, apolloEnriched: 0,\n  websiteScraped: 0, websiteFoundName: 0,\n  noDomainFallback: 0, noDomainFoundName: 0,\n  contactsInserted: 0, validationIssues: 0, errors: 0\n};\n\n// ═══ MAIN LOOP ═══\n\nlet apolloBatchCount = 0;\n\nfor (const company of needsContacts) {\n  try {\n    let contact = null;\n    let sourceMethod = 'none';\n\n    // ── 1. Solo practitioner check ──\n    const soloResult = checkSoloPractitioner(company);\n    if (soloResult.isSolo) {\n      stats.soloDetected++;\n      if (soloResult.firstName) {\n        stats.soloWithName++;\n        contact = {\n          company_id: company.id, first_name: soloResult.firstName, last_name: soloResult.lastName,\n          role: 'owner', is_owner: true, email_business: null, email_personal: null,\n          phone_direct: null, linkedin_url: null,\n          location: [company.city, company.state].filter(Boolean).join(', ') || null,\n          cultural_affinity: null, source: 'solo_detection'\n        };\n        sourceMethod = 'solo_detection';\n      }\n    }\n\n    // ── 2. Apollo search (if not solo, has domain, enabled) ──\n    if (!soloResult.isSolo && company.domain && !SKIP_APOLLO) {\n      try {\n        // Rate limiting: 3 per batch, 2s delay between batches\n        apolloBatchCount++;\n        if (apolloBatchCount > 3) {\n          await delay(2000);\n          apolloBatchCount = 1;\n        }\n\n        const apolloResp = await this.helpers.httpRequest({\n          method: 'POST',\n          url: 'https://api.apollo.io/api/v1/mixed_people/api_search',\n          headers: {\n            'Content-Type': 'application/json', 'Cache-Control': 'no-cache',\n            'X-Api-Key': apolloApiKey\n          },\n          body: {\n            q_organization_domains: company.domain,\n            person_titles: ['owner', 'founder', 'ceo', 'proprietor', 'director', 'manager', 'massage therapist', 'licensed massage therapist'],\n            per_page: 5\n          },\n          json: true\n        });\n\n        const people = apolloResp.people || [];\n        stats.apolloSearched++;\n\n        if (people.length > 0) {\n          stats.apolloFound++;\n\n          // Score people by role relevance\n          let bestPerson = null, bestScore = -1;\n          for (const person of people) {\n            const title = (person.title || '').toLowerCase();\n            let score = 0;\n            if (ownerKeywords.some(k => title.includes(k))) score = 10;\n            else if (managerKeywords.some(k => title.includes(k))) score = 5;\n            else if (practitionerKeywords.some(k => title.includes(k))) score = 3;\n            else score = 1;\n            if (person.has_email === true || person.has_email === 'true') score += 1;\n            if (score > bestScore) { bestScore = score; bestPerson = person; }\n          }\n\n          // Enrich if enabled\n          if (APOLLO_ENRICH_ENABLED && bestPerson.id) {\n            try {\n              const enrichResp = await this.helpers.httpRequest({\n                method: 'POST',\n                url: 'https://api.apollo.io/api/v1/people/match',\n                headers: {\n                  'Content-Type': 'application/json', 'Cache-Control': 'no-cache',\n                  'X-Api-Key': apolloApiKey\n                },\n                body: { id: bestPerson.id, reveal_personal_emails: true, reveal_phone_number: false },\n                json: true\n              });\n\n              const person = enrichResp.person || enrichResp.match || enrichResp;\n              if (person && person.first_name) {\n                const title = (person.title || '').toLowerCase();\n                let role = 'unknown', isOwner = false;\n                if (['owner','founder','ceo','proprietor','principal','co-founder'].some(k => title.includes(k))) { role = 'owner'; isOwner = true; }\n                else if (['manager','director','gm','general manager'].some(k => title.includes(k))) role = 'manager';\n                else if (['massage','therapist','lmt','cmt','rmt','esthetician'].some(k => title.includes(k))) role = 'practitioner';\n\n                let phoneNumber = null;\n                if (person.phone_numbers && person.phone_numbers.length > 0) {\n                  phoneNumber = person.phone_numbers[0].sanitized_number || person.phone_numbers[0].raw_number || null;\n                }\n\n                contact = {\n                  company_id: company.id, first_name: person.first_name || null,\n                  last_name: person.last_name || null, role, is_owner: isOwner,\n                  email_business: person.email || null,\n                  email_personal: (person.personal_emails && person.personal_emails[0]) || null,\n                  phone_direct: phoneNumber, linkedin_url: person.linkedin_url || null,\n                  location: [person.city, person.state].filter(Boolean).join(', ') || [company.city, company.state].filter(Boolean).join(', ') || null,\n                  cultural_affinity: null, source: 'apollo'\n                };\n                sourceMethod = 'apollo_enriched';\n                stats.apolloEnriched++;\n              } else {\n                // Enrichment returned no usable data — use search-only\n                contact = {\n                  company_id: company.id, first_name: bestPerson.first_name || null,\n                  last_name: null, role: (bestPerson.title || '').toLowerCase().includes('owner') ? 'owner' : 'unknown',\n                  is_owner: (bestPerson.title || '').toLowerCase().includes('owner'),\n                  email_business: null, email_personal: null, phone_direct: null, linkedin_url: null,\n                  location: [company.city, company.state].filter(Boolean).join(', ') || null,\n                  cultural_affinity: null, source: 'apollo'\n                };\n                sourceMethod = 'apollo_search_only';\n                stats.apolloEnriched++;\n              }\n            } catch(e) {\n              // Enrich failed — use search-only data\n              contact = {\n                company_id: company.id, first_name: bestPerson.first_name || null,\n                last_name: null, role: (bestPerson.title || '').toLowerCase().includes('owner') ? 'owner' : 'unknown',\n                is_owner: (bestPerson.title || '').toLowerCase().includes('owner'),\n                email_business: null, email_personal: null, phone_direct: null, linkedin_url: null,\n                location: [company.city, company.state].filter(Boolean).join(', ') || null,\n                cultural_affinity: null, source: 'apollo'\n              };\n              sourceMethod = 'apollo_search_only';\n              stats.apolloEnriched++;\n            }\n          } else {\n            // Enrichment disabled — use search-only\n            contact = {\n              company_id: company.id, first_name: bestPerson.first_name || null,\n              last_name: null, role: (bestPerson.title || '').toLowerCase().includes('owner') ? 'owner' : 'unknown',\n              is_owner: (bestPerson.title || '').toLowerCase().includes('owner'),\n              email_business: null, email_personal: null, phone_direct: null, linkedin_url: null,\n              location: [company.city, company.state].filter(Boolean).join(', ') || null,\n              cultural_affinity: null, source: 'apollo'\n            };\n            sourceMethod = 'apollo_search_only';\n            stats.apolloEnriched++;\n          }\n        } else {\n          // Apollo found nobody — try about page\n          if (company.domain && !SKIP_WEBSITE_SCRAPE) {\n            const additionalPaths = ['/about', '/about-us', '/about-me', '/our-team', '/team', '/our-story'];\n            let nameResult = null;\n            let usedPath = '';\n\n            for (const path of additionalPaths) {\n              try {\n                const resp = await this.helpers.httpRequest({\n                  method: 'GET',\n                  url: `https://${company.domain}${path}`,\n                  headers: { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36' },\n                  returnFullResponse: true, timeout: 10000, json: false,\n                });\n                const html = resp.body || '';\n                if (typeof html === 'string' && html.length > 500) {\n                  const found = extractNameFromHtml(html);\n                  if (found) { nameResult = found; usedPath = path; break; }\n                }\n              } catch(e) { /* Path doesn't exist or timed out */ }\n            }\n\n            stats.websiteScraped++;\n            if (nameResult) {\n              stats.websiteFoundName++;\n              contact = {\n                company_id: company.id, first_name: nameResult.firstName, last_name: nameResult.lastName,\n                role: 'owner', is_owner: true, email_business: null, email_personal: null,\n                phone_direct: null, linkedin_url: null,\n                location: [company.city, company.state].filter(Boolean).join(', ') || null,\n                cultural_affinity: null, source: 'website'\n              };\n              sourceMethod = 'website_scrape_' + usedPath.replace('/', '');\n            }\n          }\n        }\n      } catch(e) {\n        console.log(`Apollo error for ${company.name} (${company.domain}): ${e.message}`);\n      }\n    }\n\n    // ── 3. No domain fallback — extract name from business name ──\n    if (!contact && !company.domain) {\n      stats.noDomainFallback++;\n      const nameResult = extractNameFromBusinessName(company);\n      if (nameResult) {\n        stats.noDomainFoundName++;\n        contact = {\n          company_id: company.id, first_name: nameResult.firstName, last_name: nameResult.lastName,\n          role: 'owner', is_owner: true, email_business: null, email_personal: null,\n          phone_direct: null, linkedin_url: null,\n          location: [company.city, company.state].filter(Boolean).join(', ') || null,\n          cultural_affinity: null, source: 'manual'\n        };\n        sourceMethod = 'no_domain_name_extraction';\n      }\n    }\n\n    // ── 4. Validate & clean contact ──\n    if (contact) {\n      const { contact: cleanedContact, flags, hasValidContact } = validateAndCleanContact(contact);\n      if (flags.length > 0) stats.validationIssues++;\n\n      // ── 5. Insert to Supabase (with dedup) ──\n      if (hasValidContact) {\n        try {\n          await this.helpers.httpRequest({\n            method: 'POST',\n            url: `${supabaseUrl}/rest/v1/contacts?on_conflict=company_id,first_name,last_name,source`,\n            headers: { ...sbHeaders, 'Content-Type': 'application/json', 'Prefer': 'resolution=ignore-duplicates,return=minimal' },\n            body: cleanedContact,\n            json: true\n          });\n          stats.contactsInserted++;\n        } catch(e) {\n          console.log(`Contact insert error for ${company.name}: ${e.message}`);\n        }\n      }\n    }\n\n    stats.processed++;\n    if (stats.processed % 25 === 0) {\n      console.log(`  Progress: ${stats.processed}/${needsContacts.length} companies checked for contacts`);\n    }\n  } catch(e) {\n    console.log(`FATAL error finding contacts for ${company.name}: ${e.message}`);\n    stats.errors++;\n  }\n}\n\n// ═══ SUMMARY ═══\nconst summary = {\n  step: 'find_contacts',\n  metro,\n  run_completed_at: new Date().toISOString(),\n  companies_processed: stats.processed,\n  solo_detected: stats.soloDetected,\n  solo_with_name: stats.soloWithName,\n  apollo_searched: stats.apolloSearched,\n  apollo_found_people: stats.apolloFound,\n  apollo_contacts_created: stats.apolloEnriched,\n  website_scraped: stats.websiteScraped,\n  website_names_found: stats.websiteFoundName,\n  no_domain_fallback: stats.noDomainFallback,\n  no_domain_names_found: stats.noDomainFoundName,\n  contacts_inserted: stats.contactsInserted,\n  validation_issues: stats.validationIssues,\n  fatal_errors: stats.errors,\n  message: `Found contacts for ${stats.contactsInserted} of ${stats.processed} companies. Sources: ${stats.soloWithName} solo, ${stats.apolloEnriched} Apollo, ${stats.websiteFoundName} website, ${stats.noDomainFoundName} name extraction. Validation issues: ${stats.validationIssues}.`\n};\n\nconsole.log('=== STEP 3a: FIND CONTACTS SUMMARY ===');\nconsole.log(JSON.stringify(summary, null, 2));\n\n// Pass metro + company_ids through for the next node in the chain\nreturn [{ json: { ...summary, metro, company_ids: companyIds } }];"
        }
      },
      {
        "id": "sw-enrich-contacts-0001",
        "name": "Enrich Contacts",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          2000,
          192
        ],
        "parameters": {
          "jsCode": "// Enrich Contacts — Modified to include inline Supabase fetch/merge\n// Mode: runOnceForAllItems\n// Input: { metro, company_ids } from upstream Find Contacts, OR main workflow trigger\n// Output: enrichment results → Mark Fully Enriched (sub-workflow) or Run Summary4 (legacy)\n//\n// Previously depended on: Step 4 Config, Fetch Contacts, Fetch Companies1,\n// Filter & Merge Contacts, Collapse to Single. Now handles all of that inline.\n\nconst inputData = $input.first().json;\n// n8n Webhook v2 wraps POST body under .body; unwrap defensively\nconst payload = inputData.body || inputData;\nconst metro = payload.metro || payload.metro_name;\nconst companyIds = payload.company_ids || null;\nif (!metro) {\n  throw new Error('Enrich Contacts: missing metro in input. Expected metro or metro_name field.');\n}\nconst supabaseUrl = $env.SUPABASE_URL;\nconst supabaseKey = $env.SUPABASE_SERVICE_KEY;\nconst sbHeaders = { 'apikey': supabaseKey, 'Authorization': 'Bearer ' + supabaseKey };\n\n// ═══ CONFIG (previously in Step 4 Config Set node) ═══\nconst config = {\n  skip_hunter: 'false',\n  skip_snovio: 'true',\n  skip_hunter_verifier: 'false',\n  skip_namsor: 'false',\n  skip_phone_verifier: 'false',\n  batch_size: '1000',\n  batch_offset: '0'\n};\n\n// ═══ INLINE FETCH: Contacts needing enrichment ═══\n// Batch mode: filter contacts to those belonging to batch companies\n// Legacy mode: fetch all contacts globally (metro filtering happens downstream)\nlet contactsUrl;\nif (companyIds && companyIds.length > 0) {\n  contactsUrl = `${supabaseUrl}/rest/v1/contacts?company_id=in.(${companyIds.join(',')})&select=id,company_id,first_name,last_name,role,is_owner,email_business,email_personal,phone_direct,linkedin_url,cultural_affinity,source,email_status,phone_status,phone_line_type,phone_carrier&or=(email_status.is.null,email_status.eq.unverified,and(phone_direct.not.is.null,phone_status.is.null))&order=created_at.asc`;\n} else {\n  contactsUrl = `${supabaseUrl}/rest/v1/contacts?select=id,company_id,first_name,last_name,role,is_owner,email_business,email_personal,phone_direct,linkedin_url,cultural_affinity,source,email_status,phone_status,phone_line_type,phone_carrier&or=(email_status.is.null,email_status.eq.unverified,and(phone_direct.not.is.null,phone_status.is.null))&order=created_at.asc&limit=${config.batch_size}&offset=${config.batch_offset}`;\n}\n\nconst rawContacts = await this.helpers.httpRequest({\n  method: 'GET',\n  url: contactsUrl,\n  headers: sbHeaders,\n  json: true\n});\n\n// ═══ INLINE FETCH: Companies for this metro/batch ═══\nlet companiesUrl;\nif (companyIds && companyIds.length > 0) {\n  companiesUrl = `${supabaseUrl}/rest/v1/companies?id=in.(${companyIds.join(',')})&select=id,name,phone,domain,email,email_status,phone_status,phone_line_type,city,state`;\n} else {\n  companiesUrl = `${supabaseUrl}/rest/v1/companies?select=id,name,phone,domain,email,email_status,phone_status,phone_line_type,city,state&enrichment_status=in.(partially_enriched,fully_enriched)&discovery_metro=eq.${encodeURIComponent(metro)}`;\n}\n\nconst rawCompanies = await this.helpers.httpRequest({\n  method: 'GET',\n  url: companiesUrl,\n  headers: sbHeaders,\n  json: true\n});\n\n// ═══ INLINE: Filter & Merge Contacts ═══\n// Deduplicate contacts by id\nconst seenIds = new Set();\nlet uniqueContacts = [];\nif (Array.isArray(rawContacts)) {\n  for (const c of rawContacts) {\n    if (c.id && !seenIds.has(c.id)) {\n      seenIds.add(c.id);\n      uniqueContacts.push(c);\n    }\n  }\n}\n\n// Build company lookup map (metro-scoped)\nconst companyMap = {};\nif (Array.isArray(rawCompanies)) {\n  for (const co of rawCompanies) {\n    if (co.id) companyMap[co.id] = co;\n  }\n}\n\n// Filter contacts that need enrichment\nconst needsEnrichment = uniqueContacts.filter(c => {\n  const missingEmail = !c.email_business;\n  const missingCulturalAffinity = !c.cultural_affinity;\n  const missingPhone = !c.phone_direct;\n  const missingLinkedin = !c.linkedin_url;\n  const verifiedStatuses = ['verified', 'invalid', 'risky', 'accept_all'];\n  const emailNeedsVerification = c.email_business && !verifiedStatuses.includes(c.email_status);\n  const phoneNeedsVerification = c.phone_direct && !c.phone_status;\n  return missingEmail || missingCulturalAffinity || missingPhone || missingLinkedin || emailNeedsVerification || phoneNeedsVerification;\n});\n\n// Metro filter: only keep contacts whose company is in the metro-scoped companyMap\nconst metroFiltered = needsEnrichment.filter(c => companyMap[c.company_id]);\nconst crossMetroSkipped = needsEnrichment.length - metroFiltered.length;\n\nconsole.log(`Contacts: ${uniqueContacts.length} unique, ${needsEnrichment.length} need enrichment, ${crossMetroSkipped} skipped (other metro), ${metroFiltered.length} in current metro`);\n\nif (metroFiltered.length === 0) {\n  return [{ json: { _empty: true, _count: 0, _message: 'All contacts are already enriched or belong to other metros', metro, company_ids: companyIds } }];\n}\n\n// Merge company data into each contact\nconst contacts = metroFiltered.map(c => {\n  const company = companyMap[c.company_id];\n  return {\n    json: {\n      ...c,\n      _company_name: company.name || null,\n      _company_domain: company.domain || null,\n      _company_phone: company.phone || null,\n      _company_email: company.email || null,\n      _company_email_status: company.email_status || null,\n      _company_phone_status: company.phone_status || null,\n      _company_phone_line_type: company.phone_line_type || null,\n      _company_city: company.city || null,\n      _company_state: company.state || null\n    }\n  };\n});\n\n// ═══ ENRICHMENT PIPELINE (unchanged from original Enrich Contacts node) ═══\n\nconst results = [];\n\n// Helper: delay between API calls for rate limiting\nconst delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));\n\n// Dedup guard: track companies that already had email set/verified this execution\n// Batch mode: use local object (parallel sub-workflow executions don't share state safely)\n// Legacy mode: use static data with BUG-F019 cleanup\nlet companyEmailsSet;\nif (companyIds && companyIds.length > 0) {\n  // Batch mode: local dedup — each sub-workflow execution is independent\n  companyEmailsSet = {};\n} else {\n  // Legacy mode: static data dedup (ADR-015)\n  const staticData = $getWorkflowStaticData('global');\n  if (!staticData._companyEmailsSet) staticData._companyEmailsSet = {};\n  companyEmailsSet = staticData._companyEmailsSet;\n  // BUG-F019 FIX: Clear ALL stale keys from previous executions.\n  for (const key of Object.keys(companyEmailsSet)) {\n    delete companyEmailsSet[key];\n  }\n}\n\n// Phone validation (from Prepare Contact Update)\nfunction validatePhone(phone) {\n  if (!phone) return null;\n  if (typeof phone === 'object' && phone !== null) {\n    phone = phone.sanitized_number || phone.raw_number || phone.number || '';\n  }\n  let cleaned = phone.toString().trim().replace(/[^\\d]/g, '');\n  if (!cleaned || cleaned.length === 0) return null;\n  if (cleaned.length === 11 && cleaned.startsWith('1')) { /* ok */ }\n  else if (cleaned.length === 10) { cleaned = '1' + cleaned; }\n  else if (cleaned.length < 10) { return null; }\n  else if (cleaned.length > 11 && cleaned.length <= 15) {\n    if (cleaned.startsWith('1')) return null;\n    return '+' + cleaned;\n  }\n  else if (cleaned.length > 15) { return null; }\n  const areaCode = cleaned.substring(1, 4);\n  if (areaCode.startsWith('0') || areaCode.startsWith('1')) return null;\n  return '+' + cleaned;\n}\n\n// Role-based email detection\nconst rolePatterns = [\n  /^info@/i, /^contact@/i, /^hello@/i, /^support@/i, /^sales@/i,\n  /^office@/i, /^billing@/i, /^reception@/i, /^frontdesk@/i, /^front\\.desk@/i,\n  /^appointments@/i, /^booking@/i, /^bookings@/i, /^schedule@/i, /^scheduling@/i,\n  /^inquiries@/i, /^inquiry@/i, /^general@/i, /^team@/i, /^staff@/i\n];\n\nfunction isRoleBased(email) {\n  if (!email) return false;\n  return rolePatterns.some(p => p.test(email));\n}\n\nconst freeWebmailDomains = [\n  'gmail.com', 'yahoo.com', 'outlook.com', 'hotmail.com', 'aol.com',\n  'icloud.com', 'me.com', 'mac.com', 'live.com', 'msn.com',\n  'protonmail.com', 'proton.me', 'zoho.com', 'yandex.com',\n  'mail.com', 'gmx.com', 'fastmail.com', 'tutanota.com'\n];\n\nfunction isFreeWebmail(email) {\n  if (!email) return false;\n  const domain = email.split('@')[1];\n  return freeWebmailDomains.includes(domain);\n}\n\n// Helper: verify an email via Hunter Verifier API\nasync function verifyEmail(email) {\n  try {\n    const verifyUrl = `https://api.hunter.io/v2/email-verifier?email=${encodeURIComponent(email)}&api_key=${$env.HUNTER_API_KEY}`;\n    const verifyResp = await this.helpers.httpRequest({ method: 'GET', url: verifyUrl, headers: { 'Accept': 'application/json' }, json: true });\n    const vBody = verifyResp.data || verifyResp;\n    if (vBody && vBody.status) {\n      let status;\n      switch (vBody.status) {\n        case 'valid': status = 'verified'; break;\n        case 'invalid': status = 'invalid'; break;\n        case 'accept_all': status = 'accept_all'; break;\n        case 'disposable': status = 'invalid'; break;\n        case 'webmail': status = 'verified'; break;\n        default: status = 'risky'; break;\n      }\n      return { status, score: vBody.score || null, verified_at: new Date().toISOString() };\n    }\n  } catch(e) {\n    console.log(`Verifier error for ${email}: ${e.message}`);\n  }\n  return null;\n}\n\n// Helper: verify a phone number via Telnyx Number Lookup API\nasync function verifyPhone(phoneNumber) {\n  try {\n    const resp = await this.helpers.httpRequest({\n      method: 'GET',\n      url: `https://api.telnyx.com/v2/number_lookup/${encodeURIComponent(phoneNumber)}?type=carrier`,\n      headers: {\n        'Authorization': `Bearer ${$env.TELNYX_API_KEY}`,\n        'Accept': 'application/json'\n      },\n      json: true\n    });\n    const data = resp.data || resp;\n    if (data && data.valid === false) {\n      return { phone_status: 'invalid', phone_line_type: null, phone_carrier: null };\n    }\n    let lineType = null;\n    const carrierType = (data.carrier && data.carrier.type) || null;\n    if (carrierType) {\n      const typeMap = { 'mobile': 'mobile', 'landline': 'landline', 'fixed line': 'landline', 'voip': 'voip', 'toll free': 'toll_free', 'toll_free': 'toll_free' };\n      lineType = typeMap[carrierType.toLowerCase()] || null;\n    }\n    const carrierName = (data.carrier && data.carrier.name) || null;\n    const phoneStatus = lineType === 'voip' ? 'voip' : 'valid';\n    return {\n      phone_status: phoneStatus,\n      phone_line_type: lineType,\n      phone_carrier: carrierName\n    };\n  } catch(e) {\n    if (e.statusCode === 404 || e.statusCode === 422) {\n      return { phone_status: 'invalid', phone_line_type: null, phone_carrier: null };\n    }\n    console.log(`Telnyx error for ${phoneNumber}: ${e.message} (status: ${e.statusCode || 'unknown'})`);\n    return { phone_status: null, phone_line_type: null, phone_carrier: null, _error: `${e.statusCode || 'unknown'}: ${e.message}` };\n  }\n}\n\nfor (const item of contacts) {\n  const contact = { ...item.json };\n\n  // Initialize enrichment fields\n  contact._hunter_email = null;\n  contact._hunter_score = 0;\n  contact._hunter_linkedin = null;\n  contact._hunter_phone = null;\n  contact._snovio_email = null;\n  contact._email_source = null;\n  contact._best_email = contact.email_business || null;\n  contact._best_phone = contact.phone_direct || contact._company_phone || null;\n  contact._best_linkedin = contact.linkedin_url || null;\n  contact._email_status = null;\n  contact._email_verified_at = null;\n  contact._verifier_score = null;\n  contact._cultural_affinity = contact.cultural_affinity || null;\n  contact._namsor_country = null;\n  contact._namsor_region = null;\n  contact._namsor_probability = null;\n  contact._company_email_routed = false;\n  contact._company_email_verified = false;\n  contact._phone_status = null;\n  contact._phone_line_type = null;\n  contact._phone_carrier = null;\n  contact._company_phone_verified = false;\n  contact._phone_error = null;\n\n  const needsEmail = !contact.email_business;\n  const hasDomainAndName = contact._company_domain && contact.first_name;\n  const verifiedStatuses = ['verified', 'invalid', 'risky', 'accept_all'];\n  const emailNeedsVerification = contact.email_business && !verifiedStatuses.includes(contact.email_status);\n\n  // EMAIL WATERFALL\n\n  if (needsEmail && hasDomainAndName) {\n    // --- HUNTER EMAIL FINDER ---\n    if (config.skip_hunter !== 'true') {\n      try {\n        const hunterUrl = `https://api.hunter.io/v2/email-finder?domain=${encodeURIComponent(contact._company_domain)}&first_name=${encodeURIComponent(contact.first_name)}&last_name=${encodeURIComponent(contact.last_name || '')}&api_key=${$env.HUNTER_API_KEY}`;\n        const hunterResp = await this.helpers.httpRequest({ method: 'GET', url: hunterUrl, headers: { 'Accept': 'application/json' }, json: true });\n        const hData = hunterResp.data || hunterResp;\n        if (hData && hData.email && (hData.score === undefined || hData.score >= 50)) {\n          contact._hunter_email = hData.email;\n          contact._hunter_score = hData.score || 0;\n          contact._hunter_linkedin = hData.linkedin_url || null;\n          contact._hunter_phone = hData.phone_number || null;\n          contact._email_source = 'hunter';\n        }\n        await delay(200);\n      } catch(e) {\n        console.log(`Hunter error for ${contact.first_name}: ${e.message}`);\n      }\n    }\n\n    // --- SNOV.IO EMAIL FINDER (fallback) ---\n    if (!contact._hunter_email && config.skip_snovio !== 'true') {\n      try {\n        const snovResp = await this.helpers.httpRequest({\n          method: 'POST',\n          url: 'https://api.snov.io/v1/get-emails-from-names',\n          headers: { 'Content-Type': 'application/json' },\n          body: {\n            firstName: contact.first_name,\n            lastName: contact.last_name || '',\n            domain: contact._company_domain\n          },\n          json: true\n        });\n        const emails = snovResp.emails || snovResp.data?.emails || [];\n        if (Array.isArray(emails) && emails.length > 0) {\n          const valid = emails.find(e => e.emailStatus === 'valid' || e.status === 'valid') || emails[0];\n          contact._snovio_email = valid.email || valid.value || null;\n          if (contact._snovio_email) contact._email_source = 'snovio';\n        }\n        await delay(500);\n      } catch(e) {\n        console.log(`Snov.io error for ${contact.first_name}: ${e.message}`);\n      }\n    }\n\n    contact._best_email = contact._hunter_email || contact._snovio_email || null;\n    contact._best_phone = contact.phone_direct || contact._hunter_phone || contact._company_phone || null;\n    contact._best_linkedin = contact.linkedin_url || contact._hunter_linkedin || null;\n  } else if (contact.email_business) {\n    contact._best_email = contact.email_business;\n    contact._email_source = 'existing';\n  }\n\n  // COMPANY EMAIL ROUTING\n  if (contact._best_email && isRoleBased(contact._best_email) && !isFreeWebmail(contact._best_email)) {\n    const companyId = contact.company_id;\n    const companyHasEmail = !!(contact._company_email);\n\n    if (!companyHasEmail && !companyEmailsSet[companyId]) {\n      contact._routed_company_email = contact._best_email;\n      contact._company_email_routed = true;\n      companyEmailsSet[companyId] = contact._best_email;\n      console.log(`Routed role-based email ${contact._best_email} to company ${contact._company_name || companyId}`);\n    }\n\n    if (contact.email_personal) {\n      contact._best_email = contact.email_personal;\n      contact._email_source = 'personal_promoted';\n      console.log(`Promoted personal email ${contact.email_personal} for ${contact.first_name} (role-based went to company)`);\n    }\n  }\n\n  // EMAIL VERIFICATION (contact email)\n  if (contact._best_email && config.skip_hunter_verifier !== 'true') {\n    const shouldVerify = !contact.email_business || emailNeedsVerification || contact._email_source === 'hunter' || contact._email_source === 'snovio' || contact._email_source === 'personal_promoted';\n    if (shouldVerify) {\n      const vResult = await verifyEmail.call(this, contact._best_email);\n      if (vResult) {\n        contact._email_status = vResult.status;\n        contact._email_verified_at = vResult.verified_at;\n        contact._verifier_score = vResult.score;\n      }\n      await delay(700);\n    }\n  } else if (contact._best_email) {\n    contact._email_status = 'unverified';\n  }\n\n  // COMPANY EMAIL VERIFICATION\n  const companyEmailToVerify = contact._routed_company_email || contact._company_email;\n  const companyEmailNeedsVerification = companyEmailToVerify && !contact._company_email_status;\n  const companyId = contact.company_id;\n\n  if (companyEmailNeedsVerification && config.skip_hunter_verifier !== 'true' && !companyEmailsSet[companyId + '_verified']) {\n    const vResult = await verifyEmail.call(this, companyEmailToVerify);\n    let companyPatch = {};\n\n    if (contact._routed_company_email) {\n      companyPatch.email = contact._routed_company_email;\n    }\n\n    if (vResult) {\n      companyPatch.email_status = vResult.status;\n      contact._company_email_verified = true;\n      console.log(`Verified company email ${companyEmailToVerify}: ${vResult.status}`);\n    }\n\n    if (Object.keys(companyPatch).length > 0) {\n      try {\n        await this.helpers.httpRequest({\n          method: 'PATCH',\n          url: `${supabaseUrl}/rest/v1/companies?id=eq.${companyId}`,\n          headers: {\n            'apikey': supabaseKey,\n            'Authorization': `Bearer ${supabaseKey}`,\n            'Content-Type': 'application/json',\n            'Prefer': 'return=minimal'\n          },\n          body: companyPatch,\n          json: true\n        });\n        console.log(`PATCHed company ${contact._company_name || companyId}: ${JSON.stringify(companyPatch)}`);\n      } catch(e) {\n        console.log(`Company PATCH error for ${companyId}: ${e.message}`);\n      }\n    }\n\n    companyEmailsSet[companyId + '_verified'] = true;\n    await delay(700);\n  } else if (contact._routed_company_email && !companyEmailsSet[companyId + '_verified']) {\n    try {\n      await this.helpers.httpRequest({\n        method: 'PATCH',\n        url: `${supabaseUrl}/rest/v1/companies?id=eq.${companyId}`,\n        headers: {\n          'apikey': supabaseKey,\n          'Authorization': `Bearer ${supabaseKey}`,\n          'Content-Type': 'application/json',\n          'Prefer': 'return=minimal'\n        },\n        body: { email: contact._routed_company_email },\n        json: true\n      });\n      console.log(`PATCHed company email (unverified) ${contact._company_name || companyId}: ${contact._routed_company_email}`);\n    } catch(e) {\n      console.log(`Company PATCH error for ${companyId}: ${e.message}`);\n    }\n    companyEmailsSet[companyId + '_verified'] = true;\n    await delay(50);\n  }\n\n  // NAMSOR CULTURAL AFFINITY\n  if (!contact.cultural_affinity && contact.first_name && config.skip_namsor !== 'true') {\n    try {\n      const namsorUrl = `https://v2.namsor.com/NamSorAPIv2/api2/json/origin/${encodeURIComponent(contact.first_name)}/${encodeURIComponent(contact.last_name || 'Unknown')}`;\n      const namsorResp = await this.helpers.httpRequest({ method: 'GET', url: namsorUrl, headers: { 'X-API-KEY': $env.NAMSOR_API_KEY, 'Accept': 'application/json' }, json: true });\n      if (namsorResp && namsorResp.countryOrigin) {\n        const parts = [];\n        if (namsorResp.regionOrigin) parts.push(namsorResp.regionOrigin);\n        if (namsorResp.subRegionOrigin && namsorResp.subRegionOrigin !== namsorResp.regionOrigin) parts.push(namsorResp.subRegionOrigin);\n        if (namsorResp.countryOrigin) parts.push(namsorResp.countryOrigin);\n        contact._cultural_affinity = parts.join(' / ');\n        if (namsorResp.probabilityCalibrated && namsorResp.probabilityCalibrated < 0.3) {\n          contact._cultural_affinity += ' (low confidence)';\n        }\n        contact._namsor_country = namsorResp.countryOrigin;\n        contact._namsor_region = namsorResp.regionOrigin;\n        contact._namsor_probability = namsorResp.probabilityCalibrated;\n      }\n      await delay(100);\n    } catch(e) {\n      console.log(`NamSor error for ${contact.first_name}: ${e.message}`);\n    }\n  }\n\n  // PHONE VERIFICATION (Telnyx Number Lookup)\n  if (contact._best_phone && !contact.phone_status && config.skip_phone_verifier !== 'true') {\n    const phoneResult = await verifyPhone.call(this, contact._best_phone);\n    if (phoneResult) {\n      contact._phone_status = phoneResult.phone_status;\n      contact._phone_line_type = phoneResult.phone_line_type;\n      contact._phone_carrier = phoneResult.phone_carrier;\n      if (phoneResult._error) {\n        contact._phone_error = phoneResult._error;\n      } else {\n        console.log(`Phone verified ${contact._best_phone}: ${phoneResult.phone_status} (${phoneResult.phone_line_type || 'unknown type'}, ${phoneResult.phone_carrier || 'unknown carrier'})`);\n      }\n    }\n    await delay(100);\n  }\n\n  // COMPANY PHONE VERIFICATION (Telnyx)\n  if (contact._company_phone && !contact._company_phone_status && config.skip_phone_verifier !== 'true' && !companyEmailsSet[companyId + '_phone_verified']) {\n    const compPhoneResult = await verifyPhone.call(this, contact._company_phone);\n    if (compPhoneResult && !compPhoneResult._error) {\n      try {\n        await this.helpers.httpRequest({\n          method: 'PATCH',\n          url: `${supabaseUrl}/rest/v1/companies?id=eq.${companyId}`,\n          headers: {\n            'apikey': supabaseKey,\n            'Authorization': `Bearer ${supabaseKey}`,\n            'Content-Type': 'application/json',\n            'Prefer': 'return=minimal'\n          },\n          body: {\n            phone_status: compPhoneResult.phone_status,\n            phone_line_type: compPhoneResult.phone_line_type\n          },\n          json: true\n        });\n        contact._company_phone_verified = true;\n        console.log(`Company phone verified ${contact._company_phone}: ${compPhoneResult.phone_status} (${compPhoneResult.phone_line_type || 'unknown'})`);\n      } catch(e) {\n        console.log(`Company phone PATCH error for ${companyId}: ${e.message}`);\n      }\n    } else if (compPhoneResult && compPhoneResult._error) {\n      contact._phone_error = contact._phone_error || compPhoneResult._error;\n    }\n    companyEmailsSet[companyId + '_phone_verified'] = true;\n    await delay(100);\n  }\n\n  // BUILD UPDATE PAYLOAD\n  const update = {};\n  if (contact._best_email && !contact.email_business) {\n    update.email_business = contact._best_email;\n  }\n  if (contact._email_status && contact._email_status !== 'unverified') {\n    update.email_status = contact._email_status;\n    update.email_verified_at = contact._email_verified_at;\n    if (contact._email_status === 'invalid') {\n      update.email_business = null;\n    }\n  } else if (contact._best_email || contact.email_business) {\n    update.email_status = 'unverified';\n  }\n\n  const newPhone = validatePhone(contact._best_phone);\n  if (newPhone && !contact.phone_direct) update.phone_direct = newPhone;\n  if (contact._best_linkedin && !contact.linkedin_url) update.linkedin_url = contact._best_linkedin;\n  if (contact._cultural_affinity && !contact.cultural_affinity) update.cultural_affinity = contact._cultural_affinity;\n\n  // Phone verification fields\n  if (contact._phone_status) {\n    update.phone_status = contact._phone_status;\n    update.phone_verified_at = new Date().toISOString();\n    update.phone_line_type = contact._phone_line_type;\n    update.phone_carrier = contact._phone_carrier;\n    if (contact._phone_status === 'invalid' || contact._phone_status === 'disconnected') {\n      update.phone_direct = null;\n    }\n  }\n\n  contact._update_payload = Object.keys(update).length > 0 ? update : null;\n  contact._has_updates = Object.keys(update).length > 0;\n\n  // SUPABASE UPDATE (inline)\n  if (contact._has_updates) {\n    try {\n      await this.helpers.httpRequest({\n        method: 'PATCH',\n        url: `${supabaseUrl}/rest/v1/contacts?id=eq.${contact.id}`,\n        headers: {\n          'apikey': supabaseKey,\n          'Authorization': `Bearer ${supabaseKey}`,\n          'Content-Type': 'application/json',\n          'Prefer': 'return=minimal'\n        },\n        body: update,\n        json: true\n      });\n      console.log(`Updated ${contact.first_name} ${contact.last_name || ''}: ${JSON.stringify(update)}`);\n    } catch(e) {\n      console.log(`Supabase update error for ${contact.id}: ${e.message}`);\n      contact._update_error = e.message;\n    }\n    await delay(50);\n  }\n\n  results.push({\n    json: {\n      _contact_id: contact.id,\n      _company_id: contact.company_id,\n      _first_name: contact.first_name,\n      _last_name: contact.last_name,\n      _company_name: contact._company_name,\n      _update_payload: contact._update_payload,\n      _has_updates: contact._has_updates,\n      _email_source: contact._email_source,\n      _email_status: contact._email_status,\n      _verifier_score: contact._verifier_score,\n      _namsor_country: contact._namsor_country,\n      _namsor_probability: contact._namsor_probability,\n      _company_email_routed: contact._company_email_routed,\n      _company_email_verified: contact._company_email_verified,\n      _routed_company_email: contact._routed_company_email || null,\n      _phone_status: contact._phone_status,\n      _phone_line_type: contact._phone_line_type,\n      _phone_carrier: contact._phone_carrier,\n      _company_phone_verified: contact._company_phone_verified,\n      _phone_error: contact._phone_error,\n      _update_error: contact._update_error || null\n    }\n  });\n}\n\nif (results.length === 0) {\n  return [{ json: { _empty: true, _count: 0, metro, company_ids: companyIds } }];\n}\n\n// Inject metro + company_ids into the first result item so downstream nodes can access them\nif (results.length > 0) {\n  results[0].json.metro = metro;\n  results[0].json.company_ids = companyIds;\n}\n\nreturn results;"
        }
      },
      {
        "id": "sw-mark-enriched-0001",
        "name": "Mark Fully Enriched",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          2500,
          192
        ],
        "parameters": {
          "jsCode": "// Mark Fully Enriched — Final node in sub-workflow batch enrichment chain\n// Mode: runOnceForAllItems\n// Input: results from Enrich Contacts (carries metro + company_ids)\n// Output: confirmation of status update\n//\n// PATCHes all companies in the batch to enrichment_status = 'fully_enriched'.\n\nconst inputData = $input.first().json;\nconst companyIds = inputData.company_ids || [];\nconst metro = inputData.metro || 'unknown';\n\nconst supabaseUrl = $env.SUPABASE_URL;\nconst supabaseKey = $env.SUPABASE_SERVICE_KEY;\n\nif (companyIds.length === 0) {\n  console.log('Mark Fully Enriched: no company IDs in input, skipping');\n  return [{ json: { step: 'mark_fully_enriched', metro, updated: 0 } }];\n}\n\nconsole.log(`Mark Fully Enriched: marking ${companyIds.length} companies as fully_enriched for ${metro}`);\n\ntry {\n  await this.helpers.httpRequest({\n    method: 'PATCH',\n    url: `${supabaseUrl}/rest/v1/companies?id=in.(${companyIds.join(',')})`,\n    headers: {\n      'apikey': supabaseKey,\n      'Authorization': 'Bearer ' + supabaseKey,\n      'Content-Type': 'application/json',\n      'Prefer': 'return=minimal'\n    },\n    body: { enrichment_status: 'fully_enriched' },\n    json: true\n  });\n  console.log(`  Successfully marked ${companyIds.length} companies as fully_enriched`);\n} catch(e) {\n  console.log(`  ERROR marking companies as fully_enriched: ${e.message}`);\n  return [{ json: { step: 'mark_fully_enriched', metro, updated: 0, error: e.message, company_ids: companyIds } }];\n}\n\nreturn [{ json: { step: 'mark_fully_enriched', metro, updated: companyIds.length, company_ids: companyIds } }];\n",
          "mode": "runOnceForAllItems"
        }
      },
      {
        "id": "a4-track-batch-0001",
        "name": "Track Batch Completion",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          3000,
          192
        ],
        "parameters": {
          "jsCode": "// Track Batch Completion - Final node in sub-workflow (after Mark Fully Enriched)\n// Mode: runOnceForAllItems\n// Increments completed_batches atomically. If last batch, marks run as completed.\n// Skips if no run_id (legacy trigger).\n\nconst inputData = $input.first().json;\nconst companyIds = inputData.company_ids || [];\nconst metro = inputData.metro || 'unknown';\n\n// Read run_id from webhook body (sub-workflow receives it via POST from Batch Dispatcher)\nlet runId = null;\ntry {\n  const webhookData = $('Webhook').first().json;\n  const payload = webhookData.body || webhookData;\n  runId = payload.run_id || null;\n} catch(e) {\n  // Webhook reference failed - try from input chain\n  runId = inputData.run_id || null;\n}\n\nif (!runId) {\n  console.log('Track Batch Completion: no run_id, skipping (legacy trigger)');\n  return [{ json: { step: 'track_batch_completion', metro, skipped: true, reason: 'no_run_id' } }];\n}\n\nconst supabaseUrl = $env.SUPABASE_URL;\nconst supabaseKey = $env.SUPABASE_SERVICE_KEY;\nconst sbHeaders = {\n  'apikey': supabaseKey,\n  'Authorization': 'Bearer ' + supabaseKey,\n  'Content-Type': 'application/json'\n};\n\ntry {\n  // Atomically increment completed_batches\n  const result = await this.helpers.httpRequest({\n    method: 'POST',\n    url: `${supabaseUrl}/rest/v1/rpc/increment_completed_batches`,\n    headers: sbHeaders,\n    body: { p_run_id: runId },\n    json: true\n  });\n\n  console.log(`Track Batch Completion: ${metro} batch done - ${JSON.stringify(result)}`);\n\n  if (result && result.is_last_batch) {\n    console.log('Track Batch Completion: LAST BATCH - marking run as completed');\n\n    // Query totals for this metro\n    let totalDiscovered = 0;\n    let contactsFound = 0;\n    try {\n      const companies = await this.helpers.httpRequest({\n        method: 'GET',\n        url: `${supabaseUrl}/rest/v1/companies?discovery_metro=eq.${encodeURIComponent(metro)}&select=id`,\n        headers: { 'apikey': supabaseKey, 'Authorization': 'Bearer ' + supabaseKey },\n        json: true\n      });\n      totalDiscovered = Array.isArray(companies) ? companies.length : 0;\n\n      // Count contacts for companies in this metro\n      const companyIdsStr = (Array.isArray(companies) ? companies : []).map(c => c.id).join(',');\n      if (companyIdsStr) {\n        const contacts = await this.helpers.httpRequest({\n          method: 'GET',\n          url: `${supabaseUrl}/rest/v1/contacts?company_id=in.(${companyIdsStr})&select=id`,\n          headers: { 'apikey': supabaseKey, 'Authorization': 'Bearer ' + supabaseKey },\n          json: true\n        });\n        contactsFound = Array.isArray(contacts) ? contacts.length : 0;\n      }\n    } catch(e) {\n      console.log(`  WARNING: Failed to query totals: ${e.message}`);\n    }\n\n    // Mark run as completed\n    try {\n      await this.helpers.httpRequest({\n        method: 'PATCH',\n        url: `${supabaseUrl}/rest/v1/pipeline_runs?id=eq.${runId}`,\n        headers: { ...sbHeaders, 'Prefer': 'return=minimal' },\n        body: {\n          status: 'completed',\n          completed_at: new Date().toISOString(),\n          total_discovered: totalDiscovered,\n          contacts_found: contactsFound\n        },\n        json: true\n      });\n      console.log(`Track Batch Completion: pipeline_runs ${runId} -> completed (${totalDiscovered} companies, ${contactsFound} contacts)`);\n    } catch(e) {\n      console.log(`  WARNING: Failed to mark run as completed: ${e.message}`);\n    }\n  }\n\n  return [{ json: {\n    step: 'track_batch_completion',\n    metro,\n    run_id: runId,\n    completed_batches: result ? result.completed_batches : null,\n    total_batches: result ? result.total_batches : null,\n    is_last_batch: result ? result.is_last_batch : false,\n    companies_in_batch: companyIds.length\n  }}];\n\n} catch(e) {\n  console.log(`Track Batch Completion: ERROR - ${e.message}`);\n  // Non-blocking - enrichment succeeded even if tracking fails\n  return [{ json: { step: 'track_batch_completion', metro, run_id: runId, error: e.message } }];\n}"
        }
      }
    ],
    "connections": {
      "Webhook": {
        "main": [
          [
            {
              "node": "Respond to Webhook",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Respond to Webhook": {
        "main": [
          [
            {
              "node": "Enrich Companies",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Enrich Companies": {
        "main": [
          [
            {
              "node": "Find Contacts",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Find Contacts": {
        "main": [
          [
            {
              "node": "Enrich Contacts",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Enrich Contacts": {
        "main": [
          [
            {
              "node": "Mark Fully Enriched",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Mark Fully Enriched": {
        "main": [
          [
            {
              "node": "Track Batch Completion",
              "type": "main",
              "index": 0
            }
          ]
        ]
      }
    },
    "authors": "Phillip Schuman",
    "name": null,
    "description": null,
    "autosaved": false,
    "workflowPublishHistory": [
      {
        "createdAt": "2026-02-21T18:15:05.088Z",
        "id": 118,
        "workflowId": "fGm4IP0rWxgHptN8",
        "versionId": "b845ef7e-d863-4744-9084-55ad343d0c80",
        "event": "activated",
        "userId": "a0f6ea10-aac2-4dd7-a7bc-df1184531a06"
      }
    ]
  }
}