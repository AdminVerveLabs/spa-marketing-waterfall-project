{
  "updatedAt": "2026-02-20T06:02:50.861Z",
  "createdAt": "2026-02-18T03:19:26.158Z",
  "id": "yxvQst30sWlNIeZq",
  "name": "Step 4 (isolated) - FIXED - Linear Enrichment",
  "description": null,
  "active": true,
  "isArchived": false,
  "nodes": [
    {
      "parameters": {
        "jsCode": "const config = $input.first().json;\nconst queries = config.search_queries.split(',').map(q => q.trim());\nreturn queries.map(query => ({\n  json: {\n    query,\n    latitude: config.latitude,\n    longitude: config.longitude,\n    radius_meters: config.radius_meters,\n    metro_name: config.metro_name,\n    yelp_location: config.yelp_location\n  }\n}));"
      },
      "id": "3bbcf320-b713-415a-aca4-1f8fd1e54409",
      "name": "Split Search Queries",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -10736,
        192
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://places.googleapis.com/v1/places:searchText",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "X-Goog-FieldMask",
              "value": "places.id,places.displayName,places.formattedAddress,places.nationalPhoneNumber,places.internationalPhoneNumber,places.websiteUri,places.googleMapsUri,places.rating,places.userRatingCount,places.primaryType,places.primaryTypeDisplayName,places.addressComponents,nextPageToken"
            },
            {
              "name": "X-Goog-Api-Key",
              "value": "={{ $env.GOOGLE_PLACES_API_KEY }}"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"textQuery\": \"{{ $json.query }}\",\n  \"locationBias\": {\n    \"circle\": {\n      \"center\": {\n        \"latitude\": {{ $json.latitude }},\n        \"longitude\": {{ $json.longitude }}\n      },\n      \"radius\": {{ $json.radius_meters }}\n    }\n  },\n  \"maxResultCount\": 20\n}",
        "options": {}
      },
      "id": "ecf3e8c2-15ac-4259-8944-94009fae0e13",
      "name": "Google Places - Text Search",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -9168,
        48
      ],
      "notes": "Google Places API (v1). Needs HTTP Header Auth credential: name='X-Goog-Api-Key', value=your API key."
    },
    {
      "parameters": {
        "jsCode": "const allInputs = JSON.parse(JSON.stringify($input.all().map(i => i.json)));\nconst allPlaces = [];\n\nfor (const input of allInputs) {\n  const places = input.places || [];\n  const q = input.query || '';\n  places.forEach(p => { p._query = q; });\n  allPlaces.push(...places);\n}\n\nconst metro = JSON.parse(JSON.stringify($('Metro Config').first().json)).metro_name;\n\n// Booking platform domain blocklist\nconst BLOCKED_DOMAINS = ['wixsite.com','wix.com','setmore.com','schedulista.com','glossgenius.com','square.site','genbook.com','jane.app','acuityscheduling.com','mindbodyonline.com','mindbody.io','vagaro.com','fresha.com','schedulicity.com','booksy.com','massagebook.com','noterro.com','clinicsense.com','calendly.com','squarespace.com'];\n// Business type blocklist - filter non-target businesses before Supabase insert\nconst BUSINESS_TYPE_BLOCKLIST = ['school','college','university','association','federation','union','board of','institute','academy','program'];\n\n\nreturn allPlaces.map(place => {\n  // Business type filter - skip non-target businesses\n  const _bizName = (place.displayName && place.displayName.text) || '';\n  const _bizCategory = (place.primaryTypeDisplayName && place.primaryTypeDisplayName.text) || place.primaryType || '';\n  const _bizNameLower = _bizName.toLowerCase();\n  const _bizCatLower = _bizCategory.toLowerCase();\n  if (BUSINESS_TYPE_BLOCKLIST.some(kw => _bizNameLower.includes(kw) || _bizCatLower.includes(kw))) return null;\n\n  let city = '', state = '', country = '';\n  if (place.addressComponents) {\n    for (const comp of place.addressComponents) {\n      if (comp.types && comp.types.includes('locality')) city = comp.longText || '';\n      if (comp.types && comp.types.includes('administrative_area_level_1')) state = comp.shortText || '';\n      if (comp.types && comp.types.includes('country')) country = comp.shortText || '';\n    }\n  }\n\n  let phone = place.internationalPhoneNumber || place.nationalPhoneNumber || '';\n  let phoneNormalized = phone.replace(/[^\\d+]/g, '');\n  if (phoneNormalized && !phoneNormalized.startsWith('+')) {\n    phoneNormalized = '+1' + phoneNormalized.replace(/^1/, '');\n  }\n\n  const website = place.websiteUri || '';\n  let domain = '';\n  if (website) {\n    const match = website.match(/^https?:\\/\\/(?:www\\.)?([^\\/]+)/i);\n    if (match) domain = match[1];\n  }\n\n  // Check domain against blocklist\n  let _domain_blocked = false;\n  let _domain_blocked_platform = '';\n  if (domain) {\n    const lowerDomain = domain.toLowerCase();\n    for (const blocked of BLOCKED_DOMAINS) {\n      if (lowerDomain === blocked || lowerDomain.endsWith('.' + blocked)) {\n        _domain_blocked = true;\n        _domain_blocked_platform = blocked;\n        domain = '';\n        break;\n      }\n    }\n  }\n\n  return {\n    json: {\n      name: (place.displayName && place.displayName.text) || '',\n      phone: phoneNormalized,\n      domain: domain,\n      address: place.formattedAddress || '',\n      city, state, country: country || 'US',\n      google_place_id: place.id || '',\n      category: (place.primaryTypeDisplayName && place.primaryTypeDisplayName.text) || place.primaryType || '',\n      google_rating: place.rating || null,\n      google_review_count: place.userRatingCount || 0,\n      has_website: _domain_blocked ? false : !!website,\n      google_maps_url: place.googleMapsUri || '',\n      source_urls: [{source: 'google_places', url: place.googleMapsUri || '', query_used: place._query || ''}],\n      discovery_metro: metro,\n      discovery_source: 'google_places',\n      _domain_blocked,\n      _domain_blocked_platform\n    }\n  };\n}).filter(Boolean);"
      },
      "id": "a9c14e44-5d37-4994-8a7a-b9283a47f5fe",
      "name": "Normalize Google Results",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -8944,
        48
      ]
    },
    {
      "parameters": {},
      "id": "8fcec5c5-45b7-4b87-b2cb-a32c6d692aab",
      "name": "Merge All Sources",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3,
      "position": [
        -8720,
        192
      ]
    },
    {
      "parameters": {
        "jsCode": "const items = $input.all().map(i => i.json);\nconst canonical = [];\nconst phoneIndex = {};\nconst domainIndex = {};\n\nfunction normalizePhone(p) { return (p || '').replace(/[^\\d+]/g, ''); }\nfunction normalizeDomain(d) { return (d || '').toLowerCase().replace(/^www\\./, '').trim(); }\nfunction normalizeName(n) { return (n || '').toLowerCase().replace(/[^a-z0-9\\s]/g, '').trim(); }\nfunction nameSimilarity(a, b) {\n  const setA = new Set(normalizeName(a).split(/\\s+/));\n  const setB = new Set(normalizeName(b).split(/\\s+/));\n  const intersection = new Set([...setA].filter(x => setB.has(x)));\n  const union = new Set([...setA, ...setB]);\n  return union.size === 0 ? 0 : intersection.size / union.size;\n}\n\nfor (const item of items) {\n  const phone = normalizePhone(item.phone);\n  const domain = normalizeDomain(item.domain);\n  const city = (item.city || '').toLowerCase();\n  let matched = false;\n\n  if (phone && phone.length >= 10 && phoneIndex[phone] !== undefined) {\n    const existing = canonical[phoneIndex[phone]];\n    existing.source_urls = [...(existing.source_urls || []), ...(item.source_urls || [])];\n    if (!existing.domain && item.domain) existing.domain = item.domain;\n    if (!existing.google_place_id && item.google_place_id) existing.google_place_id = item.google_place_id;\n    if (!existing.has_website && item.has_website) existing.has_website = item.has_website;\n    if (item.google_rating) existing.google_rating = item.google_rating;\n    if (item.google_review_count) existing.google_review_count = item.google_review_count;\n    if (item.yelp_rating) existing.yelp_rating = item.yelp_rating;\n    if (item.yelp_review_count) existing.yelp_review_count = item.yelp_review_count;\n    if (item.yelp_url) existing.yelp_url = item.yelp_url;\n    matched = true;\n  }\n\n  if (!matched && domain && domainIndex[domain] !== undefined) {\n    const existing = canonical[domainIndex[domain]];\n    existing.source_urls = [...(existing.source_urls || []), ...(item.source_urls || [])];\n    if (!existing.phone && item.phone) existing.phone = item.phone;\n    if (!existing.google_place_id && item.google_place_id) existing.google_place_id = item.google_place_id;\n    if (item.google_rating) existing.google_rating = item.google_rating;\n    if (item.google_review_count) existing.google_review_count = item.google_review_count;\n    if (item.yelp_rating) existing.yelp_rating = item.yelp_rating;\n    if (item.yelp_review_count) existing.yelp_review_count = item.yelp_review_count;\n    if (item.yelp_url) existing.yelp_url = item.yelp_url;\n    matched = true;\n  }\n\n  if (!matched) {\n    let fuzzyMatch = false;\n    for (let i = 0; i < canonical.length; i++) {\n      const existing = canonical[i];\n      if ((existing.city || '').toLowerCase() === city && city !== '') {\n        if (nameSimilarity(existing.name, item.name) >= 0.85) {\n          existing.source_urls = [...(existing.source_urls || []), ...(item.source_urls || [])];\n          existing._fuzzy_match_flag = true;\n          existing._fuzzy_match_names = [...(existing._fuzzy_match_names || [existing.name]), item.name];\n          fuzzyMatch = true;\n          break;\n        }\n      }\n    }\n    if (!fuzzyMatch) {\n      const idx = canonical.length;\n      canonical.push({...item});\n      if (phone && phone.length >= 10) phoneIndex[phone] = idx;\n      if (domain) domainIndex[domain] = idx;\n    }\n  }\n}\n\nconsole.log('Dedup:', items.length, 'raw ->', canonical.length, 'unique,', canonical.filter(c => c._fuzzy_match_flag).length, 'fuzzy flagged');\nreturn canonical.map(item => ({ json: item }));"
      },
      "id": "50caf015-dd4e-4183-8124-b35fddffa354",
      "name": "Deduplicate Records",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -8496,
        192
      ]
    },
    {
      "parameters": {
        "jsCode": "const now = new Date().toISOString();\nreturn $input.all().map(item => {\n  const r = item.json;\n  return { json: {\n    name: r.name, phone: r.phone || null, domain: r.domain || null,\n    address: r.address || null, city: r.city || null, state: r.state || null,\n    country: r.country || 'US', google_place_id: r.google_place_id || null,\n    category: r.category || null, has_website: r.has_website || false,\n    has_online_booking: false, booking_platform: null, has_paid_ads: false,\n    on_groupon: false,\n    on_yelp: (r.source_urls || []).some(s => s.source === 'yelp_apify'),\n    google_review_count: r.google_review_count || 0,\n    google_rating: r.google_rating || null,\n    estimated_size: null, source_urls: r.source_urls || [],\n    enrichment_status: r._fuzzy_match_flag ? 'needs_review' : 'discovered',\n    lead_score: 0, discovered_at: now, enriched_at: null,\n    discovery_metro: r.discovery_metro || null,\n    _fuzzy_match_flag: r._fuzzy_match_flag || false\n  }};\n});"
      },
      "id": "59bd4554-e739-4428-bd72-53b502f85f61",
      "name": "Prepare for Supabase",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -8272,
        192
      ]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "fuzzy-check",
              "leftValue": "={{ $json._fuzzy_match_flag }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "21269bb4-ab43-49df-94ec-17640d94777d",
      "name": "Fuzzy Match?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        -8048,
        192
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $env.SUPABASE_URL }}/rest/v1/companies?on_conflict=google_place_id",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "apikey",
              "value": "={{ $env.SUPABASE_SERVICE_KEY }}"
            },
            {
              "name": "Authorization",
              "value": "=Bearer {{ $env.SUPABASE_SERVICE_KEY }}"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            },
            {
              "name": "Prefer",
              "value": "resolution=merge-duplicates"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({ name: $json.name, phone: $json.phone, domain: $json.domain, address: $json.address, city: $json.city, state: $json.state, country: $json.country, google_place_id: $json.google_place_id, category: $json.category, has_website: $json.has_website, source_urls: $json.source_urls, discovery_metro: $json.discovery_metro, enrichment_status: 'discovered', discovered_at: new Date().toISOString() }) }}",
        "options": {
          "batching": {
            "batch": {}
          }
        }
      },
      "id": "f4cdac90-eda5-4c9c-8e3e-aa2f04cf45ab",
      "name": "Insert to Supabase",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -7824,
        288
      ],
      "alwaysOutputData": true,
      "onError": "continueRegularOutput",
      "notes": "Clean records. Uses service_role key (bypasses RLS)."
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $env.SUPABASE_URL }}/rest/v1/companies?on_conflict=google_place_id",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "apikey",
              "value": "={{ $env.SUPABASE_SERVICE_KEY }}"
            },
            {
              "name": "Authorization",
              "value": "=Bearer {{ $env.SUPABASE_SERVICE_KEY }}"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            },
            {
              "name": "Prefer",
              "value": "resolution=merge-duplicates"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({ name: $json.name, phone: $json.phone, domain: $json.domain, address: $json.address, city: $json.city, state: $json.state, country: $json.country, google_place_id: $json.google_place_id, category: $json.category, has_website: $json.has_website, source_urls: $json.source_urls, discovery_metro: $json.discovery_metro, enrichment_status: 'needs_review', discovered_at: new Date().toISOString() }) }}",
        "options": {}
      },
      "id": "6014b12d-87d3-45bc-9a6c-678a3c1031a2",
      "name": "Insert Flagged (Needs Review)",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -7824,
        96
      ],
      "notes": "Fuzzy-matched records. Status = needs_review for manual dedup.",
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "jsCode": "const allItems = $('Deduplicate Records').all();\nconst metro = $('Metro Config').first().json.metro_name;\nconst fromGoogle = allItems.filter(i => (i.json.source_urls || []).some(s => s.source === 'google_places')).length;\nconst fromYelp = allItems.filter(i => (i.json.source_urls || []).some(s => s.source === 'yelp_apify')).length;\nconst bothSources = allItems.filter(i => { const s = (i.json.source_urls || []).map(x => x.source); return s.includes('google_places') && s.includes('yelp_apify'); }).length;\nconst fuzzyFlagged = allItems.filter(i => i.json._fuzzy_match_flag).length;\n\nconst summary = {\n  metro, run_timestamp: new Date().toISOString(),\n  total_unique_records: allItems.length,\n  found_on_google: fromGoogle, found_on_yelp: fromYelp, found_on_both: bothSources,\n  flagged_for_review: fuzzyFlagged,\n  clean_records: allItems.length - fuzzyFlagged,\n  sources_used: ['google_places', 'yelp_apify']\n};\nconsole.log('=== DISCOVERY RUN SUMMARY ===');\nconsole.log(JSON.stringify(summary, null, 2));\nreturn [{ json: summary }];"
      },
      "id": "d53e0354-3695-4aaf-948e-92e8bf3e80c4",
      "name": "Run Summary",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -7600,
        192
      ]
    },
    {
      "parameters": {
        "jsCode": "const response = $input.first().json;\nlet runId = '';\nlet datasetId = '';\n\nif (response.data) {\n  runId = response.data.id || '';\n  datasetId = response.data.defaultDatasetId || '';\n}\n\nif (!runId) {\n  throw new Error('Failed to start Apify run. Response: ' + JSON.stringify(response).substring(0, 500));\n}\n\nreturn [{ json: { runId, datasetId, pollCount: 0 } }];"
      },
      "id": "ca8aee6f-7b5b-40b6-8d16-3902dceea5c6",
      "name": "Extract Run ID",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -10288,
        288
      ]
    },
    {
      "parameters": {
        "amount": 20
      },
      "id": "13385ec3-d78d-4bbd-8579-d67fd6d52395",
      "name": "Wait 30s",
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1.1,
      "position": [
        -10064,
        288
      ],
      "webhookId": "58f36f86-6055-45a5-84d5-f71b858202b8"
    },
    {
      "parameters": {
        "url": "=https://api.apify.com/v2/actor-runs/{{ $('Extract Run ID').first().json.runId }}?token={{ $env.APIFY_API_TOKEN }}",
        "options": {
          "timeout": 15000
        }
      },
      "id": "6ce308da-fda1-430e-a1ed-ef0605941bcd",
      "name": "Check Run Status",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -9840,
        224
      ],
      "alwaysOutputData": true,
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "jsCode": "const response = $input.first().json;\nconst prevData = $('Extract Run ID').first().json;\n\nlet status = 'UNKNOWN';\nlet datasetId = prevData.datasetId || '';\n\n// Single run response\nif (response.data && response.data.status && !response.data.items) {\n  status = response.data.status;\n  if (response.data.defaultDatasetId) datasetId = response.data.defaultDatasetId;\n}\n// List response\nelse if (response.data && response.data.items && response.data.items.length > 0) {\n  status = response.data.items[0].status;\n  if (response.data.items[0].defaultDatasetId) datasetId = response.data.items[0].defaultDatasetId;\n}\n\n// Increment poll count from previous Parse Status if looping, otherwise from Extract Run ID\nlet pollCount = 0;\ntry {\n  pollCount = $('Parse Status').first().json.pollCount || 0;\n} catch(e) {\n  pollCount = prevData.pollCount || 0;\n}\npollCount++;\n\nreturn [{ json: { runId: prevData.runId, datasetId, pollCount, status } }];"
      },
      "id": "d7861f94-bfc5-4f69-9f11-b82f2815ba8c",
      "name": "Parse Status",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -9616,
        224
      ]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "succeeded",
              "leftValue": "={{ $json.status }}",
              "rightValue": "SUCCEEDED",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "deb02ddd-d3e5-4f68-a564-a4380714224d",
      "name": "Run Succeeded?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        -9392,
        288
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://api.apify.com/v2/actor-tasks/uplifted_veranda~yelp-scraper-task/runs?token={{ $env.APIFY_API_TOKEN }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"searchTerms\": [\"{{ $json.query }}\"],\n  \"locations\": [\"{{ $json.yelp_location }}\"],\n  \"searchLimit\": 100,\n  \"maxImages\": 0,\n  \"reviewLimit\": 0\n}",
        "options": {
          "timeout": 30000
        }
      },
      "id": "b0bba0ff-f1a6-4e25-bdea-6002b7ed869c",
      "name": "Start Apify Run",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -10512,
        288
      ],
      "alwaysOutputData": true,
      "onError": "continueRegularOutput",
      "notes": "Starts the Apify task. Returns run object with data.id for polling."
    },
    {
      "parameters": {
        "jsCode": "const metro = $('Metro Config').first().json.metro_name;\nconst query = $('Split Search Queries').first().json.query || '';\nconst results = [];\n\n// Booking platform domain blocklist\nconst BLOCKED_DOMAINS = ['wixsite.com','wix.com','setmore.com','schedulista.com','glossgenius.com','square.site','genbook.com','jane.app','acuityscheduling.com','mindbodyonline.com','mindbody.io','vagaro.com','fresha.com','schedulicity.com','booksy.com','massagebook.com','noterro.com','clinicsense.com','calendly.com','squarespace.com'];\n// Business type blocklist - filter non-target businesses before Supabase insert\nconst BUSINESS_TYPE_BLOCKLIST = ['school','college','university','association','federation','union','board of','institute','academy','program'];\n\n\nfor (const item of items) {\n  const biz = item.json;\n  if (!biz.name) continue;\n\n  // Business type filter - skip non-target businesses\n  const _bizNameLower = biz.name.toLowerCase();\n  const _bizCatLower = ((biz.categories || []).join(', ')).toLowerCase();\n  if (BUSINESS_TYPE_BLOCKLIST.some(kw => _bizNameLower.includes(kw) || _bizCatLower.includes(kw))) continue;\n\n  let phone = (biz.phone || '').replace(/[^\\d+]/g, '');\n  if (phone && !phone.startsWith('+')) {\n    phone = '+1' + phone.replace(/^1/, '');\n  }\n\n  let domain = '';\n  if (biz.website) {\n    try {\n      domain = new URL(biz.website.startsWith('http') ? biz.website : 'https://' + biz.website)\n        .hostname.replace(/^www\\./, '');\n    } catch(e) {}\n  }\n\n  // Check domain against blocklist\n  let _domain_blocked = false;\n  let _domain_blocked_platform = '';\n  if (domain) {\n    const lowerDomain = domain.toLowerCase();\n    for (const blocked of BLOCKED_DOMAINS) {\n      if (lowerDomain === blocked || lowerDomain.endsWith('.' + blocked)) {\n        _domain_blocked = true;\n        _domain_blocked_platform = blocked;\n        domain = '';\n        break;\n      }\n    }\n  }\n\n  const addr = biz.address || {};\n  const fullAddress = [addr.addressLine1, addr.addressLine2, addr.addressLine3]\n    .filter(Boolean).join(', ');\n\n  results.push({\n    json: {\n      name: biz.name,\n      phone: phone,\n      domain: domain,\n      address: fullAddress,\n      city: addr.city || '',\n      state: addr.regionCode || '',\n      country: addr.country || 'US',\n      google_place_id: '',\n      category: (biz.categories || []).join(', '),\n      google_rating: null,\n      google_review_count: 0,\n      yelp_rating: biz.aggregatedRating || null,\n      yelp_review_count: biz.reviewCount || 0,\n      has_website: _domain_blocked ? false : !!biz.website,\n      yelp_url: biz.directUrl || '',\n      yelp_is_claimed: biz.claimed || false,\n      yelp_is_advertiser: biz.advertiser || false,\n      source_urls: [{source: 'yelp_apify', url: biz.directUrl || '', query_used: query}],\n      discovery_metro: metro,\n      discovery_source: 'yelp_apify',\n      _domain_blocked,\n      _domain_blocked_platform\n    }\n  });\n}\n\nreturn results.length > 0 ? results : [{ json: { _empty: true } }];"
      },
      "id": "ca715d3a-ef73-4e5b-82cc-2f181555ee2a",
      "name": "Normalize Yelp Results",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -8944,
        288
      ],
      "notes": "After testing, change $('Test Input (Remove After Testing)') to $('Metro Config') and $('Split Search Queries')."
    },
    {
      "parameters": {
        "url": "=https://api.apify.com/v2/datasets/{{ $json.datasetId }}/items?token={{ $env.APIFY_API_TOKEN }}",
        "options": {
          "timeout": 60000
        }
      },
      "id": "78eece76-1e81-4ce4-aef2-637dfd3815be",
      "name": "Fetch Apify Results",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -9168,
        288
      ],
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "batch-size",
              "name": "batch_size",
              "value": "1000",
              "type": "string"
            },
            {
              "id": "batch-offset",
              "name": "batch_offset",
              "value": "0",
              "type": "string"
            },
            {
              "id": "http-timeout",
              "name": "http_timeout_ms",
              "value": "15000",
              "type": "string"
            },
            {
              "id": "skip-google-details",
              "name": "skip_google_details",
              "value": "false",
              "type": "string"
            },
            {
              "id": "skip-social-discovery",
              "name": "skip_social_discovery",
              "value": "true",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "id": "e5d5b057-40c0-4930-bc05-b3bcc0b8f1bb",
      "name": "Enrichment Config",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -7376,
        192
      ],
      "notes": "CONFIGURE: batch_size = how many companies to process per run. batch_offset = starting offset (for resuming). http_timeout_ms = timeout for website fetches. Set skip flags to 'true' to bypass sub-steps."
    },
    {
      "parameters": {
        "url": "={{ $env.SUPABASE_URL }}/rest/v1/companies?enrichment_status=in.(discovered,partially_enriched)&discovery_metro=eq.{{ $('Metro Config').first().json.metro_name }}&order=discovered_at.asc&limit={{ $json.batch_size }}&offset={{ $json.batch_offset }}&select=id,name,phone,domain,address,city,state,country,google_place_id,category,has_website,google_review_count,google_rating,source_urls,on_yelp,on_groupon",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "apikey",
              "value": "={{ $env.SUPABASE_SERVICE_KEY }}"
            },
            {
              "name": "Authorization",
              "value": "=Bearer {{ $env.SUPABASE_SERVICE_KEY }}"
            }
          ]
        },
        "options": {
          "timeout": 30000
        }
      },
      "id": "abaeeae8-e237-4efb-b319-f5234498f039",
      "name": "Fetch Batch from Supabase",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -7152,
        192
      ],
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "jsCode": "// Supabase HTTP node may return items individually (one per row) or as a single array.\n// Handle both cases.\nconst allInputs = $input.all();\n\nlet companies = [];\n\nif (allInputs.length === 1 && Array.isArray(allInputs[0].json)) {\n  // Single item containing an array\n  companies = allInputs[0].json;\n} else if (allInputs.length === 1 && allInputs[0].json[0]) {\n  // Single item with nested array\n  companies = allInputs[0].json;\n} else {\n  // Multiple items, one company per item (this is what n8n HTTP node does)\n  companies = allInputs.map(i => i.json);\n}\n\nif (!companies || companies.length === 0 || (companies.length === 1 && !companies[0].id)) {\n  return [{ json: { _empty: true, _count: 0, _message: 'No companies to enrich in this batch' } }];\n}\n\nconsole.log(`Batch loaded: ${companies.length} companies to enrich`);\n\nreturn companies.map(c => ({ json: c }));"
      },
      "id": "1f84094c-dbc7-488f-8c63-8b30d1d23217",
      "name": "Parse Batch",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -6928,
        192
      ]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose"
          },
          "conditions": [
            {
              "id": "empty-check",
              "leftValue": "={{ $json._empty }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "292b2adf-daa2-478b-8d42-53696df8b73d",
      "name": "Batch Empty?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        -6704,
        192
      ]
    },
    {
      "parameters": {
        "jsCode": "return [{ json: { message: 'No companies with enrichment_status=discovered found. Step 2 complete or no Step 1 data available.', completed_at: new Date().toISOString() } }];"
      },
      "id": "137601ae-3d7c-425d-8c75-f5fae5575bf7",
      "name": "No Records - Done",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -6480,
        96
      ]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose"
          },
          "conditions": [
            {
              "id": "has-domain",
              "leftValue": "={{ $json.has_website }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "2358770c-9b07-4173-b8a5-ac37cce4ed99",
      "name": "Has Website?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        -5584,
        288
      ]
    },
    {
      "parameters": {
        "jsCode": "// For companies without a website, pass through with empty enrichment\n// but still check domain for booking platform signals\nconst items = $input.all();\nconst results = [];\n\nconst bookingSignatures = {\n  'jane_app': ['jane.app', 'janeapp.com'],\n  'acuity': ['acuityscheduling.com', 'squareup.com/appointments'],\n  'mindbody': ['mindbodyonline.com', 'clients.mindbodyonline.com', 'mindbody.io'],\n  'square': ['square.site', 'squareup.com'],\n  'vagaro': ['vagaro.com'],\n  'fresha': ['fresha.com', 'shedul.com'],\n  'schedulicity': ['schedulicity.com'],\n  'schedulista': ['schedulista.com'],\n  'booksy': ['booksy.com'],\n  'massagebook': ['massagebook.com'],\n  'genbook': ['genbook.com'],\n  'noterro': ['noterro.com'],\n  'clinicsense': ['clinicsense.com'],\n  'wix_bookings': ['wix.com/booking'],\n  'calendly': ['calendly.com']\n};\n\nfor (const entry of items) {\n  const item = entry.json;\n  const domain = (item.domain || '').toLowerCase();\n\n  let booking_platform = null;\n  let has_online_booking = false;\n\n  for (const [platform, signatures] of Object.entries(bookingSignatures)) {\n    for (const sig of signatures) {\n      if (domain.includes(sig)) {\n        booking_platform = platform;\n        has_online_booking = true;\n        break;\n      }\n    }\n    if (has_online_booking) break;\n  }\n\n  results.push({\n    json: {\n      ...item,\n      _website_enrichment: {\n        has_online_booking,\n        booking_platform,\n        has_paid_ads: false,\n        estimated_size: null,\n        social_links_found: [],\n        _website_fetch_status: 'skipped_no_website'\n      }\n    }\n  });\n}\n\nreturn results;"
      },
      "id": "3b7bfe86-1088-4850-bf9c-0c19122519b8",
      "name": "Skip - No Website",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -5136,
        384
      ]
    },
    {
      "parameters": {
        "url": "=https://{{ $json.domain }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36"
            },
            {
              "name": "Accept",
              "value": "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8"
            }
          ]
        },
        "options": {
          "redirect": {
            "redirect": {
              "maxRedirects": 5
            }
          },
          "response": {
            "response": {
              "fullResponse": true,
              "responseFormat": "text"
            }
          },
          "timeout": "={{ Number($('Enrichment Config').first().json.http_timeout_ms) }}"
        }
      },
      "id": "89b0f41d-00bc-4b6c-aed8-d1dc8ba4269d",
      "name": "Fetch Website HTML",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -5360,
        192
      ],
      "onError": "continueRegularOutput",
      "notes": "Fetches homepage HTML. On error (timeout, SSL, 403, etc.) continues with error data so the pipeline doesn't break."
    },
    {
      "parameters": {
        "jsCode": "// runOnceForAllItems \u2014 index-paired with Has Website?\nconst upstreamAll = $('Has Website?').all();\nconst inputAll = $input.all();\nconst results = [];\n\n// === HOISTED CONSTANTS ===\nconst bookingSignatures = {\n  'jane_app': ['jane.app', 'janeapp.com'],\n  'acuity': ['acuityscheduling.com', 'squareup.com/appointments', 'app.acuityscheduling.com'],\n  'mindbody': ['mindbodyonline.com', 'clients.mindbodyonline.com', 'mindbody.io', 'healcode.com'],\n  'square': ['square.site', 'squareup.com'],\n  'vagaro': ['vagaro.com'],\n  'fresha': ['fresha.com', 'shedul.com'],\n  'schedulicity': ['schedulicity.com'],\n  'schedulista': ['schedulista.com'],\n  'booksy': ['booksy.com'],\n  'massagebook': ['massagebook.com'],\n  'genbook': ['genbook.com'],\n  'noterro': ['noterro.com'],\n  'clinicsense': ['clinicsense.com'],\n  'wix_bookings': ['wix.com/booking', 'bookings.wixapps.net'],\n  'calendly': ['calendly.com']\n};\n\nconst junkEmailDomains = [\n  'sentry.io', 'schema.org', 'w3.org', 'wordpress.com', 'wordpress.org',\n  'squarespace.com', 'wix.com', 'gravatar.com', 'facebook.com', 'twitter.com',\n  'instagram.com', 'youtube.com', 'linkedin.com', 'pinterest.com', 'tiktok.com',\n  'cloudflare.com', 'googleapis.com', 'googletagmanager.com', 'google-analytics.com',\n  'gstatic.com', 'jsdelivr.net', 'cdnjs.cloudflare.com', 'unpkg.com',\n  'bootstrapcdn.com', 'fontawesome.com', 'typekit.net', 'fonts.googleapis.com',\n  'example.com', 'example.org', 'test.com', 'localhost',\n  'mailinator.com', 'guerrillamail.com', 'tempmail.com', 'yopmail.com'\n];\n\nconst junkLocalPatterns = [\n  /^noreply$/i, /^no-reply$/i, /^donotreply$/i, /^do-not-reply$/i,\n  /^postmaster$/i, /^mailer-daemon$/i, /^webmaster$/i, /^root$/i,\n  /^null$/i, /^test$/i, /^admin$/i, /^abuse$/i\n];\n\nconst roleBasedPrefixes = ['info', 'contact', 'hello', 'office', 'reception',\n  'frontdesk', 'front.desk', 'appointments', 'booking', 'bookings',\n  'schedule', 'scheduling', 'inquiries', 'inquiry', 'general', 'team', 'staff',\n  'support', 'sales', 'billing'];\n\nconst adSignatures = [\n  'googleadservices.com', 'googlesyndication.com', 'googleads.g.doubleclick.net',\n  'google_conversion', 'conversion_async', 'ads/ga-audiences',\n  'fbevents.js', 'fbq(', 'snap.licdn.com', 'linkedin.com/insight',\n  'analytics.tiktok.com', 'tiktok.com/i18n/pixel', 'ads-twitter.com', 'static.ads-twitter.com'\n];\n\nconst socialPatterns = {\n  facebook: /https?:\\/\\/(?:www\\.)?facebook\\.com\\/[a-zA-Z0-9._-]+/gi,\n  instagram: /https?:\\/\\/(?:www\\.)?instagram\\.com\\/[a-zA-Z0-9._-]+/gi,\n  tiktok: /https?:\\/\\/(?:www\\.)?tiktok\\.com\\/@[a-zA-Z0-9._-]+/gi,\n  linkedin: /https?:\\/\\/(?:www\\.)?linkedin\\.com\\/(?:company|in)\\/[a-zA-Z0-9._-]+/gi,\n  x: /https?:\\/\\/(?:www\\.)?(?:twitter\\.com|x\\.com)\\/[a-zA-Z0-9._-]+/gi,\n  youtube: /https?:\\/\\/(?:www\\.)?youtube\\.com\\/(?:c\\/|channel\\/|@)[a-zA-Z0-9._-]+/gi\n};\n\nconst teamPatterns = [\n  /our\\s+team/i, /meet\\s+(?:the\\s+)?team/i, /our\\s+(?:therapists|practitioners|staff|massage\\s+therapists)/i,\n  /meet\\s+(?:our|the)\\s+(?:therapists|practitioners|staff)/i\n];\n\nconst emailRegex = /[a-zA-Z0-9._%+\\-]+@[a-zA-Z0-9.\\-]+\\.[a-zA-Z]{2,}/g;\nconst mailtoRegex = /mailto:([a-zA-Z0-9._%+\\-]+@[a-zA-Z0-9.\\-]+\\.[a-zA-Z]{2,})/gi;\n\nconst bookingPatterns = ['book now', 'book online', 'book appointment', 'schedule now', 'schedule online', 'book a massage', 'online booking'];\n\nconst soloSignals = ['sole proprietor', 'solo practice', 'independent massage',\n  'i am a licensed', \"i'm a licensed\", 'about me', 'my practice', 'my approach',\n  'my services', 'i specialize', 'i provide'];\n\nfor (let i = 0; i < inputAll.length; i++) {\n  const company = upstreamAll[i].json;\n  const response = inputAll[i].json;\n  const domain = (company.domain || '').toLowerCase();\n\n  // === DOMAIN-BASED BOOKING DETECTION (runs even if fetch fails) ===\n  let booking_platform = null;\n  let has_online_booking = false;\n\n  // Check domain first\n  for (const [platform, signatures] of Object.entries(bookingSignatures)) {\n    for (const sig of signatures) {\n      if (domain.includes(sig)) {\n        booking_platform = platform;\n        has_online_booking = true;\n        break;\n      }\n    }\n    if (has_online_booking) break;\n  }\n\n  // Handle fetch errors\n  if (response.error || (!response.body && !response.data)) {\n    results.push({\n      json: {\n        ...company,\n        _website_enrichment: {\n          has_online_booking,\n          booking_platform,\n          has_paid_ads: false,\n          estimated_size: null,\n          social_links_found: [],\n          emails_found: [],\n          best_email: null,\n          _website_fetch_status: 'error',\n          _website_error: response.error || 'Empty response'\n        }\n      }\n    });\n    continue;\n  }\n\n  const rawHtml = response.body || response.data || '';\n  const html = (typeof rawHtml === 'string' ? rawHtml : '').toLowerCase();\n  const htmlOriginal = typeof rawHtml === 'string' ? rawHtml : '';\n\n  // === EMAIL EXTRACTION ===\n  const allEmailMatches = htmlOriginal.match(emailRegex) || [];\n\n  // Also extract from mailto: links (higher confidence)\n  // Reset regex lastIndex since we reuse it across loop iterations\n  mailtoRegex.lastIndex = 0;\n  const mailtoEmails = new Set();\n  let mailtoMatch;\n  while ((mailtoMatch = mailtoRegex.exec(htmlOriginal)) !== null) {\n    mailtoEmails.add(mailtoMatch[1].toLowerCase());\n  }\n\n  // Deduplicate and filter\n  const uniqueEmails = [...new Set(allEmailMatches.map(e => e.toLowerCase()))];\n  const scoredEmails = [];\n\n  for (const email of uniqueEmails) {\n    const [localPart, emailDomain] = email.split('@');\n    if (!emailDomain) continue;\n\n    // Filter out junk domains\n    if (junkEmailDomains.some(d => emailDomain.includes(d))) continue;\n\n    // Filter out junk local parts\n    if (junkLocalPatterns.some(p => p.test(localPart))) continue;\n\n    // Filter out numeric-only local parts\n    if (/^\\d+$/.test(localPart)) continue;\n\n    // Score the email\n    let score = 0;\n    if (domain && emailDomain.includes(domain.replace('www.', ''))) score += 20;\n    if (mailtoEmails.has(email)) score += 10;\n    if (roleBasedPrefixes.some(p => localPart === p || localPart.startsWith(p + '.'))) score += 5;\n\n    scoredEmails.push({ email, score, from_mailto: mailtoEmails.has(email) });\n  }\n\n  // Sort by score descending\n  scoredEmails.sort((a, b) => b.score - a.score);\n  const best_email = scoredEmails.length > 0 ? scoredEmails[0].email : null;\n\n  // === HTML-BASED BOOKING DETECTION ===\n  if (!has_online_booking) {\n    for (const [platform, signatures] of Object.entries(bookingSignatures)) {\n      for (const sig of signatures) {\n        if (html.includes(sig)) {\n          booking_platform = platform;\n          has_online_booking = true;\n          break;\n        }\n      }\n      if (has_online_booking) break;\n    }\n  }\n\n  if (!has_online_booking) {\n    for (const pattern of bookingPatterns) {\n      if (html.includes(pattern)) {\n        has_online_booking = true;\n        booking_platform = 'unknown';\n        break;\n      }\n    }\n  }\n\n  // === PAID ADS DETECTION ===\n  let has_paid_ads = false;\n  for (const sig of adSignatures) {\n    if (html.includes(sig)) {\n      has_paid_ads = true;\n      break;\n    }\n  }\n\n  // === SOCIAL LINKS EXTRACTION ===\n  const social_links_found = [];\n  const seenPlatforms = new Set();\n\n  for (const [platform, regex] of Object.entries(socialPatterns)) {\n    // Reset regex lastIndex since we reuse across loop iterations\n    regex.lastIndex = 0;\n    const matches = htmlOriginal.match(regex) || [];\n    for (const url of matches) {\n      const lowerUrl = url.toLowerCase();\n      if (lowerUrl.includes('/sharer') || lowerUrl.includes('/share') ||\n          lowerUrl.includes('/intent') || lowerUrl.includes('/login') ||\n          lowerUrl.includes('/help') || lowerUrl.includes('/about') ||\n          lowerUrl.includes('/policies') || lowerUrl.includes('/privacy')) {\n        continue;\n      }\n      if (!seenPlatforms.has(platform)) {\n        social_links_found.push({ platform, url: url.replace(/\\/+$/, '') });\n        seenPlatforms.add(platform);\n      }\n    }\n  }\n\n  // === TEAM SIZE ESTIMATION ===\n  let estimated_size = null;\n\n  let hasTeamPage = false;\n  for (const p of teamPatterns) {\n    if (p.test(htmlOriginal)) {\n      hasTeamPage = true;\n      break;\n    }\n  }\n\n  if (hasTeamPage) {\n    const namePatterns = htmlOriginal.match(/<h[2-4][^>]*>[^<]{2,40}<\\/h[2-4]>/gi) || [];\n    const staffLinks = htmlOriginal.match(/\\/(?:team|staff|therapist|practitioner)s?\\/[a-z-]+/gi) || [];\n    const memberCount = Math.max(namePatterns.length, staffLinks.length);\n    if (memberCount <= 1) estimated_size = 'solo';\n    else if (memberCount <= 5) estimated_size = 'small';\n    else estimated_size = 'medium';\n  } else {\n    const isSolo = soloSignals.some(s => html.includes(s));\n    if (isSolo) estimated_size = 'solo';\n  }\n\n  results.push({\n    json: {\n      ...company,\n      _website_enrichment: {\n        has_online_booking,\n        booking_platform,\n        has_paid_ads,\n        estimated_size,\n        social_links_found,\n        emails_found: scoredEmails.slice(0, 5),\n        best_email,\n        _website_fetch_status: 'success'\n      }\n    }\n  });\n}\n\nreturn results;"
      },
      "id": "9fc33b79-32fd-4245-9b47-b645a1dc7c58",
      "name": "Analyze Website HTML",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -5136,
        192
      ],
      "notes": "Detects booking platforms, paid ads scripts, social media links, and estimates team size from website HTML."
    },
    {
      "parameters": {
        "jsCode": "// Merge website-enriched (from both paths: with website and without)\nconst items = $input.all();\nconst results = [];\n// Enrichment Config is a single-item node, .first() is correct here\nconst config = $('Enrichment Config').first().json;\nconst skipGoogleDetails = config.skip_google_details === 'true' || config.skip_google_details === true;\n\nfor (const entry of items) {\n  const item = entry.json;\n  const enrichment = item._website_enrichment || {};\n\n  // Prepare the enriched company object\n  const enriched = {\n    id: item.id,\n    name: item.name,\n    phone: item.phone,\n    domain: item.domain,\n    address: item.address,\n    city: item.city,\n    state: item.state,\n    country: item.country,\n    google_place_id: item.google_place_id,\n    category: item.category,\n    has_website: item.has_website,\n    google_review_count: item.google_review_count,\n    google_rating: item.google_rating,\n    source_urls: item.source_urls,\n    on_yelp: item.on_yelp,\n    on_groupon: item.on_groupon,\n\n    // Enriched fields from website analysis\n    has_online_booking: enrichment.has_online_booking || false,\n    booking_platform: enrichment.booking_platform || null,\n    has_paid_ads: enrichment.has_paid_ads || false,\n    estimated_size: enrichment.estimated_size || null,\n\n    // Email fields from website scraping (BUG-F012 fix)\n    _emails_found: enrichment.emails_found || [],\n    _best_email: enrichment.best_email || null,\n\n    // Backfill data from Google Places lookup (BUG-F013 fix)\n    _backfill_patch: item._backfill_patch || null,\n\n    // Social links for later processing\n    _social_links_found: enrichment.social_links_found || [],\n    _website_fetch_status: enrichment._website_fetch_status || 'unknown',\n    _website_error: enrichment._website_error || null,\n    _needs_social_discovery: (enrichment.social_links_found || []).length === 0,\n    _skip_google_details: skipGoogleDetails\n  };\n\n  results.push({ json: enriched });\n}\n\nreturn results;"
      },
      "id": "5ab890a5-77ce-4e02-afff-9a58b1cf852c",
      "name": "Merge Website Results",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -4912,
        288
      ]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose"
          },
          "conditions": [
            {
              "id": "has-place-id",
              "leftValue": "={{ $json.google_place_id }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "notEquals"
              }
            },
            {
              "id": "not-skipped",
              "leftValue": "={{ $json._skip_google_details }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "notEquals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "75afb43c-2b57-4603-9062-bbb20e5a8bfe",
      "name": "Has Google Place ID?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        -4688,
        288
      ]
    },
    {
      "parameters": {
        "url": "=https://places.googleapis.com/v1/places/{{ $json.google_place_id }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "X-Goog-FieldMask",
              "value": "currentOpeningHours,regularOpeningHours,types,photos,priceLevel,businessStatus"
            },
            {
              "name": "X-Goog-Api-Key",
              "value": "={{ $env.GOOGLE_PLACES_API_KEY }}"
            }
          ]
        },
        "options": {
          "timeout": 15000
        }
      },
      "id": "b5388f46-798b-4b64-81b3-93e6e088b48d",
      "name": "Google Places Details",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -4464,
        192
      ],
      "onError": "continueRegularOutput",
      "notes": "Fetches ONLY incremental fields not captured in Step 1 Text Search: opening hours, business status, price level, photo count."
    },
    {
      "parameters": {
        "jsCode": "// runOnceForAllItems \u2014 index-paired with Has Google Place ID?\nconst upstreamAll = $('Has Google Place ID?').all();\nconst inputAll = $input.all();\nconst results = [];\n\nfor (let i = 0; i < inputAll.length; i++) {\n  const company = upstreamAll[i].json;\n  const details = inputAll[i].json;\n\n  // Extract incremental data from Google Places Details\n  let opening_hours = null;\n  let business_status = null;\n  let photo_count = 0;\n  let price_level = null;\n  let additional_types = [];\n\n  if (details && !details.error) {\n    if (details.regularOpeningHours && details.regularOpeningHours.periods) {\n      opening_hours = details.regularOpeningHours;\n    } else if (details.currentOpeningHours && details.currentOpeningHours.periods) {\n      opening_hours = details.currentOpeningHours;\n    }\n    business_status = details.businessStatus || null;\n    if (details.photos && Array.isArray(details.photos)) {\n      photo_count = details.photos.length;\n    }\n    price_level = details.priceLevel || null;\n    if (details.types && Array.isArray(details.types)) {\n      additional_types = details.types;\n    }\n  }\n\n  results.push({\n    json: {\n      ...company,\n      _google_details: {\n        opening_hours,\n        business_status,\n        photo_count,\n        price_level,\n        additional_types,\n        _fetch_status: details.error ? 'error' : 'success'\n      }\n    }\n  });\n}\n\nreturn results;"
      },
      "id": "86bf32b5-7f8b-477d-bc0f-46cd919e314f",
      "name": "Parse Google Details",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -4240,
        192
      ]
    },
    {
      "parameters": {
        "jsCode": "// Companies without Google Place ID skip details fetch\nconst items = $input.all();\nconst results = [];\n\nfor (const entry of items) {\n  const company = entry.json;\n  results.push({\n    json: {\n      ...company,\n      _google_details: {\n        opening_hours: null,\n        business_status: null,\n        photo_count: 0,\n        price_level: null,\n        additional_types: [],\n        _fetch_status: 'skipped'\n      }\n    }\n  });\n}\n\nreturn results;"
      },
      "id": "2a557f09-9a93-4fee-a243-b5ac2aa3aac4",
      "name": "Skip Google Details",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -4352,
        400
      ]
    },
    {
      "parameters": {
        "jsCode": "const items = $input.all();\nconst results = [];\n\nfor (const entry of items) {\n  const item = entry.json;\n  const now = new Date().toISOString();\n\n  // Build the PATCH payload for Supabase\n  const updatePayload = {\n    has_online_booking: item.has_online_booking || false,\n    booking_platform: item.booking_platform || null,\n    has_paid_ads: item.has_paid_ads || false,\n    estimated_size: item.estimated_size || null,\n    enrichment_status: 'partially_enriched',\n    enriched_at: now\n  };\n\n  // Include backfill data ONLY from companies that went through the backfill path\n  // This prevents 409 conflicts when PATCHing domain on companies that already have one\n  const backfill = item._backfill_patch || {};\n  if (backfill.domain) updatePayload.domain = backfill.domain;\n  if (backfill.google_place_id) updatePayload.google_place_id = backfill.google_place_id;\n  if (backfill.google_rating) updatePayload.google_rating = backfill.google_rating;\n  if (backfill.google_review_count) updatePayload.google_review_count = backfill.google_review_count;\n\n  // has_website can change via website analysis (not just backfill)\n  if (item.has_website) updatePayload.has_website = item.has_website;\n\n  // Include website-scraped email if found (BUG-F012 fix: read from flat field)\n  const websiteEmail = item._best_email || null;\n  if (websiteEmail) {\n    updatePayload.email = websiteEmail;\n    // email_status stays NULL - will be verified in Step 4\n  }\n\n  results.push({\n    json: {\n      _company_id: item.id,\n      _update_payload: updatePayload,\n      // Pass through everything for social discovery\n      ...item\n    }\n  });\n}\n\nreturn results;"
      },
      "id": "b8406b5a-6d4c-4fd6-a5dc-10d327214c6d",
      "name": "Prepare Company Update",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -4016,
        288
      ]
    },
    {
      "parameters": {
        "method": "PATCH",
        "url": "={{ $env.SUPABASE_URL }}/rest/v1/companies?id=eq.{{ $json._company_id }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "apikey",
              "value": "={{ $env.SUPABASE_SERVICE_KEY }}"
            },
            {
              "name": "Authorization",
              "value": "=Bearer {{ $env.SUPABASE_SERVICE_KEY }}"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            },
            {
              "name": "Prefer",
              "value": "return=minimal"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify($json._update_payload) }}",
        "options": {
          "batching": {
            "batch": {
              "batchSize": 10,
              "batchInterval": 500
            }
          }
        }
      },
      "id": "5d505629-0622-4b1d-9221-f8be1c207a94",
      "name": "Update Company in Supabase",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -3792,
        288
      ],
      "onError": "continueRegularOutput",
      "notes": "PATCH updates enrichment fields. Batched 10 at a time with 500ms delay to avoid overwhelming Supabase."
    },
    {
      "parameters": {
        "jsCode": "// runOnceForAllItems \u2014 index-paired with Prepare Company Update\n// Enrichment Config is a single-item node, hoisted outside loop\nconst upstreamAll = $('Prepare Company Update').all();\nconst inputAll = $input.all();\nconst config = $('Enrichment Config').first().json;\nconst skipSocial = config.skip_social_discovery === 'true' || config.skip_social_discovery === true;\nconst results = [];\n\nfor (let i = 0; i < inputAll.length; i++) {\n  const item = upstreamAll[i].json;\n\n  const socialLinks = item._social_links_found || [];\n  const needsDiscovery = item._needs_social_discovery && !skipSocial;\n\n  results.push({\n    json: {\n      company_id: item.id,\n      company_name: item.name,\n      city: item.city,\n      state: item.state,\n      domain: item.domain,\n      social_links_found: socialLinks,\n      needs_social_discovery: needsDiscovery,\n      _skip_social: skipSocial\n    }\n  });\n}\n\nreturn results;"
      },
      "id": "34e24a4d-6e12-4c13-95b9-d417e5a19d82",
      "name": "Prepare Social Processing",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -3568,
        288
      ]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose"
          },
          "conditions": [
            {
              "id": "has-social-links",
              "leftValue": "={{ $json.social_links_found.length }}",
              "rightValue": "0",
              "operator": {
                "type": "number",
                "operation": "gt"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "e77bb9db-36cc-479e-8d0c-13ef6b6482c1",
      "name": "Has Social Links?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        -3344,
        288
      ]
    },
    {
      "parameters": {
        "jsCode": "// Insert social profiles found from website HTML into Supabase social_profiles table\nconst items = $input.all();\nconst results = [];\n\nfor (const entry of items) {\n  const item = entry.json;\n  const links = item.social_links_found || [];\n\n  if (links.length === 0) {\n    results.push({ json: { _social_inserts: 0, company_id: item.company_id } });\n    continue;\n  }\n\n  // Build an array of social_profiles rows\n  const rows = links.map(link => ({\n    company_id: item.company_id,\n    platform: link.platform,\n    profile_url: link.url,\n    follower_count: null,\n    post_count: null,\n    last_post_date: null,\n    scraped_at: new Date().toISOString()\n  }));\n\n  results.push({\n    json: {\n      _social_rows: rows,\n      _social_inserts: rows.length,\n      company_id: item.company_id,\n      company_name: item.company_name,\n      city: item.city,\n      state: item.state,\n      needs_social_discovery: false\n    }\n  });\n}\n\nreturn results;"
      },
      "id": "be72a227-8bf1-49a5-9c84-229905aab929",
      "name": "Prepare Social Profiles Insert",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -432,
        0
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $env.SUPABASE_URL }}/rest/v1/social_profiles",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "apikey",
              "value": "={{ $env.SUPABASE_SERVICE_KEY }}"
            },
            {
              "name": "Authorization",
              "value": "=Bearer {{ $env.SUPABASE_SERVICE_KEY }}"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            },
            {
              "name": "Prefer",
              "value": "resolution=merge-duplicates,return=minimal"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify($json._social_rows) }}",
        "options": {}
      },
      "id": "7256fe4c-eff0-4345-ba69-bc010db8f0d8",
      "name": "Insert Social Profiles",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -208,
        0
      ],
      "onError": "continueRegularOutput",
      "notes": "Inserts social profiles found from website HTML. Uses merge-duplicates to handle re-runs gracefully."
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose"
          },
          "conditions": [
            {
              "id": "needs-discovery",
              "leftValue": "={{ $json.needs_social_discovery }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "60910ba9-01e0-4cbd-b8f9-6bf01758ff14",
      "name": "Needs Social Discovery?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        -3120,
        368
      ]
    },
    {
      "parameters": {
        "jsCode": "// Collect all companies that need social discovery into a single batch for Apify\n// This node collects items from the loop and builds the search queries\nconst items = $input.all();\n\nconst searchQueries = [];\nconst companyMap = {};\n\nfor (const item of items) {\n  const data = item.json;\n  if (!data.company_name || !data.city) continue;\n  \n  const searchTerm = `${data.company_name} ${data.city} ${data.state || ''} massage`.trim();\n  searchQueries.push({\n    company_id: data.company_id,\n    company_name: data.company_name,\n    city: data.city,\n    state: data.state,\n    search_term: searchTerm\n  });\n}\n\nif (searchQueries.length === 0) {\n  return [{ json: { _no_social_discovery_needed: true, _count: 0 } }];\n}\n\nconsole.log(`Social discovery needed for ${searchQueries.length} companies`);\n\nreturn [{\n  json: {\n    _social_discovery_queries: searchQueries,\n    _count: searchQueries.length,\n    _no_social_discovery_needed: false\n  }\n}];"
      },
      "id": "a51849ff-dd51-4d07-8412-227e5088f00d",
      "name": "Build Social Discovery Batch",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2896,
        560
      ]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose"
          },
          "conditions": [
            {
              "id": "has-queries",
              "leftValue": "={{ $json._no_social_discovery_needed }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "notEquals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "648e916d-ca2d-4e54-bcbf-a0fe2bb2a905",
      "name": "Discovery Queries Exist?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        -2672,
        560
      ]
    },
    {
      "parameters": {
        "jsCode": "// Build the Apify Facebook Search Scraper input\n// Actor: apify/facebook-search-scraper\n// Input fields: categories (array of search terms), locations (array), resultsLimit (number)\nconst data = $input.first().json;\nconst queries = data._social_discovery_queries || [];\n\n// Build category search terms: \"CompanyName City\" for each company\nconst categories = queries.map(q => \n  `${q.company_name} ${q.city}`.trim()\n).slice(0, 100);\n\n// Get unique locations in \"City, State\" format\nconst locations = [...new Set(\n  queries.map(q => `${q.city}, ${q.state}`.trim()).filter(l => l !== ',')\n)];\n\nreturn [{\n  json: {\n    _queries: queries,\n    _apify_input: {\n      categories: categories,\n      locations: locations,\n      resultsLimit: 3\n    }\n  }\n}];"
      },
      "id": "b83c7e7e-e460-43f5-a53f-5b9d143df069",
      "name": "Prepare FB Search Input",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2448,
        368
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://api.apify.com/v2/actor-tasks/uplifted_veranda~facebook-search-scraper-task/runs?token={{ $env.APIFY_API_TOKEN }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify($json._apify_input) }}",
        "options": {
          "timeout": 30000
        }
      },
      "id": "618804e0-dd9b-40fb-9c93-d7cb851b271c",
      "name": "Start FB Search Run",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -2224,
        368
      ],
      "onError": "continueRegularOutput",
      "notes": "Starts the Apify Facebook Search Scraper actor to find Facebook pages for companies without social links."
    },
    {
      "parameters": {
        "jsCode": "const response = $input.first().json;\nconst queries = $('Prepare FB Search Input').first().json._queries;\nlet runId = '';\nlet datasetId = '';\n\nif (response.data) {\n  runId = response.data.id || '';\n  datasetId = response.data.defaultDatasetId || '';\n}\n\nif (!runId) {\n  console.log('Facebook Search: Failed to start run. Response:', JSON.stringify(response).substring(0, 500));\n  return [{ json: { _fb_search_failed: true, _fb_error: 'Failed to start Apify run', _queries: queries, runId: '', datasetId: '' } }];\n}\n\nreturn [{ json: { runId, datasetId, pollCount: 0, _queries: queries, _fb_search_failed: false } }];"
      },
      "id": "11bb7aa4-8482-4397-811a-27e5c22f530c",
      "name": "Extract FB Run ID",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2000,
        368
      ]
    },
    {
      "parameters": {
        "amount": 30
      },
      "id": "e6d428ec-8df0-4e7f-b06f-55f00585e56e",
      "name": "Wait FB 30s",
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1.1,
      "position": [
        -1776,
        368
      ],
      "webhookId": "e1d8796f-0e93-4645-bf79-d1bb08239994"
    },
    {
      "parameters": {
        "url": "=https://api.apify.com/v2/actor-runs/{{ $('Extract FB Run ID').first().json.runId }}?token={{ $env.APIFY_API_TOKEN }}",
        "options": {
          "timeout": 15000
        }
      },
      "id": "331a19fa-7e04-48fc-8f22-1c6177a4e1c2",
      "name": "Check FB Run Status",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -1552,
        288
      ]
    },
    {
      "parameters": {
        "jsCode": "const response = $input.first().json;\nconst prevData = $('Extract FB Run ID').first().json;\n\nlet status = 'UNKNOWN';\nlet datasetId = prevData.datasetId || '';\n\nif (response.data && response.data.status) {\n  status = response.data.status;\n  if (response.data.defaultDatasetId) datasetId = response.data.defaultDatasetId;\n}\n\nlet pollCount = 0;\ntry {\n  pollCount = $('Parse FB Status').first().json.pollCount || 0;\n} catch(e) {\n  pollCount = prevData.pollCount || 0;\n}\npollCount++;\n\n// Timeout after 20 polls (10 minutes)\nif (pollCount > 20 && status !== 'SUCCEEDED' && status !== 'FAILED') {\n  status = 'TIMED_OUT';\n}\n\nreturn [{ json: { runId: prevData.runId, datasetId, pollCount, status, _queries: prevData._queries } }];"
      },
      "id": "a9662999-475f-4e3b-8c41-6fc80b66da99",
      "name": "Parse FB Status",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1328,
        288
      ]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose"
          },
          "conditions": [
            {
              "id": "fb-succeeded",
              "leftValue": "={{ $json.status }}",
              "rightValue": "SUCCEEDED",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "3ec5754f-95ca-4bba-8622-98a661019b1f",
      "name": "FB Run Succeeded?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        -1104,
        368
      ]
    },
    {
      "parameters": {
        "url": "=https://api.apify.com/v2/datasets/{{ $json.datasetId }}/items?token={{ $env.APIFY_API_TOKEN }}",
        "options": {
          "timeout": 60000
        }
      },
      "id": "fe058fde-038b-4047-99e1-f607a4d3a4e5",
      "name": "Fetch FB Search Results",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -880,
        368
      ]
    },
    {
      "parameters": {
        "jsCode": "// Match Facebook search results back to companies and build social_profiles rows\nconst results = $input.first().json;\nconst queries = $('Extract FB Run ID').first().json._queries || [];\n\n// results should be an array of Facebook page results\nconst fbPages = Array.isArray(results) ? results : [results];\n\nconst socialRows = [];\nconst matchLog = [];\n\nfor (const query of queries) {\n  const companyNameLower = (query.company_name || '').toLowerCase();\n  const cityLower = (query.city || '').toLowerCase();\n\n  let bestMatch = null;\n  let bestScore = 0;\n\n  for (const page of fbPages) {\n    // FB Search Scraper output fields: title, description, url, address, email, \n    // website, phone, likes, checkins, categories, messenger, adStatus\n    const pageName = (page.title || page.name || '').toLowerCase();\n    const pageAddress = (page.address || '').toLowerCase();\n    const pageDescription = (page.description || '').toLowerCase();\n    \n    // Score based on name similarity\n    const companyWords = companyNameLower.split(/\\s+/).filter(w => w.length > 2);\n    const matchingWords = companyWords.filter(w => pageName.includes(w));\n    let score = companyWords.length > 0 ? matchingWords.length / companyWords.length : 0;\n    \n    // Bonus for city match in address or description\n    if (cityLower && (pageAddress.includes(cityLower) || pageDescription.includes(cityLower))) {\n      score += 0.2;\n    }\n    \n    // Bonus for massage/spa/therapy keywords\n    const relevantKeywords = ['massage', 'spa', 'therapy', 'therapist', 'bodywork', 'wellness'];\n    const pageText = `${pageName} ${pageDescription} ${(page.categories || []).join(' ')}`.toLowerCase();\n    if (relevantKeywords.some(kw => pageText.includes(kw))) {\n      score += 0.15;\n    }\n    \n    if (score > bestScore && score >= 0.5) {\n      bestScore = score;\n      bestMatch = page;\n    }\n  }\n\n  if (bestMatch) {\n    const pageUrl = bestMatch.url || bestMatch.facebookUrl || '';\n    if (pageUrl) {\n      socialRows.push({\n        company_id: query.company_id,\n        platform: 'facebook',\n        profile_url: pageUrl,\n        follower_count: bestMatch.likes || bestMatch.followers || null,\n        post_count: null,\n        last_post_date: null,\n        scraped_at: new Date().toISOString()\n      });\n      matchLog.push({ \n        company: query.company_name, \n        matched_to: bestMatch.title || bestMatch.name, \n        score: bestScore,\n        fb_url: pageUrl\n      });\n    }\n  }\n}\n\nconsole.log(`Facebook discovery: ${socialRows.length} matches from ${fbPages.length} results for ${queries.length} queries`);\n\nreturn [{\n  json: {\n    _fb_social_rows: socialRows,\n    _fb_match_count: socialRows.length,\n    _fb_total_results: fbPages.length,\n    _match_log: matchLog\n  }\n}];"
      },
      "id": "f38c97f4-5519-4234-8877-4fc51d2af24a",
      "name": "Match FB Results to Companies",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -656,
        368
      ]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose"
          },
          "conditions": [
            {
              "id": "has-fb-results",
              "leftValue": "={{ $json._fb_match_count }}",
              "rightValue": "0",
              "operator": {
                "type": "number",
                "operation": "gt"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "8e8275ce-a89c-4e91-b4bc-1fabb85b4577",
      "name": "FB Matches Found?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        -432,
        368
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $env.SUPABASE_URL }}/rest/v1/social_profiles",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "apikey",
              "value": "={{ $env.SUPABASE_SERVICE_KEY }}"
            },
            {
              "name": "Authorization",
              "value": "=Bearer {{ $env.SUPABASE_SERVICE_KEY }}"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            },
            {
              "name": "Prefer",
              "value": "resolution=merge-duplicates,return=minimal"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify($json._fb_social_rows) }}",
        "options": {}
      },
      "id": "ecff84ca-7e3d-428f-ad89-236f5e0d9698",
      "name": "Insert FB Social Profiles",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -208,
        288
      ],
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "jsCode": "// Build the Apify Instagram Search Scraper input\n// Actor: apify/instagram-search-scraper\n// Input fields: search (single string), searchType (string), searchLimit (number),\n//               enhanceUserSearchWithFacebookPage (boolean)\n//\n// LIMITATION: IG Search Scraper takes ONE search string per run.\n// Strategy: We search for \"massage therapy [city] [state]\" to find local businesses,\n// then match results back to individual companies.\nconst data = $input.first().json;\nconst queries = data._social_discovery_queries || [];\n\nif (queries.length === 0) {\n  return [{ json: { _queries: queries, _apify_input: {}, _ig_skip: true } }];\n}\n\n// Get the most common city from the batch (they're likely all the same metro)\nconst cityCounts = {};\nfor (const q of queries) {\n  const loc = `${q.city} ${q.state}`.trim();\n  cityCounts[loc] = (cityCounts[loc] || 0) + 1;\n}\nconst primaryCity = Object.entries(cityCounts).sort((a, b) => b[1] - a[1])[0][0];\n\nreturn [{\n  json: {\n    _queries: queries,\n    _apify_input: {\n      search: `massage therapy ${primaryCity}`,\n      searchType: \"user\",\n      searchLimit: Math.min(queries.length * 2, 50),\n      enhanceUserSearchWithFacebookPage: false\n    },\n    _ig_skip: false\n  }\n}];"
      },
      "id": "07ffe709-bd8d-4a1a-835d-8f4ecf6e0516",
      "name": "Prepare IG Search Input",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2448,
        768
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://api.apify.com/v2/actor-tasks/uplifted_veranda~instagram-search-scraper-task/runs?token={{ $env.APIFY_API_TOKEN }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify($json._apify_input) }}",
        "options": {
          "timeout": 30000
        }
      },
      "id": "dc2c0c09-619b-4e41-a8a9-9a8222d36d17",
      "name": "Start IG Search Run",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -2224,
        768
      ],
      "onError": "continueRegularOutput",
      "notes": "Starts the Apify Instagram Search Scraper actor to discover Instagram profiles."
    },
    {
      "parameters": {
        "jsCode": "const response = $input.first().json;\nconst prevInput = $('Prepare IG Search Input').first().json;\nconst queries = prevInput._queries;\n\n// If we skipped IG search\nif (prevInput._ig_skip) {\n  return [{ json: { _ig_search_failed: true, _ig_error: 'No queries - skipped', _queries: queries, runId: '', datasetId: '' } }];\n}\n\nlet runId = '';\nlet datasetId = '';\n\nif (response.data) {\n  runId = response.data.id || '';\n  datasetId = response.data.defaultDatasetId || '';\n}\n\nif (!runId) {\n  console.log('Instagram Search: Failed to start run. Response:', JSON.stringify(response).substring(0, 500));\n  return [{ json: { _ig_search_failed: true, _ig_error: 'Failed to start Apify run', _queries: queries, runId: '', datasetId: '' } }];\n}\n\nreturn [{ json: { runId, datasetId, pollCount: 0, _queries: queries, _ig_search_failed: false } }];"
      },
      "id": "6111a6c3-a138-4910-b799-9303a0e9f511",
      "name": "Extract IG Run ID",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2000,
        768
      ]
    },
    {
      "parameters": {
        "amount": 30
      },
      "id": "c512e75a-b7d5-4c4a-b944-3ad81a568191",
      "name": "Wait IG 30s",
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1.1,
      "position": [
        -1776,
        768
      ],
      "webhookId": "a4c07964-b9f7-418a-9217-471299bbaa53"
    },
    {
      "parameters": {
        "url": "=https://api.apify.com/v2/actor-runs/{{ $('Extract IG Run ID').first().json.runId }}?token={{ $env.APIFY_API_TOKEN }}",
        "options": {
          "timeout": 15000
        }
      },
      "id": "8daea210-10b2-44bb-8820-408888bcbb62",
      "name": "Check IG Run Status",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -1552,
        704
      ]
    },
    {
      "parameters": {
        "jsCode": "const response = $input.first().json;\nconst prevData = $('Extract IG Run ID').first().json;\n\nlet status = 'UNKNOWN';\nlet datasetId = prevData.datasetId || '';\n\nif (response.data && response.data.status) {\n  status = response.data.status;\n  if (response.data.defaultDatasetId) datasetId = response.data.defaultDatasetId;\n}\n\nlet pollCount = 0;\ntry {\n  pollCount = $('Parse IG Status').first().json.pollCount || 0;\n} catch(e) {\n  pollCount = prevData.pollCount || 0;\n}\npollCount++;\n\nif (pollCount > 20 && status !== 'SUCCEEDED' && status !== 'FAILED') {\n  status = 'TIMED_OUT';\n}\n\nreturn [{ json: { runId: prevData.runId, datasetId, pollCount, status, _queries: prevData._queries } }];"
      },
      "id": "06bbd7b4-b14e-49da-a5e1-a7852ee42db9",
      "name": "Parse IG Status",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1328,
        704
      ]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose"
          },
          "conditions": [
            {
              "id": "ig-succeeded",
              "leftValue": "={{ $json.status }}",
              "rightValue": "SUCCEEDED",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "cd7738b4-5846-4b33-b42c-16c57376b4d9",
      "name": "IG Run Succeeded?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        -1104,
        768
      ]
    },
    {
      "parameters": {
        "url": "=https://api.apify.com/v2/datasets/{{ $json.datasetId }}/items?token={{ $env.APIFY_API_TOKEN }}",
        "options": {
          "timeout": 60000
        }
      },
      "id": "d805fc7a-6c73-415f-b351-2607899dd6ab",
      "name": "Fetch IG Search Results",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -880,
        768
      ]
    },
    {
      "parameters": {
        "jsCode": "// Match Instagram search results back to companies\nconst results = $input.first().json;\nconst queries = $('Extract IG Run ID').first().json._queries || [];\n\n// IG Search Scraper returns profiles with fields like:\n// username, fullName, biography, followersCount, followsCount, \n// postsCount, isBusinessAccount, profilePicUrl, externalUrl, etc.\nconst igProfiles = Array.isArray(results) ? results : [results];\n\nconst socialRows = [];\nconst matchLog = [];\n\nfor (const query of queries) {\n  const companyNameLower = (query.company_name || '').toLowerCase().replace(/[^a-z0-9\\s]/g, '');\n  const cityLower = (query.city || '').toLowerCase();\n\n  let bestMatch = null;\n  let bestScore = 0;\n\n  for (const profile of igProfiles) {\n    const profileName = (profile.fullName || profile.name || '').toLowerCase().replace(/[^a-z0-9\\s]/g, '');\n    const profileBio = (profile.biography || profile.bio || '').toLowerCase();\n    const username = (profile.username || '').toLowerCase();\n    \n    // Score based on name similarity\n    const companyWords = companyNameLower.split(/\\s+/).filter(w => w.length > 2);\n    const matchingWords = companyWords.filter(w => \n      profileName.includes(w) || username.includes(w)\n    );\n    let score = companyWords.length > 0 ? matchingWords.length / companyWords.length : 0;\n    \n    // Bonus for city mention in bio\n    if (cityLower && profileBio.includes(cityLower)) score += 0.2;\n    \n    // Bonus for massage/spa/therapy keywords in bio or name\n    const relevantKeywords = ['massage', 'spa', 'therapy', 'therapist', 'bodywork', 'wellness', 'rmt'];\n    if (relevantKeywords.some(kw => profileBio.includes(kw) || profileName.includes(kw))) score += 0.15;\n    \n    // Bonus for business account\n    const isBusinessAccount = profile.isBusinessAccount || profile.isBusiness || false;\n    if (isBusinessAccount) score += 0.1;\n    \n    if (score > bestScore && score >= 0.5) {\n      bestScore = score;\n      bestMatch = profile;\n    }\n  }\n\n  if (bestMatch) {\n    const profileUrl = bestMatch.url || bestMatch.profileUrl || \n      (bestMatch.username ? `https://www.instagram.com/${bestMatch.username}` : '');\n    \n    if (profileUrl) {\n      socialRows.push({\n        company_id: query.company_id,\n        platform: 'instagram',\n        profile_url: profileUrl,\n        follower_count: bestMatch.followersCount || bestMatch.followers || null,\n        post_count: bestMatch.postsCount || bestMatch.posts || null,\n        last_post_date: null,\n        scraped_at: new Date().toISOString()\n      });\n      matchLog.push({ \n        company: query.company_name, \n        matched_to: bestMatch.username || bestMatch.fullName, \n        score: bestScore \n      });\n    }\n  }\n}\n\nconsole.log(`Instagram discovery: ${socialRows.length} matches from ${igProfiles.length} results for ${queries.length} queries`);\n\nreturn [{\n  json: {\n    _ig_social_rows: socialRows,\n    _ig_match_count: socialRows.length,\n    _ig_total_results: igProfiles.length,\n    _match_log: matchLog\n  }\n}];"
      },
      "id": "ba2a1c03-8e73-449e-9fa4-98d1c404b18c",
      "name": "Match IG Results to Companies",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -656,
        768
      ]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose"
          },
          "conditions": [
            {
              "id": "has-ig-results",
              "leftValue": "={{ $json._ig_match_count }}",
              "rightValue": "0",
              "operator": {
                "type": "number",
                "operation": "gt"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "84b243fa-2ecb-4b93-9078-21e3a1d267d9",
      "name": "IG Matches Found?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        -432,
        768
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $env.SUPABASE_URL }}/rest/v1/social_profiles",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "apikey",
              "value": "={{ $env.SUPABASE_SERVICE_KEY }}"
            },
            {
              "name": "Authorization",
              "value": "=Bearer {{ $env.SUPABASE_SERVICE_KEY }}"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            },
            {
              "name": "Prefer",
              "value": "resolution=merge-duplicates,return=minimal"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify($json._ig_social_rows) }}",
        "options": {}
      },
      "id": "6a6ed64e-9e32-4808-a6bb-19dd17be9892",
      "name": "Insert IG Social Profiles",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -208,
        848
      ],
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "jsCode": "// Final summary of the enrichment batch run\nconst config = $('Enrichment Config').first().json;\n\n// Collect stats from various paths\nlet companiesProcessed = 0;\nlet websitesFetched = 0;\nlet websiteErrors = 0;\nlet bookingDetected = 0;\nlet paidAdsDetected = 0;\nlet socialFromWebsite = 0;\nlet fbDiscovered = 0;\nlet igDiscovered = 0;\n\ntry {\n  const batchItems = $('Parse Batch').all();\n  companiesProcessed = batchItems.filter(i => !i.json._empty).length;\n} catch(e) {}\n\ntry {\n  const websiteItems = $('Analyze Website HTML').all();\n  for (const item of websiteItems) {\n    const enrichment = item.json._website_enrichment || {};\n    if (enrichment._website_fetch_status === 'success') websitesFetched++;\n    if (enrichment._website_fetch_status === 'error') websiteErrors++;\n    if (enrichment.has_online_booking) bookingDetected++;\n    if (enrichment.has_paid_ads) paidAdsDetected++;\n    socialFromWebsite += (enrichment.social_links_found || []).length;\n  }\n} catch(e) {}\n\ntry {\n  const fbResults = $('Match FB Results to Companies').first().json;\n  fbDiscovered = fbResults._fb_match_count || 0;\n} catch(e) {}\n\ntry {\n  const igResults = $('Match IG Results to Companies').first().json;\n  igDiscovered = igResults._ig_match_count || 0;\n} catch(e) {}\n\nconst summary = {\n  run_completed_at: new Date().toISOString(),\n  batch_size: config.batch_size,\n  batch_offset: config.batch_offset,\n  companies_processed: companiesProcessed,\n  websites_fetched_successfully: websitesFetched,\n  website_fetch_errors: websiteErrors,\n  booking_platforms_detected: bookingDetected,\n  paid_ads_detected: paidAdsDetected,\n  social_links_from_websites: socialFromWebsite,\n  facebook_pages_discovered: fbDiscovered,\n  instagram_profiles_discovered: igDiscovered,\n  total_social_profiles_created: socialFromWebsite + fbDiscovered + igDiscovered,\n  next_offset: Number(config.batch_offset) + Number(config.batch_size),\n  message: `Enriched ${companiesProcessed} companies. Update batch_offset to ${Number(config.batch_offset) + Number(config.batch_size)} for next run.`\n};\n\nconsole.log('=== ENRICHMENT RUN SUMMARY ===');\nconsole.log(JSON.stringify(summary, null, 2));\n\nreturn [{ json: summary }];"
      },
      "id": "47056c12-3c0f-4263-a32e-307da26ff9e5",
      "name": "Run Summary1",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        16,
        432
      ],
      "notes": "Final summary of the enrichment batch. Shows stats for websites analyzed, booking/ads detected, social profiles found. Provides next_offset for continuing with next batch."
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "batch-size",
              "name": "batch_size",
              "value": "100",
              "type": "string"
            },
            {
              "id": "batch-offset",
              "name": "batch_offset",
              "value": "0",
              "type": "string"
            },
            {
              "id": "skip-instagram",
              "name": "skip_instagram",
              "value": "true",
              "type": "string"
            },
            {
              "id": "skip-facebook",
              "name": "skip_facebook",
              "value": "true",
              "type": "string"
            },
            {
              "id": "skip-tiktok",
              "name": "skip_tiktok",
              "value": "true",
              "type": "string"
            },
            {
              "id": "skip-twitter",
              "name": "skip_twitter",
              "value": "true",
              "type": "string"
            },
            {
              "id": "skip-linkedin",
              "name": "skip_linkedin",
              "value": "true",
              "type": "string"
            },
            {
              "id": "skip-youtube",
              "name": "skip_youtube",
              "value": "true",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "id": "03f635b7-5fb7-47b0-b0de-20be39e9d0d5",
      "name": "Step 3b Config",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        448,
        432
      ],
      "notes": "CONFIGURE: batch_size = how many social profiles to process. Set skip_<platform> to 'true' to skip that platform."
    },
    {
      "parameters": {
        "url": "={{ $env.SUPABASE_URL }}/rest/v1/social_profiles?follower_count=is.null&order=scraped_at.asc&limit={{ $json.batch_size }}&offset={{ $json.batch_offset }}&select=id,company_id,platform,profile_url,follower_count,post_count,last_post_date,scraped_at",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "apikey",
              "value": "={{ $env.SUPABASE_SERVICE_KEY }}"
            },
            {
              "name": "Authorization",
              "value": "=Bearer {{ $env.SUPABASE_SERVICE_KEY }}"
            }
          ]
        },
        "options": {
          "timeout": 30000
        }
      },
      "id": "dacf43aa-0530-45b3-b9a5-b97f4f84ec65",
      "name": "Fetch Unenriched Social Profiles",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        672,
        432
      ],
      "notes": "Fetches social_profiles rows where follower_count is NULL (not yet enriched by SociaVault).",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "jsCode": "const items = $input.all();\nconst results = [];\nconst config = $('Step 3b Config').first().json;\nconst baseUrl = 'https://api.sociavault.com/v1/scrape';\n\nconst skipMap = {\n  instagram: config.skip_instagram,\n  facebook: config.skip_facebook,\n  tiktok: config.skip_tiktok,\n  x: config.skip_twitter,\n  twitter: config.skip_twitter,\n  linkedin: config.skip_linkedin,\n  youtube: config.skip_youtube\n};\n\nconst invalidHandles = [\n  'sharer', 'share', 'intent', 'login', 'help', 'about', 'policies', 'privacy',\n  'hashtag', 'explore', 'watch', 'results', 'search',\n  // Facebook non-profile paths (tracking pixels, SDK, plugins, etc.)\n  'tr', 'flx', 'plugins', 'dialog', 'ajax', 'ads', 'business', 'events',\n  'groups', 'marketplace', 'gaming', 'watch', 'reels', 'stories'\n];\n\nfor (const entry of items) {\n  const profile = entry.json;\n  const platform = (profile.platform || '').toLowerCase();\n  const url = (profile.profile_url || '').trim();\n\n  const shouldSkip = skipMap[platform] === 'true' || skipMap[platform] === true;\n  if (shouldSkip) {\n    results.push({ json: { ...profile, _skip: true, _skip_reason: `Platform ${platform} disabled`, _sociavault_url: '', _extracted_handle: '' } });\n    continue;\n  }\n\n  let handle = '';\n  try {\n    if (platform === 'instagram') {\n      const match = url.match(/instagram\\.com\\/([a-zA-Z0-9._]+)/i);\n      if (match) handle = match[1];\n    } else if (platform === 'facebook') {\n      const profileIdMatch = url.match(/profile\\.php\\?id=(\\d+)/);\n      if (profileIdMatch) {\n        handle = profileIdMatch[1];\n      } else {\n        const match = url.match(/facebook\\.com\\/([a-zA-Z0-9._-]+)/i);\n        if (match) handle = match[1];\n      }\n    } else if (platform === 'tiktok') {\n      const match = url.match(/tiktok\\.com\\/@([a-zA-Z0-9._-]+)/i);\n      if (match) handle = match[1];\n    } else if (platform === 'x' || platform === 'twitter') {\n      const match = url.match(/(?:twitter|x)\\.com\\/([a-zA-Z0-9_]+)/i);\n      if (match) handle = match[1];\n    } else if (platform === 'linkedin') {\n      const companyMatch = url.match(/linkedin\\.com\\/company\\/([a-zA-Z0-9._-]+)/i);\n      const personMatch = url.match(/linkedin\\.com\\/in\\/([a-zA-Z0-9._-]+)/i);\n      handle = companyMatch ? companyMatch[1] : (personMatch ? personMatch[1] : '');\n    } else if (platform === 'youtube') {\n      const handleMatch = url.match(/youtube\\.com\\/@([a-zA-Z0-9._-]+)/i);\n      const channelMatch = url.match(/youtube\\.com\\/channel\\/([a-zA-Z0-9_-]+)/i);\n      const cMatch = url.match(/youtube\\.com\\/c\\/([a-zA-Z0-9._-]+)/i);\n      handle = handleMatch ? handleMatch[1] : (channelMatch ? channelMatch[1] : (cMatch ? cMatch[1] : ''));\n    }\n  } catch (e) {}\n\n  if (invalidHandles.includes(handle.toLowerCase())) handle = '';\n\n  if (!handle) {\n    results.push({ json: { ...profile, _skip: true, _skip_reason: `Could not extract handle from URL: ${url}`, _sociavault_url: '', _extracted_handle: '' } });\n    continue;\n  }\n\n  let sociavaultUrl = '';\n  if (platform === 'instagram') {\n    sociavaultUrl = `${baseUrl}/instagram/profile?handle=${encodeURIComponent(handle)}`;\n  } else if (platform === 'facebook') {\n    // Facebook endpoint requires the full profile URL with https://\n    let fbUrl = url;\n    if (!fbUrl.startsWith('http')) {\n      fbUrl = 'https://' + fbUrl;\n    }\n    // Ensure https (not http)\n    fbUrl = fbUrl.replace(/^http:\\/\\//, 'https://');\n    sociavaultUrl = `${baseUrl}/facebook/profile?url=${encodeURIComponent(fbUrl)}`;\n  } else if (platform === 'tiktok') {\n    sociavaultUrl = `${baseUrl}/tiktok/profile?handle=${encodeURIComponent(handle)}`;\n  } else if (platform === 'x' || platform === 'twitter') {\n    sociavaultUrl = `${baseUrl}/twitter/profile?handle=${encodeURIComponent(handle)}`;\n  } else if (platform === 'linkedin') {\n    const isCompany = url.includes('/company/');\n    sociavaultUrl = isCompany\n      ? `${baseUrl}/linkedin/company?username=${encodeURIComponent(handle)}`\n      : `${baseUrl}/linkedin/profile?username=${encodeURIComponent(handle)}`;\n  } else if (platform === 'youtube') {\n    const isChannelId = handle.startsWith('UC');\n    sociavaultUrl = isChannelId\n      ? `${baseUrl}/youtube/channel?channel_id=${encodeURIComponent(handle)}`\n      : `${baseUrl}/youtube/channel?handle=${encodeURIComponent(handle)}`;\n  }\n\n  if (!sociavaultUrl) {\n    results.push({ json: { ...profile, _skip: true, _skip_reason: `Unsupported platform: ${platform}`, _sociavault_url: '', _extracted_handle: handle } });\n    continue;\n  }\n\n  results.push({ json: { ...profile, _skip: false, _skip_reason: null, _sociavault_url: sociavaultUrl, _extracted_handle: handle, _platform: platform } });\n}\n\nreturn results;"
      },
      "id": "cf4e0257-cfc4-44e6-8364-d7c36d5aa120",
      "name": "Build SociaVault Request",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1344,
        528
      ],
      "notes": "Extracts username/handle from profile_url, builds SociaVault API URL per platform. Skips unparseable profiles."
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose"
          },
          "conditions": [
            {
              "id": "should-skip",
              "leftValue": "={{ $json._skip }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "notEquals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "ea99682f-2982-4a5f-9a54-9edd80bcbe6e",
      "name": "Should Enrich?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        1568,
        528
      ]
    },
    {
      "parameters": {
        "url": "={{ $json._sociavault_url }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "X-API-Key",
              "value": "={{ $env.SOCIAVAULT_API_KEY }}"
            }
          ]
        },
        "options": {
          "batching": {
            "batch": {
              "batchSize": 5,
              "batchInterval": 2000
            }
          },
          "timeout": 30000
        }
      },
      "id": "ab74e793-f3e6-4b75-a1ec-4123a3e069d4",
      "name": "Call SociaVault API",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1792,
        464
      ],
      "onError": "continueRegularOutput",
      "notes": "Calls SociaVault profile endpoint. Batched 5 at a time with 2s delay. On error, continues."
    },
    {
      "parameters": {
        "jsCode": "// runOnceForAllItems \u2014 index-paired with Should Enrich?\nconst upstreamAll = $('Should Enrich?').all();\nconst inputAll = $input.all();\nconst results = [];\n\nfor (let i = 0; i < inputAll.length; i++) {\n  const response = inputAll[i].json;\n  const profileData = upstreamAll[i].json;\n  const platform = profileData._platform;\n  const profileId = profileData.id;\n  const companyId = profileData.company_id;\n  let follower_count = null;\n  let post_count = null;\n  let last_post_date = null;\n  let fetchStatus = 'success';\n  let errorMsg = null;\n  try {\n    if (response.error || response.status === 'error' || response.success === false) {\n      fetchStatus = 'error';\n      errorMsg = response.error || response.message || 'API returned error';\n    } else if (platform === 'instagram') {\n      const user = response.data?.data?.user || response.data?.user || response.user || response.data || {};\n      follower_count = user.edge_followed_by?.count ?? user.follower_count ?? user.followers_count ?? null;\n      post_count = user.edge_owner_to_timeline_media?.count ?? user.media_count ?? null;\n      const edges = user.edge_owner_to_timeline_media?.edges || [];\n      const edgeArray = Array.isArray(edges) ? edges : Object.values(edges);\n      if (edgeArray.length > 0) {\n        const firstPost = edgeArray[0]?.node || edgeArray[0] || {};\n        if (firstPost.taken_at) {\n          last_post_date = new Date(firstPost.taken_at * 1000).toISOString().split('T')[0];\n        }\n      }\n    } else if (platform === 'facebook') {\n      const data = response.data || response;\n      follower_count = data.followerCount ?? data.follower_count ?? data.followers_count ?? data.likes ?? data.likeCount ?? data.fan_count ?? null;\n      post_count = data.posts_count ?? data.postCount ?? null;\n    } else if (platform === 'tiktok') {\n      const stats = response.data?.userInfo?.stats || response.data?.stats || {};\n      const user = response.data?.userInfo?.user || response.data?.user || response.data || response;\n      follower_count = stats.followerCount ?? user.followerCount ?? user.followers_count ?? null;\n      post_count = stats.videoCount ?? user.videoCount ?? null;\n    } else if (platform === 'x' || platform === 'twitter') {\n      const data = response.data || {};\n      const legacy = data.legacy || {};\n      const user = data.user || data;\n      follower_count = legacy.followers_count ?? legacy.normal_followers_count ?? user.followers_count ?? user.followerCount ?? user.public_metrics?.followers_count ?? null;\n      post_count = legacy.statuses_count ?? user.statuses_count ?? user.tweet_count ?? user.public_metrics?.tweet_count ?? null;\n      if (data.message === \"Account doesn't exist\" || data.userId === null && data.handle) {\n        fetchStatus = 'not_found';\n        errorMsg = `Account @${data.handle} does not exist`;\n        follower_count = null;\n        post_count = null;\n      }\n      if (user.status?.created_at) {\n        try { last_post_date = new Date(user.status.created_at).toISOString().split('T')[0]; } catch(e) {}\n      }\n    } else if (platform === 'linkedin') {\n      const data = response.data || response;\n      follower_count = data.followerCount ?? data.followers_count ?? data.followersCount ?? null;\n    } else if (platform === 'youtube') {\n      const data = response.data || response;\n      follower_count = data.subscriberCount ?? data.subscriber_count ?? data.statistics?.subscriberCount ?? null;\n      post_count = data.videoCount ?? data.video_count ?? data.statistics?.videoCount ?? null;\n      if (typeof follower_count === 'string') follower_count = parseInt(follower_count, 10);\n      if (typeof post_count === 'string') post_count = parseInt(post_count, 10);\n    }\n    if (follower_count !== null) follower_count = Number(follower_count) || null;\n    if (post_count !== null) post_count = Number(post_count) || null;\n  } catch (e) {\n    fetchStatus = 'error';\n    errorMsg = 'Parse error: ' + e.message;\n  }\n  results.push({ json: { _profile_id: profileId, _company_id: companyId, _platform: platform, _extracted_handle: profileData._extracted_handle, _fetch_status: fetchStatus, _error: errorMsg, _update_payload: { follower_count, post_count, last_post_date, scraped_at: new Date().toISOString() } } });\n}\n\nreturn results;"
      },
      "id": "272a14b7-7dde-4a86-8f25-f93ab3f05a59",
      "name": "Parse SociaVault Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2016,
        464
      ],
      "notes": "Extracts follower_count, post_count, last_post_date from SociaVault response per platform."
    },
    {
      "parameters": {
        "method": "PATCH",
        "url": "={{ $env.SUPABASE_URL }}/rest/v1/social_profiles?id=eq.{{ $json._profile_id }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "apikey",
              "value": "={{ $env.SUPABASE_SERVICE_KEY }}"
            },
            {
              "name": "Authorization",
              "value": "=Bearer {{ $env.SUPABASE_SERVICE_KEY }}"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            },
            {
              "name": "Prefer",
              "value": "return=minimal"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify($json._update_payload) }}",
        "options": {
          "batching": {
            "batch": {
              "batchSize": 10,
              "batchInterval": 500
            }
          }
        }
      },
      "id": "351b351e-22fe-4756-bd35-c2816fb2bb41",
      "name": "Update Social Profile in Supabase",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        2240,
        464
      ],
      "onError": "continueRegularOutput",
      "notes": "PATCH updates social_profiles row. Batched 10 at a time with 500ms delay."
    },
    {
      "parameters": {
        "jsCode": "const allInputs = $input.all();\nlet profiles = [];\n\nif (allInputs.length === 1 && Array.isArray(allInputs[0].json)) {\n  profiles = allInputs[0].json;\n} else {\n  profiles = allInputs.map(i => i.json);\n}\n\nif (!profiles || profiles.length === 0 || (profiles.length === 1 && !profiles[0].id)) {\n  return [{ json: { _empty: true, _count: 0, _message: 'No unenriched social profiles found' } }];\n}\n\nconsole.log('Batch loaded: ' + profiles.length + ' social profiles to enrich');\nreturn profiles.map(p => ({ json: p }));"
      },
      "id": "b839fab2-2974-4430-96a9-bacc19c88368",
      "name": "Parse Batch1",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        896,
        432
      ]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose"
          },
          "conditions": [
            {
              "id": "empty-check",
              "leftValue": "={{ $json._empty }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "ed584da2-06d7-42e6-a032-b508e58c7074",
      "name": "Batch Empty?1",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        1120,
        432
      ]
    },
    {
      "parameters": {
        "jsCode": "return [{ json: { message: 'No unenriched social profiles found. Step 3b complete.', completed_at: new Date().toISOString() } }];"
      },
      "id": "f670d029-36b1-4113-94ae-b424d050ced6",
      "name": "No Records - Done1",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1344,
        336
      ]
    },
    {
      "parameters": {
        "jsCode": "const config = $('Step 3b Config').first().json;\nlet totalProcessed = 0, enriched = 0, errors = 0, skipped = 0;\nconst platformCounts = {};\nconst errorDetails = [];\n\ntry {\n  const allItems = $('Build SociaVault Request').all();\n  totalProcessed = allItems.length;\n  skipped = allItems.filter(i => i.json._skip === true).length;\n} catch(e) {}\n\ntry {\n  const results = $('Parse SociaVault Response').all();\n  for (const item of results) {\n    const data = item.json;\n    const platform = data._platform || 'unknown';\n    if (!platformCounts[platform]) platformCounts[platform] = { success: 0, error: 0 };\n    if (data._fetch_status === 'error') {\n      errors++;\n      platformCounts[platform].error++;\n      errorDetails.push({ handle: data._extracted_handle, platform: data._platform, error: data._error });\n    } else {\n      enriched++;\n      platformCounts[platform].success++;\n    }\n  }\n} catch(e) {}\n\nconst summary = {\n  run_completed_at: new Date().toISOString(),\n  batch_size: config.batch_size,\n  batch_offset: config.batch_offset,\n  total_profiles_in_batch: totalProcessed,\n  skipped, enriched, errors,\n  platform_breakdown: platformCounts,\n  error_details: errorDetails.slice(0, 10),\n  next_offset: Number(config.batch_offset) + Number(config.batch_size),\n  message: `Enriched ${enriched} social profiles (${errors} errors, ${skipped} skipped).`\n};\n\nconsole.log('=== STEP 3b: SOCIAL ENRICHMENT SUMMARY ===');\nconsole.log(JSON.stringify(summary, null, 2));\nreturn [{ json: summary }];"
      },
      "id": "b6823dfa-63a0-4c3a-827b-824ce9870eac",
      "name": "Run Summary2",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2464,
        544
      ],
      "notes": "Final summary with per-platform breakdown."
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "version": 3,
            "leftValue": "",
            "caseSensitive": true,
            "typeValidation": "loose"
          },
          "conditions": [
            {
              "id": "b807db58-4ea5-4a80-893d-18a9609d454a",
              "leftValue": "={{ $json.domain }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "empty"
              }
            },
            {
              "id": "1650bd01-dca9-4d41-932b-501666c3ff50",
              "leftValue": "={{ $json.has_website }}",
              "rightValue": "true",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.3,
      "position": [
        -6480,
        288
      ],
      "id": "4960eeab-3e4d-4120-b6c1-7901d35c7228",
      "name": "Needs Backfill?"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://places.googleapis.com/v1/places:searchText",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "X-Goog-FieldMask",
              "value": "places.id,places.displayName,places.nationalPhoneNumber,places.internationalPhoneNumber,places.websiteUri,places.rating,places.userRatingCount"
            },
            {
              "name": "X-Goog-Api-Key",
              "value": "={{ $env.GOOGLE_PLACES_API_KEY }}"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"textQuery\": \"{{ $json.name }} {{ $json.city }} {{ $json.state }}\",\n  \"maxResultCount\": 3\n}",
        "options": {
          "batching": {
            "batch": {
              "batchSize": 5
            }
          }
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [
        -6256,
        208
      ],
      "id": "7152cbc1-bc54-4ffc-86a2-5444784f029e",
      "name": "Google Places Lookup",
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "jsCode": "// runOnceForAllItems \u2014 index-paired with Needs Backfill?\nconst upstreamAll = $('Needs Backfill?').all();\nconst inputAll = $input.all();\nconst results = [];\n\n// Hoisted constant\nconst BLOCKED_DOMAINS = ['wixsite.com','wix.com','setmore.com','schedulista.com','glossgenius.com','square.site','genbook.com','jane.app','acuityscheduling.com','mindbodyonline.com','mindbody.io','vagaro.com','fresha.com','schedulicity.com','booksy.com','massagebook.com','noterro.com','clinicsense.com','calendly.com','squarespace.com'];\n\nfor (let i = 0; i < inputAll.length; i++) {\n  const company = upstreamAll[i].json;\n  const response = inputAll[i].json;\n  const places = response.places || [];\n\n  if (places.length === 0) {\n    results.push({ json: { ...company } });\n    continue;\n  }\n\n  const companyName = (company.name || '').toLowerCase().replace(/[^a-z0-9\\s]/g, '');\n  const companyPhone = (company.phone || '').replace(/[^\\d]/g, '');\n\n  let bestMatch = null;\n  let bestScore = 0;\n\n  for (const place of places) {\n    const placeName = ((place.displayName && place.displayName.text) || '').toLowerCase().replace(/[^a-z0-9\\s]/g, '');\n    let score = 0;\n\n    const companyWords = companyName.split(/\\s+/).filter(w => w.length > 2);\n    const placeWords = placeName.split(/\\s+/).filter(w => w.length > 2);\n    const matchingWords = companyWords.filter(w => placeWords.some(pw => pw.includes(w) || w.includes(pw)));\n    score = companyWords.length > 0 ? matchingWords.length / companyWords.length : 0;\n\n    const placePhone = (place.internationalPhoneNumber || place.nationalPhoneNumber || '').replace(/[^\\d]/g, '');\n    if (companyPhone && placePhone && (placePhone.includes(companyPhone.slice(-10)) || companyPhone.includes(placePhone.slice(-10)))) {\n      score += 0.5;\n    }\n\n    if (score > bestScore && score >= 0.4) {\n      bestScore = score;\n      bestMatch = place;\n    }\n  }\n\n  if (!bestMatch) {\n    results.push({ json: { ...company } });\n    continue;\n  }\n\n  const website = bestMatch.websiteUri || '';\n  let domain = null;\n  if (website) {\n    const match = website.match(/^https?:\\/\\/(?:www\\.)?([^\\/]+)/i);\n    if (match) domain = match[1];\n  }\n\n  // Check domain against blocklist\n  let _domain_blocked = false;\n  let _domain_blocked_platform = '';\n  if (domain) {\n    const lowerDomain = domain.toLowerCase();\n    for (const blocked of BLOCKED_DOMAINS) {\n      if (lowerDomain === blocked || lowerDomain.endsWith('.' + blocked)) {\n        _domain_blocked = true;\n        _domain_blocked_platform = blocked;\n        domain = null;\n        break;\n      }\n    }\n  }\n\n  // Merge found data into the company item so downstream nodes see it\n  const updated = { ...company };\n  if (bestMatch.id && !company.google_place_id) updated.google_place_id = bestMatch.id;\n  if (domain) {\n    updated.domain = domain;\n    updated.has_website = true;\n  }\n  if (_domain_blocked) {\n    updated._domain_blocked = true;\n    updated._domain_blocked_platform = _domain_blocked_platform;\n  }\n  if (bestMatch.rating && !company.google_rating) updated.google_rating = bestMatch.rating;\n  if (bestMatch.userRatingCount && !company.google_review_count) updated.google_review_count = bestMatch.userRatingCount;\n\n  // Build Supabase patch payload - only include domain if not blocked\n  const patch = {};\n  if (updated.google_place_id !== company.google_place_id) patch.google_place_id = updated.google_place_id;\n  if (domain) {\n    patch.domain = domain;\n    if (updated.has_website !== company.has_website) patch.has_website = updated.has_website;\n  }\n  if (updated.google_rating !== company.google_rating) patch.google_rating = updated.google_rating;\n  if (updated.google_review_count !== company.google_review_count) patch.google_review_count = updated.google_review_count;\n\n  updated._backfill_patch = Object.keys(patch).length > 0 ? patch : null;\n  updated._backfill_matched = bestMatch.displayName?.text || '';\n  updated._backfill_score = bestScore;\n\n  results.push({ json: updated });\n}\n\nreturn results;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -6032,
        224
      ],
      "id": "6331ba97-df66-4a50-a69b-ec74a0b95843",
      "name": "Extract & Patch Domain"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        -5808,
        288
      ],
      "id": "e225430f-6efa-4b41-a7ea-6b456dce326f",
      "name": "Merge Backfill"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "batch-size",
              "name": "batch_size",
              "value": "1000",
              "type": "string"
            },
            {
              "id": "batch-offset",
              "name": "batch_offset",
              "value": "0",
              "type": "string"
            },
            {
              "id": "skip-apollo",
              "name": "skip_apollo",
              "value": "false",
              "type": "string"
            },
            {
              "id": "skip-website-scrape",
              "name": "skip_website_scrape",
              "value": "false",
              "type": "string"
            },
            {
              "id": "apollo-enrich-enabled",
              "name": "apollo_enrich_enabled",
              "value": "true",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "id": "d6400060-d28a-4b98-8ab9-b5af12f79118",
      "name": "Step 3a Config",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        2992,
        528
      ],
      "notes": "CONFIGURE: batch_size = companies per run. skip_apollo/skip_website_scrape to bypass sub-steps. apollo_enrich_enabled = set false to save credits (search only, no enrich)."
    },
    {
      "parameters": {
        "url": "={{ $env.SUPABASE_URL }}/rest/v1/companies?enrichment_status=in.(partially_enriched,fully_enriched)&discovery_metro=eq.{{ $('Metro Config').first().json.metro_name }}&order=lead_score.desc,discovered_at.asc&limit={{ $json.batch_size }}&offset={{ $json.batch_offset }}&select=id,name,phone,domain,address,city,state,country,google_place_id,category,estimated_size,has_website,google_review_count,google_rating",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "apikey",
              "value": "={{ $env.SUPABASE_SERVICE_KEY }}"
            },
            {
              "name": "Authorization",
              "value": "=Bearer {{ $env.SUPABASE_SERVICE_KEY }}"
            }
          ]
        },
        "options": {
          "timeout": 30000
        }
      },
      "id": "fba4044a-fb9b-49aa-9cec-9fc4f093935d",
      "name": "Fetch Companies",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        3216,
        528
      ],
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "url": "={{ $env.SUPABASE_URL }}/rest/v1/contacts?select=company_id",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "apikey",
              "value": "={{ $env.SUPABASE_SERVICE_KEY }}"
            },
            {
              "name": "Authorization",
              "value": "=Bearer {{ $env.SUPABASE_SERVICE_KEY }}"
            }
          ]
        },
        "options": {
          "timeout": 30000
        }
      },
      "id": "5424ae75-5839-4493-8439-c126a74c8321",
      "name": "Fetch Existing Contacts",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        3440,
        528
      ],
      "alwaysOutputData": true,
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "jsCode": "// Get companies from upstream Fetch Companies node\nconst companyItems = $('Fetch Companies').all();\nlet companies = [];\nif (companyItems.length === 1 && Array.isArray(companyItems[0].json)) {\n  companies = companyItems[0].json;\n} else {\n  companies = companyItems.map(i => i.json);\n}\n\n// Get existing contact company_ids\nconst contactItems = $input.all();\nlet existingIds = new Set();\nfor (const item of contactItems) {\n  if (item.json && item.json.company_id) {\n    existingIds.add(item.json.company_id);\n  }\n  // Handle array response\n  if (Array.isArray(item.json)) {\n    for (const row of item.json) {\n      if (row.company_id) existingIds.add(row.company_id);\n    }\n  }\n}\n\n// Filter out companies that already have contacts\nconst filtered = companies.filter(c => c.id && !existingIds.has(c.id));\n\nconsole.log(`Companies: ${companies.length} total, ${existingIds.size} already have contacts, ${filtered.length} need people discovery`);\n\nif (filtered.length === 0) {\n  return [{ json: { _empty: true, _count: 0, _message: 'All companies already have contacts or no companies to process' } }];\n}\n\nreturn filtered.map(c => ({ json: c }));"
      },
      "id": "07d62a02-17a6-4bab-910b-0f26be520010",
      "name": "Filter & Parse Batch",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3664,
        528
      ]
    },
    {
      "parameters": {
        "jsCode": "// runOnceForAllItems \u2014 hoist name list + helper outside loop\nconst items = $input.all();\nconst results = [];\n\nconst commonFirstNames = new Set([\n  'aaron','abby','abigail','adam','adrian','adriana','aiden','aimee','alana','albert',\n  'alec','alexa','alexander','alexandra','alexis','alice','alicia','alina','alison','allison',\n  'alyssa','amanda','amber','amelia','amy','ana','andrea','andrew','angela','angelica',\n  'angie','anita','ann','anna','anne','annie','anthony','april','aria','ariana',\n  'ashley','audrey','austin','autumn','ava','avery','bailey','barbara','beatrice','becky',\n  'bella','ben','benjamin','beth','bethany','betty','beverly','bianca','blake','bonnie',\n  'brad','bradley','brandi','brandon','brandy','breanna','brenda','brent','brett','brian',\n  'briana','brianna','bridget','brittany','brittney','brooke','bruce','bryan','caitlin','caleb',\n  'cameron','camila','candace','cara','carina','carl','carla','carlos','carly','carmen',\n  'carol','carolina','caroline','carolyn','carrie','casey','cassandra','cassidy','catherine','cathy',\n  'cecilia','celeste','celia','chad','charlene','charles','charlie','charlotte','chase','chelsea',\n  'cheryl','chloe','chris','christa','christian','christina','christine','christopher','cindy','claire',\n  'clara','claudia','cody','colleen','connor','constance','corey','corinne','courtney','craig',\n  'crystal','cynthia','daisy','dale','dana','daniel','daniela','danielle','daphne','darlene',\n  'darren','dave','david','dawn','dean','deanna','debbie','deborah','debra','denise',\n  'derek','desiree','destiny','diana','diane','dianne','dolores','dominic','donna','doris',\n  'dorothy','douglas','drew','dustin','dylan','eddie','edith','edward','eileen','elaine',\n  'elena','elisa','elizabeth','ella','ellen','ellie','emily','emma','eric','erica',\n  'erika','erin','ernest','esther','ethan','eugene','eva','evan','evelyn','faith',\n  'faye','felicia','fiona','florence','frances','frank','gabriel','gabriela','gabriella','gabrielle',\n  'gail','gary','gavin','genevieve','george','georgia','gerald','gina','giselle','gladys',\n  'glen','glenn','gloria','grace','grant','greg','gregory','gretchen','hailey','haley',\n  'hannah','harold','harriet','harry','hayden','hazel','heather','heidi','helen','henry',\n  'hillary','holly','hope','howard','hunter','ian','irene','iris','isaac','isabel',\n  'isabella','ivy','jack','jackie','jackson','jacob','jacqueline','jade','jaime','jake',\n  'james','jamie','jan','jane','janet','janice','jared','jasmine','jason','jay',\n  'jean','jeanette','jeanne','jeff','jeffrey','jenna','jennifer','jenny','jeremy','jerry',\n  'jesse','jessica','jill','jillian','jim','jimmy','jo','joan','joann','joanna',\n  'joanne','jocelyn','jodi','jody','joe','joel','johanna','john','johnny','jolene',\n  'jon','jonathan','jordan','jorge','jose','joseph','josephine','josh','joshua','joy',\n  'joyce','juan','judith','judy','julia','julian','juliana','julie','june','justin',\n  'kaitlyn','kara','karen','karina','karl','kate','katelyn','katherine','kathleen','kathryn',\n  'kathy','katie','katrina','kay','kayla','keith','kelley','kelli','kelly','kelsey',\n  'ken','kendra','kenneth','kenny','kerry','kevin','kim','kimberly','kirsten','krista',\n  'kristen','kristin','kristina','kristy','kyle','kylie','lacey','lana','lance','larry',\n  'laura','lauren','laurie','leah','lee','leigh','lena','leo','leon','leslie',\n  'lexy','liam','lillian','lily','linda','lindsay','lindsey','lisa','logan','lois',\n  'lora','lorena','lori','lorraine','louis','louise','lucia','luis','luke','lydia',\n  'lynn','mackenzie','madeline','madison','maggie','malik','mallory','mandy','marc','marcia',\n  'marco','marcus','margaret','maria','mariah','marie','marilyn','marina','mario','marisa',\n  'marissa','mark','marlene','marsha','martha','martin','mary','mason','matt','matthew',\n  'maureen','max','maya','megan','meghan','melanie','melinda','melissa','melody','meredith',\n  'mia','michael','michele','michelle','miguel','mike','mildred','mindy','miranda','misty',\n  'mitchell','molly','monica','monique','morgan','mya','nadia','nancy','naomi','natalia',\n  'natalie','natasha','nathan','nathaniel','neil','nelson','nicholas','nicole','nina','noah',\n  'noel','nora','norma','olivia','owen','paige','pam','pamela','patricia','patrick',\n  'patty','paul','paula','pauline','peggy','penny','peter','philip','phyllis','priscilla',\n  'rachel','ralph','ramona','randall','randy','ray','raymond','rebecca','regina','renee',\n  'rhonda','ricardo','richard','rick','ricky','riley','rita','rob','robert','roberta',\n  'robin','rochelle','rodney','roger','ronald','rosa','rosalie','rose','rosemary','roxanne',\n  'ruby','russell','ruth','ryan','sabrina','sally','samantha','samuel','sandra','sandy',\n  'sara','sarah','savannah','scott','sean','selena','serena','seth','shana','shane',\n  'shannon','sharon','shawn','sheila','shelby','shelley','shelly','sheri','sherri','sherry',\n  'shirley','sierra','silvia','simone','sofia','sonia','sonya','sophia','stacey','stacy',\n  'stella','stephanie','stephen','steve','steven','sue','summer','susan','suzanne','sydney',\n  'sylvia','tabitha','tamara','tammy','tanya','tara','tatiana','taylor','teresa','terri',\n  'terry','tess','tessa','theresa','thomas','tiffany','tim','timothy','tina','tito',\n  'todd','tom','tommy','toni','tony','tonya','tracey','traci','tracy','travis',\n  'tricia','trisha','troy','tyler','valerie','vanessa','vera','veronica','vicki','vicky',\n  'victoria','vincent','violet','virginia','vivian','wade','walter','wanda','warren','wayne',\n  'wendy','wesley','whitney','william','willie','wilma','xavier','yolanda','yvette','yvonne',\n  'zachary','zoe'\n]);\n\nfunction isLikelyFirstName(word) {\n  return commonFirstNames.has(word.toLowerCase());\n}\n\nfor (const entry of items) {\n  const item = entry.json;\n  const name = (item.name || '').trim();\n  const estimatedSize = item.estimated_size;\n\n  let isSolo = false;\n  let firstName = null;\n  let lastName = null;\n\n  // Pattern 1: \"by Name\" pattern - \"Bodywork by Benna\", \"Massage by Celeste\"\n  const byPattern = name.match(/\\bby\\s+([A-Z][a-z]+)(?:\\s+([A-Z][a-z]+))?/i);\n  if (byPattern) {\n    const candidate = byPattern[1];\n    if (isLikelyFirstName(candidate) || estimatedSize === 'solo') {\n      isSolo = true;\n      firstName = candidate;\n      lastName = byPattern[2] || null;\n    }\n  }\n\n  // Pattern 2: \"with Name\" pattern\n  if (!firstName) {\n    const withPattern = name.match(/\\bwith\\s+([A-Z][a-z]+)(?:\\s+([A-Z][a-z]+))?/i);\n    if (withPattern) {\n      const candidate = withPattern[1];\n      if (isLikelyFirstName(candidate) || estimatedSize === 'solo') {\n        isSolo = true;\n        firstName = candidate;\n        lastName = withPattern[2] || null;\n      }\n    }\n  }\n\n  // Pattern 3: Possessive - \"Lexy's Massage\"\n  if (!firstName) {\n    const possessiveMatch = name.match(/^([A-Z][a-z]+)'s\\s+/i);\n    if (possessiveMatch && isLikelyFirstName(possessiveMatch[1])) {\n      isSolo = true;\n      firstName = possessiveMatch[1];\n    }\n  }\n\n  // Pattern 4: \"FirstName LastName, LMT/CMT/RMT\"\n  if (!firstName) {\n    const nameFirst = name.match(/^([A-Z][a-z]+)\\s+([A-Z][a-z]+)(?:\\s*[,|]\\s*|\\s+)(?:LMT|CMT|RMT|Licensed|Massage|Bodywork|Therapeutic|Wellness)/i);\n    if (nameFirst) {\n      const fn = nameFirst[1];\n      const ln = nameFirst[2];\n      if (isLikelyFirstName(fn) && !commonFirstNames.has(ln.toLowerCase())) {\n        isSolo = true;\n        firstName = fn;\n        lastName = ln;\n      }\n    }\n  }\n\n  // Pattern 5: \"FirstName LastName's Massage/Spa\"\n  if (!firstName) {\n    const possessiveFullName = name.match(/^([A-Z][a-z]+)\\s+([A-Z][a-z]+)'s\\s+(?:Massage|Bodywork|Wellness|Spa|Healing)/i);\n    if (possessiveFullName && isLikelyFirstName(possessiveFullName[1])) {\n      isSolo = true;\n      firstName = possessiveFullName[1];\n      lastName = possessiveFullName[2];\n    }\n  }\n\n  // Pattern 6: Three-part name with title\n  if (!firstName) {\n    const threePartName = name.match(/^([A-Z][a-z]+)\\s+([A-Z][a-z]+)\\s+([A-Z][a-z]+),?\\s+(?:LMT|CMT|RMT|Licensed)/i);\n    if (threePartName && isLikelyFirstName(threePartName[1])) {\n      isSolo = true;\n      firstName = threePartName[1];\n      lastName = threePartName[3];\n    }\n  }\n\n  // Pattern 7: Name embedded after comma\n  if (!firstName) {\n    const commaNameMatch = name.match(/,\\s*([A-Z][a-z]+)\\s+([A-Z][a-z]+)(?:\\s*,?\\s*(?:LMT|CMT|RMT|Licensed))?/i);\n    if (commaNameMatch && isLikelyFirstName(commaNameMatch[1])) {\n      isSolo = true;\n      firstName = commaNameMatch[1];\n      lastName = commaNameMatch[2];\n    }\n  }\n\n  // If estimated_size is solo but no name extracted, still flag as solo\n  if (estimatedSize === 'solo' && !isSolo) {\n    isSolo = true;\n  }\n\n  // Reject if extracted first name matches the company's city\n  if (firstName && item.city && firstName.toLowerCase() === item.city.toLowerCase()) {\n    firstName = null;\n    lastName = null;\n  }\n\n  results.push({\n    json: {\n      ...item,\n      _is_solo: isSolo,\n      _solo_first_name: firstName,\n      _solo_last_name: lastName\n    }\n  });\n}\n\nreturn results;"
      },
      "id": "56176ae4-01b1-4fbb-9ec9-894c5dd24eff",
      "name": "Solo Practitioner Check",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        4112,
        624
      ],
      "notes": "Detects solo practitioners from estimated_size='solo' or business name patterns. Extracts first/last name from business name to avoid wasting API credits."
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose"
          },
          "conditions": [
            {
              "id": "is-solo",
              "leftValue": "={{ $json._is_solo }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "90cfe293-7c3e-457d-867e-63f5315914b1",
      "name": "Is Solo?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        4416,
        512
      ]
    },
    {
      "parameters": {
        "jsCode": "const items = $input.all();\nconst results = [];\n\nfor (const entry of items) {\n  const item = entry.json;\n  results.push({\n    json: {\n      _contact: {\n        company_id: item.id,\n        first_name: item._solo_first_name || null,\n        last_name: item._solo_last_name || null,\n        role: 'owner',\n        is_owner: true,\n        email_business: null,\n        email_personal: null,\n        phone_direct: null,\n        linkedin_url: null,\n        location: [item.city, item.state].filter(Boolean).join(', ') || null,\n        cultural_affinity: null,\n        source: 'solo_detection'\n      },\n      _company_name: item.name,\n      _company_id: item.id,\n      _source_method: 'solo_detection',\n      _has_contact: !!(item._solo_first_name)\n    }\n  });\n}\n\nreturn results;"
      },
      "id": "52a5a162-ed46-4a80-93c6-aec6bc23fd66",
      "name": "Prepare Solo Contact",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        5584,
        48
      ]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose"
          },
          "conditions": [
            {
              "id": "has-domain",
              "leftValue": "={{ $json.domain }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "notEquals"
              }
            },
            {
              "id": "not-skip-apollo",
              "leftValue": "={{ $('Step 3a Config').first().json.skip_apollo }}",
              "rightValue": "true",
              "operator": {
                "type": "string",
                "operation": "notEquals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "801a7433-0b2e-46f8-bc18-057ec867313b",
      "name": "Has Domain & Apollo?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        4640,
        608
      ],
      "notes": "Routes to Apollo search if company has a domain AND apollo is not skipped. Otherwise goes to website scrape fallback."
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.apollo.io/api/v1/mixed_people/api_search",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            },
            {
              "name": "Cache-Control",
              "value": "no-cache"
            },
            {
              "name": "X-Api-Key",
              "value": "={{ $env.APOLLO_API_KEY }}"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"q_organization_domains\": \"{{ $json.domain }}\",\n  \"person_titles\": [\"owner\", \"founder\", \"ceo\", \"proprietor\", \"director\", \"manager\", \"massage therapist\", \"licensed massage therapist\"],\n  \"per_page\": 5\n}",
        "options": {
          "timeout": 15000,
          "batching": {
            "batch": {
              "batchSize": 3,
              "batchInterval": 2000
            }
          }
        }
      },
      "id": "f07c5c38-08ff-4038-87b0-54d90e26424b",
      "name": "Apollo People Search",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        4848,
        496
      ],
      "onError": "continueRegularOutput",
      "notes": "FREE - does not consume credits. Searches for people at the company's domain. Returns person IDs with obfuscated last names."
    },
    {
      "parameters": {
        "jsCode": "// runOnceForAllItems \u2014 index-paired with Solo Practitioner Check\nconst upstreamAll = $('Solo Practitioner Check').all();\nconst inputAll = $input.all();\nconst results = [];\n\n// Hoisted keyword arrays\nconst ownerKeywords = ['owner', 'founder', 'ceo', 'proprietor', 'principal', 'co-founder'];\nconst managerKeywords = ['manager', 'director', 'general manager', 'gm', 'head'];\nconst practitionerKeywords = ['massage', 'therapist', 'lmt', 'cmt', 'rmt', 'bodywork', 'esthetician'];\n\nfor (let i = 0; i < inputAll.length; i++) {\n  const company = upstreamAll[i].json;\n  const response = inputAll[i].json;\n  const people = response.people || [];\n\n  if (!people || people.length === 0) {\n    results.push({\n      json: {\n        ...company,\n        _apollo_found: false,\n        _apollo_person_id: null,\n        _apollo_person_count: 0\n      }\n    });\n    continue;\n  }\n\n  // Score people by role relevance - prefer owners/founders\n  let bestPerson = null;\n  let bestScore = -1;\n\n  for (const person of people) {\n    const title = (person.title || '').toLowerCase();\n    let score = 0;\n\n    if (ownerKeywords.some(k => title.includes(k))) score = 10;\n    else if (managerKeywords.some(k => title.includes(k))) score = 5;\n    else if (practitionerKeywords.some(k => title.includes(k))) score = 3;\n    else score = 1;\n\n    // Bonus for having email available\n    if (person.has_email === true || person.has_email === 'true') score += 1;\n\n    if (score > bestScore) {\n      bestScore = score;\n      bestPerson = person;\n    }\n  }\n\n  console.log(`Apollo search for ${company.domain}: ${people.length} people found. Best: ${bestPerson.first_name} (${bestPerson.title || 'no title'}, score ${bestScore})`);\n\n  results.push({\n    json: {\n      ...company,\n      _apollo_found: true,\n      _apollo_person_id: bestPerson.id,\n      _apollo_first_name: bestPerson.first_name,\n      _apollo_last_name_obfuscated: bestPerson.last_name_obfuscated || null,\n      _apollo_title: bestPerson.title || null,\n      _apollo_person_count: people.length\n    }\n  });\n}\n\nreturn results;"
      },
      "id": "4392c9f8-39dc-4ac1-a39b-9f16be3926c7",
      "name": "Parse Apollo Search",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        5040,
        448
      ]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose"
          },
          "conditions": [
            {
              "id": "apollo-found",
              "leftValue": "={{ $json._apollo_found }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "64fca517-5772-4d0e-bc72-9756e00edd4e",
      "name": "Apollo Found People?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        5264,
        448
      ]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose"
          },
          "conditions": [
            {
              "id": "enrich-enabled",
              "leftValue": "={{ $('Step 3a Config').first().json.apollo_enrich_enabled }}",
              "rightValue": "true",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "dd64a3e6-eb3a-46c6-b894-83f0297d65ef",
      "name": "Enrich Enabled?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        5440,
        336
      ],
      "notes": "Guards Apollo enrichment credits. Set apollo_enrich_enabled=false in config to skip enrichment and just use search results."
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.apollo.io/api/v1/people/match",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            },
            {
              "name": "Cache-Control",
              "value": "no-cache"
            },
            {
              "name": "X-Api-Key",
              "value": "={{ $env.APOLLO_API_KEY }}"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"id\": \"{{ $json._apollo_person_id }}\",\n  \"reveal_personal_emails\": true,\n  \"reveal_phone_number\": false\n}",
        "options": {
          "batching": {
            "batch": {
              "batchSize": 5
            }
          },
          "timeout": 15000
        }
      },
      "id": "205649d6-149f-4706-8d75-b6a0f0a68525",
      "name": "Apollo People Enrich",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        5632,
        240
      ],
      "onError": "continueRegularOutput",
      "notes": "COSTS 1 CREDIT per call. Enriches the selected person with full name, email, phone, LinkedIn. Batched 5/sec."
    },
    {
      "parameters": {
        "jsCode": "// runOnceForAllItems \u2014 index-paired with Parse Apollo Search\nconst upstreamAll = $('Parse Apollo Search').all();\nconst inputAll = $input.all();\nconst results = [];\n\nfor (let i = 0; i < inputAll.length; i++) {\n  const company = upstreamAll[i].json;\n  const response = inputAll[i].json;\n  const person = response.person || response.match || response;\n\n  if (!person || !person.first_name) {\n    // Enrichment failed but we still have search data\n    results.push({\n      json: {\n        _contact: {\n          company_id: company.id,\n          first_name: company._apollo_first_name || null,\n          last_name: null,\n          role: (company._apollo_title || '').toLowerCase().includes('owner') ? 'owner' : 'unknown',\n          is_owner: (company._apollo_title || '').toLowerCase().includes('owner'),\n          email_business: null,\n          email_personal: null,\n          phone_direct: null,\n          linkedin_url: null,\n          location: [company.city, company.state].filter(Boolean).join(', ') || null,\n          cultural_affinity: null,\n          source: 'apollo'\n        },\n        _company_name: company.name,\n        _company_id: company.id,\n        _source_method: 'apollo_search_only',\n        _has_contact: !!(company._apollo_first_name)\n      }\n    });\n    continue;\n  }\n\n  // Extract phone number\n  let phoneNumber = null;\n  if (person.phone_numbers && person.phone_numbers.length > 0) {\n    phoneNumber = person.phone_numbers[0].sanitized_number || person.phone_numbers[0].raw_number || null;\n  }\n\n  // Determine role\n  const title = (person.title || '').toLowerCase();\n  let role = 'unknown';\n  let isOwner = false;\n  if (['owner', 'founder', 'ceo', 'proprietor', 'principal', 'co-founder'].some(k => title.includes(k))) {\n    role = 'owner';\n    isOwner = true;\n  } else if (['manager', 'director', 'gm', 'general manager'].some(k => title.includes(k))) {\n    role = 'manager';\n  } else if (['massage', 'therapist', 'lmt', 'cmt', 'rmt', 'esthetician'].some(k => title.includes(k))) {\n    role = 'practitioner';\n  }\n\n  results.push({\n    json: {\n      _contact: {\n        company_id: company.id,\n        first_name: person.first_name || null,\n        last_name: person.last_name || null,\n        role: role,\n        is_owner: isOwner,\n        email_business: person.email || null,\n        email_personal: (person.personal_emails && person.personal_emails[0]) || null,\n        phone_direct: phoneNumber,\n        linkedin_url: person.linkedin_url || null,\n        location: [person.city, person.state].filter(Boolean).join(', ') || [company.city, company.state].filter(Boolean).join(', ') || null,\n        cultural_affinity: null,\n        source: 'apollo'\n      },\n      _company_name: company.name,\n      _company_id: company.id,\n      _source_method: 'apollo_enriched',\n      _has_contact: true\n    }\n  });\n}\n\nreturn results;"
      },
      "id": "b8845975-4f17-416e-861e-94cc5cc39146",
      "name": "Parse Apollo Enrich",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        5808,
        240
      ]
    },
    {
      "parameters": {
        "jsCode": "// Apollo search found someone but enrichment is disabled - use search-only data\nconst items = $input.all();\nconst results = [];\n\nfor (const entry of items) {\n  const item = entry.json;\n  results.push({\n    json: {\n      _contact: {\n        company_id: item.id,\n        first_name: item._apollo_first_name || null,\n        last_name: null,\n        role: (item._apollo_title || '').toLowerCase().includes('owner') ? 'owner' : 'unknown',\n        is_owner: (item._apollo_title || '').toLowerCase().includes('owner'),\n        email_business: null,\n        email_personal: null,\n        phone_direct: null,\n        linkedin_url: null,\n        location: [item.city, item.state].filter(Boolean).join(', ') || null,\n        cultural_affinity: null,\n        source: 'apollo'\n      },\n      _company_name: item.name,\n      _company_id: item.id,\n      _source_method: 'apollo_search_only',\n      _has_contact: !!(item._apollo_first_name)\n    }\n  });\n}\n\nreturn results;"
      },
      "id": "84b82e8e-33cb-4264-8c45-96b1081845f1",
      "name": "Apollo Search Only Contact",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        5680,
        448
      ],
      "notes": "Fallback: uses Apollo search data (first name + obfuscated last name) when enrichment credits are disabled."
    },
    {
      "parameters": {
        "url": "=https://{{ $json.domain }}/about",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36"
            },
            {
              "name": "Accept",
              "value": "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8"
            }
          ]
        },
        "options": {
          "redirect": {
            "redirect": {
              "maxRedirects": 5
            }
          },
          "response": {
            "response": {
              "fullResponse": true,
              "responseFormat": "text"
            }
          },
          "timeout": 15000
        }
      },
      "id": "56a047ca-1e8c-4228-90d2-906e3f4672bc",
      "name": "Fetch About Page",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        5424,
        704
      ],
      "onError": "continueRegularOutput",
      "notes": "Fetches /about page as fallback when Apollo found no results. Tries to extract owner name from HTML."
    },
    {
      "parameters": {
        "jsCode": "// runOnceForAllItems \u2014 index-paired with Solo Practitioner Check\n// Has async this.helpers.httpRequest() inside loop (required per-item)\nconst upstreamAll = $('Solo Practitioner Check').all();\nconst inputAll = $input.all();\nconst results = [];\n\nconst additionalPaths = ['/about-us', '/about-me', '/our-team', '/team', '/our-story'];\n\nconst commonFirstNames = new Set([\n  'aaron','abby','abigail','adam','adrian','adriana','aiden','aimee','alana','albert',\n  'alexa','alexander','alexandra','alexis','alice','alicia','alison','allison','amanda','amber',\n  'amelia','amy','ana','andrea','andrew','angela','angelica','angie','anita','ann',\n  'anna','anne','annie','anthony','april','aria','ariana','ashley','audrey','ava',\n  'avery','bailey','barbara','becky','bella','ben','benjamin','beth','bethany','betty',\n  'beverly','bianca','blake','bonnie','brad','bradley','brandi','brandon','brandy','brenda',\n  'brent','brian','brianna','bridget','brittany','brooke','bruce','bryan','caitlin','caleb',\n  'cameron','candace','cara','carl','carla','carlos','carly','carmen','carol','caroline',\n  'carolyn','carrie','casey','cassandra','catherine','cathy','celeste','chad','charlene','charles',\n  'charlotte','chelsea','cheryl','chloe','chris','christina','christine','christopher','cindy','claire',\n  'clara','claudia','colleen','connor','courtney','craig','crystal','cynthia','daisy','dale',\n  'dana','daniel','daniela','danielle','darlene','dave','david','dawn','dean','deanna',\n  'debbie','deborah','debra','denise','derek','desiree','diana','diane','dolores','donna',\n  'doris','dorothy','douglas','drew','dustin','dylan','eddie','edward','eileen','elaine',\n  'elena','elizabeth','ella','ellen','emily','emma','eric','erica','erika','erin',\n  'esther','ethan','eva','evelyn','faith','felicia','fiona','florence','frances','frank',\n  'gabriel','gabriela','gabrielle','gail','gary','george','georgia','gerald','gina','glen',\n  'glenn','gloria','grace','greg','gregory','hailey','haley','hannah','harold','harry',\n  'hazel','heather','heidi','helen','henry','holly','hope','howard','hunter','ian',\n  'irene','iris','isaac','isabel','isabella','ivy','jack','jackie','jacob','jacqueline',\n  'jade','jaime','jake','james','jamie','jane','janet','janice','jared','jasmine',\n  'jason','jay','jean','jeff','jeffrey','jenna','jennifer','jenny','jeremy','jerry',\n  'jesse','jessica','jill','jim','jimmy','joan','joanna','joanne','jocelyn','jodi',\n  'joe','joel','john','johnny','jon','jonathan','jordan','jose','joseph','josh',\n  'joshua','joy','joyce','judith','judy','julia','julie','june','justin','kaitlyn',\n  'kara','karen','karina','kate','katelyn','katherine','kathleen','kathryn','kathy','katie',\n  'katrina','kay','kayla','keith','kelly','kelsey','ken','kendra','kenneth','kevin',\n  'kim','kimberly','kirsten','krista','kristen','kristin','kristina','kristy','kyle','kylie',\n  'lacey','lana','lance','larry','laura','lauren','laurie','leah','lee','leigh',\n  'lena','leon','leslie','lexy','liam','lillian','lily','linda','lindsay','lindsey',\n  'lisa','logan','lois','lori','lorraine','louis','louise','lucia','luis','luke',\n  'lydia','lynn','mackenzie','madeline','madison','maggie','mallory','mandy','marc','marcia',\n  'marcus','margaret','maria','marie','marilyn','marina','mario','marisa','mark','marlene',\n  'martha','martin','mary','matt','matthew','maureen','max','maya','megan','meghan',\n  'melanie','melinda','melissa','melody','meredith','mia','michael','michele','michelle','miguel',\n  'mike','mildred','mindy','miranda','misty','molly','monica','monique','morgan','nadia',\n  'nancy','naomi','natalia','natalie','natasha','nathan','nicholas','nicole','nina','noah',\n  'nora','norma','olivia','owen','paige','pamela','patricia','patrick','paul','paula',\n  'peggy','penny','peter','philip','phyllis','priscilla','rachel','ralph','randy','ray',\n  'raymond','rebecca','regina','renee','rhonda','richard','rick','riley','rita','robert',\n  'roberta','robin','rodney','roger','ronald','rosa','rose','rosemary','ruby','russell',\n  'ruth','ryan','sabrina','sally','samantha','samuel','sandra','sandy','sara','sarah',\n  'savannah','scott','sean','selena','serena','seth','shannon','sharon','shawn','sheila',\n  'shelby','shelly','sheri','sherry','shirley','sierra','simone','sofia','sonia','sophia',\n  'stacey','stacy','stella','stephanie','stephen','steve','steven','sue','summer','susan',\n  'suzanne','sydney','sylvia','tamara','tammy','tanya','tara','tatiana','taylor','teresa',\n  'terri','terry','tessa','theresa','thomas','tiffany','timothy','tina','tito','todd',\n  'tom','toni','tony','tonya','tracey','tracy','travis','tricia','troy','tyler',\n  'valerie','vanessa','vera','veronica','vicki','victoria','vincent','violet','virginia','vivian',\n  'walter','wanda','wayne','wendy','wesley','whitney','william','willie','wilma','xavier',\n  'yolanda','yvette','yvonne','zachary','zoe'\n]);\n\nfunction isLikelyFirstName(word) {\n  return commonFirstNames.has((word || '').toLowerCase());\n}\n\nfunction extractName(html) {\n  if (!html || html.length < 100) return null;\n  const textOnly = html.replace(/<[^>]+>/g, ' ').replace(/\\s+/g, ' ');\n\n  const patterns = [\n    /(?:owner|owned\\s+by|founded\\s+by|proprietor)[:\\s]+([A-Z][a-z]+)\\s+([A-Z][a-z]+)/i,\n    /(?:hi,?\\s+i'?m|hello,?\\s+i'?m|my\\s+name\\s+is|i\\s+am)\\s+([A-Z][a-z]+)\\s+([A-Z][a-z]+)/i,\n    /(?:^|\\s)about\\s+([A-Z][a-z]+)\\s+([A-Z][a-z]+)(?:\\s*[,|]|\\s+(?:LMT|CMT|RMT|Licensed))/i,\n    /(?:^|\\s)meet\\s+([A-Z][a-z]+)\\s+([A-Z][a-z]+)(?:\\s*[,|]|\\s+(?:LMT|CMT|RMT|Licensed|is\\s+a|has\\s+been))/i,\n    /([A-Z][a-z]+)\\s+([A-Z][a-z]+),?\\s+(?:LMT|CMT|RMT|Licensed\\s+Massage)/i\n  ];\n\n  for (const pattern of patterns) {\n    for (const source of [textOnly, html]) {\n      const match = source.match(pattern);\n      if (match) {\n        const fn = match[1];\n        const ln = match[2];\n        if (isLikelyFirstName(fn) &&\n            fn.length >= 2 && fn.length <= 20 &&\n            ln.length >= 2 && ln.length <= 20) {\n          return { firstName: fn, lastName: ln };\n        }\n      }\n    }\n  }\n  return null;\n}\n\nfor (let i = 0; i < inputAll.length; i++) {\n  const company = upstreamAll[i].json;\n  const response = inputAll[i].json;\n\n  // Step 1: Check the upstream /about response\n  let bestHtml = '';\n  let usedPath = '/about';\n  const rawHtml = response.body || response.data || '';\n  if (typeof rawHtml === 'string' && rawHtml.length > 500) {\n    bestHtml = rawHtml;\n  }\n\n  // Step 2: Try to extract name from /about\n  let nameResult = bestHtml ? extractName(bestHtml) : null;\n\n  // Step 3: If /about didn't yield a name, try additional paths\n  if (!nameResult && company.domain) {\n    for (const path of additionalPaths) {\n      try {\n        const resp = await this.helpers.httpRequest({\n          method: 'GET',\n          url: `https://${company.domain}${path}`,\n          headers: { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36' },\n          returnFullResponse: true,\n          timeout: 10000,\n          json: false,\n        });\n        const html = resp.body || '';\n        if (typeof html === 'string' && html.length > 500) {\n          const found = extractName(html);\n          if (found) {\n            nameResult = found;\n            usedPath = path;\n            console.log(`Found name on ${path}: ${found.firstName} ${found.lastName}`);\n            break;\n          }\n        }\n      } catch(e) {\n        // Path doesn't exist or timed out \u2014 try next\n      }\n    }\n  }\n\n  const hasContact = !!(nameResult);\n\n  results.push({\n    json: {\n      _contact: hasContact ? {\n        company_id: company.id,\n        first_name: nameResult.firstName,\n        last_name: nameResult.lastName,\n        role: 'owner',\n        is_owner: true,\n        email_business: null,\n        email_personal: null,\n        phone_direct: null,\n        linkedin_url: null,\n        location: [company.city, company.state].filter(Boolean).join(', ') || null,\n        cultural_affinity: null,\n        source: 'website'\n      } : null,\n      _company_name: company.name,\n      _company_id: company.id,\n      _source_method: hasContact ? `website_scrape_${usedPath.replace('/', '')}` : 'website_scrape',\n      _has_contact: hasContact\n    }\n  });\n}\n\nreturn results;"
      },
      "id": "eed207a8-0d1d-4e22-899a-cbdbc7039086",
      "name": "Parse About Page",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        5584,
        704
      ]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose"
          },
          "conditions": [
            {
              "id": "found-name",
              "leftValue": "={{ $json._has_contact }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "c3c2d97c-9326-4b42-a0ad-7462fa6d6829",
      "name": "About Found Name?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        5744,
        704
      ]
    },
    {
      "parameters": {
        "jsCode": "// runOnceForAllItems \u2014 hoist name list + helper outside loop\nconst items = $input.all();\nconst results = [];\n\nconst commonFirstNames = new Set([\n  'aaron','abby','abigail','adam','adrian','adriana','aiden','aimee','alana','albert',\n  'alexa','alexander','alexandra','alexis','alice','alicia','alison','allison','amanda','amber',\n  'amelia','amy','ana','andrea','andrew','angela','angelica','angie','anita','ann',\n  'anna','anne','annie','anthony','april','aria','ariana','ashley','audrey','ava',\n  'avery','bailey','barbara','becky','bella','ben','benjamin','beth','bethany','betty',\n  'beverly','bianca','blake','bonnie','brad','bradley','brandi','brandon','brandy','brenda',\n  'brent','brian','brianna','bridget','brittany','brooke','bruce','bryan','caitlin','caleb',\n  'cameron','candace','cara','carl','carla','carlos','carly','carmen','carol','caroline',\n  'carolyn','carrie','casey','cassandra','catherine','cathy','celeste','chad','charlene','charles',\n  'charlotte','chelsea','cheryl','chloe','chris','christina','christine','christopher','cindy','claire',\n  'clara','claudia','colleen','connor','courtney','craig','crystal','cynthia','daisy','dale',\n  'dana','daniel','daniela','danielle','darlene','dave','david','dawn','dean','deanna',\n  'debbie','deborah','debra','denise','derek','desiree','diana','diane','dolores','donna',\n  'doris','dorothy','douglas','drew','dustin','dylan','eddie','edward','eileen','elaine',\n  'elena','elizabeth','ella','ellen','emily','emma','eric','erica','erika','erin',\n  'esther','ethan','eva','evelyn','faith','felicia','fiona','florence','frances','frank',\n  'gabriel','gabriela','gabrielle','gail','gary','george','georgia','gerald','gina','glen',\n  'glenn','gloria','grace','greg','gregory','hailey','haley','hannah','harold','harry',\n  'hazel','heather','heidi','helen','henry','holly','hope','howard','hunter','ian',\n  'irene','iris','isaac','isabel','isabella','ivy','jack','jackie','jacob','jacqueline',\n  'jade','jaime','jake','james','jamie','jane','janet','janice','jared','jasmine',\n  'jason','jay','jean','jeff','jeffrey','jenna','jennifer','jenny','jeremy','jerry',\n  'jesse','jessica','jill','jim','jimmy','joan','joanna','joanne','jocelyn','jodi',\n  'joe','joel','john','johnny','jon','jonathan','jordan','jose','joseph','josh',\n  'joshua','joy','joyce','judith','judy','julia','julie','june','justin','kaitlyn',\n  'kara','karen','karina','kate','katelyn','katherine','kathleen','kathryn','kathy','katie',\n  'katrina','kay','kayla','keith','kelly','kelsey','ken','kendra','kenneth','kevin',\n  'kim','kimberly','kirsten','krista','kristen','kristin','kristina','kristy','kyle','kylie',\n  'lacey','lana','lance','larry','laura','lauren','laurie','leah','lee','leigh',\n  'lena','leon','leslie','lexy','liam','lillian','lily','linda','lindsay','lindsey',\n  'lisa','logan','lois','lori','lorraine','louis','louise','lucia','luis','luke',\n  'lydia','lynn','mackenzie','madeline','madison','maggie','mallory','mandy','marc','marcia',\n  'marcus','margaret','maria','marie','marilyn','marina','mario','marisa','mark','marlene',\n  'martha','martin','mary','matt','matthew','maureen','max','maya','megan','meghan',\n  'melanie','melinda','melissa','melody','meredith','mia','michael','michele','michelle','miguel',\n  'mike','mildred','mindy','miranda','misty','molly','monica','monique','morgan','nadia',\n  'nancy','naomi','natalia','natalie','natasha','nathan','nicholas','nicole','nina','noah',\n  'nora','norma','olivia','owen','paige','pamela','patricia','patrick','paul','paula',\n  'peggy','penny','peter','philip','phyllis','priscilla','rachel','ralph','randy','ray',\n  'raymond','rebecca','regina','renee','rhonda','richard','rick','riley','rita','robert',\n  'roberta','robin','rodney','roger','ronald','rosa','rose','rosemary','ruby','russell',\n  'ruth','ryan','sabrina','sally','samantha','samuel','sandra','sandy','sara','sarah',\n  'savannah','scott','sean','selena','serena','seth','shannon','sharon','shawn','sheila',\n  'shelby','shelly','sheri','sherry','shirley','sierra','simone','sofia','sonia','sophia',\n  'stacey','stacy','stella','stephanie','stephen','steve','steven','sue','summer','susan',\n  'suzanne','sydney','sylvia','tamara','tammy','tanya','tara','tatiana','taylor','teresa',\n  'terri','terry','tessa','theresa','thomas','tiffany','timothy','tina','tito','todd',\n  'tom','toni','tony','tonya','tracey','tracy','travis','tricia','troy','tyler',\n  'valerie','vanessa','vera','veronica','vicki','victoria','vincent','violet','virginia','vivian',\n  'walter','wanda','wayne','wendy','wesley','whitney','william','willie','wilma','xavier',\n  'yolanda','yvette','yvonne','zachary','zoe'\n]);\n\nfunction isLikelyFirstName(word) {\n  return commonFirstNames.has(word.toLowerCase());\n}\n\nfor (const entry of items) {\n  const item = entry.json;\n  const name = (item.name || '').trim();\n\n  let firstName = null;\n  let lastName = null;\n\n  // Pattern 1: \"by Name\"\n  const byPattern = name.match(/\\bby\\s+([A-Z][a-z]+)(?:\\s+([A-Z][a-z]+))?/i);\n  if (byPattern && isLikelyFirstName(byPattern[1])) {\n    firstName = byPattern[1];\n    lastName = byPattern[2] || null;\n  }\n\n  // Pattern 2: \"with Name\"\n  if (!firstName) {\n    const withPattern = name.match(/\\bwith\\s+([A-Z][a-z]+)(?:\\s+([A-Z][a-z]+))?/i);\n    if (withPattern && isLikelyFirstName(withPattern[1])) {\n      firstName = withPattern[1];\n      lastName = withPattern[2] || null;\n    }\n  }\n\n  // Pattern 3: Possessive\n  if (!firstName) {\n    const possessive = name.match(/^([A-Z][a-z]+)'s\\s+/i);\n    if (possessive && isLikelyFirstName(possessive[1])) {\n      firstName = possessive[1];\n    }\n  }\n\n  // Pattern 4: \"FirstName LastName, LMT\"\n  if (!firstName) {\n    const credMatch = name.match(/^([A-Z][a-z]+)\\s+([A-Z][a-z]+)(?:\\s*,?\\s*(?:LMT|CMT|RMT|Licensed))/i);\n    if (credMatch && isLikelyFirstName(credMatch[1])) {\n      firstName = credMatch[1];\n      lastName = credMatch[2];\n    }\n  }\n\n  // Pattern 5: Name after comma\n  if (!firstName) {\n    const commaMatch = name.match(/,\\s*([A-Z][a-z]+)\\s+([A-Z][a-z]+)/i);\n    if (commaMatch && isLikelyFirstName(commaMatch[1])) {\n      firstName = commaMatch[1];\n      lastName = commaMatch[2];\n    }\n  }\n\n  // Pattern 6: Validated first+last before business keyword\n  if (!firstName) {\n    const nameKeyword = name.match(/^([A-Z][a-z]+)\\s+([A-Z][a-z]+)\\s+(?:Massage|Bodywork|Therapeutic|Wellness|Healing|Spa)/i);\n    if (nameKeyword && isLikelyFirstName(nameKeyword[1]) && !isLikelyFirstName(nameKeyword[2])) {\n      firstName = nameKeyword[1];\n      lastName = nameKeyword[2];\n    }\n  }\n\n  const hasContact = !!(firstName);\n\n  results.push({\n    json: {\n      _contact: hasContact ? {\n        company_id: item.id,\n        first_name: firstName,\n        last_name: lastName,\n        role: 'owner',\n        is_owner: true,\n        email_business: null,\n        email_personal: null,\n        phone_direct: null,\n        linkedin_url: null,\n        location: [item.city, item.state].filter(Boolean).join(', ') || null,\n        cultural_affinity: null,\n        source: 'manual'\n      } : null,\n      _company_name: item.name,\n      _company_id: item.id,\n      _source_method: 'no_domain_name_extraction',\n      _has_contact: hasContact\n    }\n  });\n}\n\nreturn results;"
      },
      "id": "2900cb38-81d2-48b9-a3d5-8797662f8fcf",
      "name": "No Domain Fallback",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        5552,
        896
      ],
      "notes": "Last resort: tries to extract a person name from the business name when there's no domain to search or scrape."
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose"
          },
          "conditions": [
            {
              "id": "has-contact",
              "leftValue": "={{ $json._has_contact }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "0a130892-5648-4382-90b3-c5f7e7c1d42b",
      "name": "No Domain Found Name?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        5776,
        944
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $env.SUPABASE_URL }}/rest/v1/contacts?on_conflict=company_id,first_name,last_name,source",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "apikey",
              "value": "={{ $env.SUPABASE_SERVICE_KEY }}"
            },
            {
              "name": "Authorization",
              "value": "=Bearer {{ $env.SUPABASE_SERVICE_KEY }}"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            },
            {
              "name": "Prefer",
              "value": "resolution=ignore-duplicates,return=minimal"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify($json._contact) }}",
        "options": {
          "batching": {
            "batch": {
              "batchSize": 10,
              "batchInterval": 500
            }
          }
        }
      },
      "id": "066f3ba9-f8a3-4ffe-ae46-76f135525e99",
      "name": "Insert Contact to Supabase",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        6240,
        512
      ],
      "onError": "continueRegularOutput",
      "notes": "Inserts contact into Supabase contacts table. All paths (solo, apollo, website) converge here with the same _contact shape."
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose"
          },
          "conditions": [
            {
              "id": "empty-check",
              "leftValue": "={{ $json._empty }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "afa86014-5ac8-4fad-a9b3-e4513f149926",
      "name": "Batch Empty?2",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        3888,
        528
      ]
    },
    {
      "parameters": {
        "jsCode": "return [{ json: { message: 'No companies need people discovery. All already have contacts or no partially/fully enriched companies found.', completed_at: new Date().toISOString() } }];"
      },
      "id": "5e50a41e-d9b9-4d52-b249-8bb73d5360fb",
      "name": "No Records - Done2",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        4112,
        432
      ]
    },
    {
      "parameters": {
        "jsCode": "// Collapse all input items into a single trigger item for the next step\nreturn [{ json: { _trigger: 'continue', _timestamp: new Date().toISOString() } }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        224,
        432
      ],
      "id": "7bc117c3-7316-4388-9630-869eb2b9868c",
      "name": "Bridge to 3b"
    },
    {
      "parameters": {
        "jsCode": "// Collapse all input items into a single trigger item for the next step\nreturn [{ json: { _trigger: 'continue', _timestamp: new Date().toISOString() } }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2672,
        544
      ],
      "id": "9023af2e-fd90-425e-b42d-331959709141",
      "name": "Bridge to 3a"
    },
    {
      "parameters": {
        "jsCode": "// Validate & Clean Contact \u2014 runOnceForAllItems\n// Cleans emails, phones, names, LinkedIn URLs before Supabase insert.\n// Nulls out invalid data rather than blocking the insert.\n// Adds _validation_flags array for audit trail.\n\nconst items = $input.all();\nconst results = [];\n\n// Helper functions accept flags array as parameter (not closure)\nfunction validateEmail(email, fieldName, flags) {\n  if (!email) return null;\n  let cleaned = email.trim().toLowerCase();\n  const emailRegex = /^[a-zA-Z0-9._%+\\-]+@[a-zA-Z0-9.\\-]+\\.[a-zA-Z]{2,}$/;\n  if (!emailRegex.test(cleaned)) {\n    flags.push(`${fieldName}_invalid_format: \"${email}\"`);\n    return null;\n  }\n  const junkPatterns = [\n    /^noreply@/, /^no-reply@/, /^donotreply@/, /^do-not-reply@/,\n    /^test@/, /^admin@example\\./, /^info@example\\./, /^user@example\\./,\n    /^sample@/, /^fake@/, /^placeholder@/, /^null@/, /^none@/, /^na@/,\n    /^n\\/a@/, /^unknown@/, /^abuse@/, /^postmaster@/, /^mailer-daemon@/\n  ];\n  if (junkPatterns.some(p => p.test(cleaned))) {\n    flags.push(`${fieldName}_junk_pattern: \"${cleaned}\"`);\n    return null;\n  }\n  const rolePatterns = [\n    /^info@/, /^contact@/, /^hello@/, /^support@/, /^sales@/, /^office@/,\n    /^billing@/, /^reception@/, /^frontdesk@/, /^front\\.desk@/,\n    /^appointments@/, /^booking@/, /^bookings@/, /^schedule@/,\n    /^scheduling@/, /^inquiries@/, /^inquiry@/, /^general@/, /^team@/, /^staff@/\n  ];\n  if (rolePatterns.some(p => p.test(cleaned))) {\n    flags.push(`${fieldName}_role_based_kept: \"${cleaned}\"`);\n  }\n  const junkDomains = [\n    'example.com', 'example.org', 'example.net', 'test.com', 'test.org',\n    'placeholder.com', 'fake.com', 'noemail.com', 'nomail.com', 'none.com',\n    'localhost', 'mailinator.com', 'guerrillamail.com', 'tempmail.com',\n    'throwaway.email', 'yopmail.com'\n  ];\n  const domain = cleaned.split('@')[1];\n  if (junkDomains.includes(domain)) {\n    flags.push(`${fieldName}_junk_domain: \"${domain}\"`);\n    return null;\n  }\n  const localPart = cleaned.split('@')[0];\n  if (/^\\d+$/.test(localPart)) {\n    flags.push(`${fieldName}_numeric_local: \"${cleaned}\"`);\n    return null;\n  }\n  if (localPart.startsWith('.') || localPart.endsWith('.') || localPart.includes('..')) {\n    flags.push(`${fieldName}_malformed_local: \"${cleaned}\"`);\n    return null;\n  }\n  return cleaned;\n}\n\nfunction validatePhone(phone, fieldName, flags) {\n  if (!phone) return null;\n  if (typeof phone === 'object' && phone !== null) {\n    phone = phone.sanitized_number || phone.raw_number || phone.number || '';\n  }\n  let cleaned = phone.toString().trim();\n  cleaned = cleaned.replace(/[^\\d]/g, '');\n  if (!cleaned || cleaned.length === 0) {\n    flags.push(`${fieldName}_empty_after_strip`);\n    return null;\n  }\n  if (cleaned.length === 11 && cleaned.startsWith('1')) {\n    // already has country code\n  } else if (cleaned.length === 10) {\n    cleaned = '1' + cleaned;\n  } else if (cleaned.length < 10) {\n    flags.push(`${fieldName}_too_short: \"${phone}\" (${cleaned.length} digits)`);\n    return null;\n  } else if (cleaned.length > 11) {\n    flags.push(`${fieldName}_possibly_international: \"${phone}\" (${cleaned.length} digits)`);\n    return '+' + cleaned;\n  }\n  const areaCode = cleaned.substring(1, 4);\n  if (areaCode.startsWith('0') || areaCode.startsWith('1')) {\n    flags.push(`${fieldName}_invalid_area_code: \"${areaCode}\"`);\n    return null;\n  }\n  return '+' + cleaned;\n}\n\nfunction cleanName(name, fieldName, flags) {\n  if (!name) return null;\n  let cleaned = name.trim();\n  cleaned = cleaned.replace(/\\*+$/, '').trim();\n  if (cleaned.length <= 1) {\n    flags.push(`${fieldName}_too_short: \"${name}\"`);\n    return null;\n  }\n  if (/^\\d+$/.test(cleaned)) {\n    flags.push(`${fieldName}_numeric: \"${name}\"`);\n    return null;\n  }\n  if (/\\d/.test(cleaned)) {\n    flags.push(`${fieldName}_contains_digits: \"${name}\"`);\n    return null;\n  }\n  const junkNames = [\n    'unknown', 'n/a', 'na', 'none', 'null', 'test',\n    'owner', 'manager', 'admin', 'info', 'contact'\n  ];\n  if (junkNames.includes(cleaned.toLowerCase())) {\n    flags.push(`${fieldName}_junk_name: \"${name}\"`);\n    return null;\n  }\n  const credentials = [\n    'lmt', 'cmt', 'rmt', 'lmbt', 'lmp', 'bctmb', 'nctmb', 'nctm',\n    'cpt', 'cst', 'mld', 'nmt', 'amt', 'abmp'\n  ];\n  if (credentials.includes(cleaned.toLowerCase())) {\n    flags.push(`${fieldName}_credential_not_name: \"${name}\"`);\n    return null;\n  }\n  if (cleaned === cleaned.toUpperCase() || cleaned === cleaned.toLowerCase()) {\n    cleaned = cleaned.charAt(0).toUpperCase() + cleaned.slice(1).toLowerCase();\n  }\n  return cleaned;\n}\n\nfunction validateLinkedIn(url, flags) {\n  if (!url) return null;\n  let cleaned = url.trim();\n  if (!/linkedin\\.com\\/in\\//i.test(cleaned)) {\n    if (/linkedin\\.com/i.test(cleaned)) {\n      flags.push(`linkedin_not_personal_profile: \"${cleaned}\"`);\n    } else {\n      flags.push(`linkedin_invalid_url: \"${cleaned}\"`);\n    }\n    return null;\n  }\n  if (!cleaned.startsWith('http')) {\n    cleaned = 'https://' + cleaned;\n  }\n  cleaned = cleaned.replace(/^http:\\/\\//, 'https://');\n  return cleaned;\n}\n\nfor (const entry of items) {\n  const item = entry.json;\n  const contact = item._contact;\n  const flags = [];\n\n  if (!contact) {\n    results.push({ json: { ...item, _validation_flags: ['no_contact_object'] } });\n    continue;\n  }\n\n  contact.email_business = validateEmail(contact.email_business, 'email_business', flags);\n  contact.email_personal = validateEmail(contact.email_personal, 'email_personal', flags);\n  contact.phone_direct = validatePhone(contact.phone_direct, 'phone_direct', flags);\n  contact.first_name = cleanName(contact.first_name, 'first_name', flags);\n  contact.last_name = cleanName(contact.last_name, 'last_name', flags);\n\n  if (!contact.first_name) {\n    flags.push('contact_has_no_valid_first_name');\n  }\n\n  contact.linkedin_url = validateLinkedIn(contact.linkedin_url, flags);\n\n  if (contact.location) {\n    contact.location = contact.location.trim();\n    if (!contact.location || contact.location === ',' || contact.location.length < 2) {\n      contact.location = null;\n      flags.push('location_empty_after_clean');\n    }\n  }\n\n  const hasValidContact = !!(contact.first_name);\n\n  if (flags.length > 0) {\n    console.log(`Validation [${item._company_name}] (${item._source_method}): ${flags.join(', ')}`);\n  }\n\n  results.push({\n    json: {\n      _contact: contact,\n      _company_name: item._company_name,\n      _company_id: item._company_id,\n      _source_method: item._source_method,\n      _has_contact: hasValidContact,\n      _validation_flags: flags\n    }\n  });\n}\n\nreturn results;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        6016,
        48
      ],
      "id": "3f98c182-0d4e-4978-a9c9-3beec8691ba1",
      "name": "Validate & Clean Contact"
    },
    {
      "parameters": {
        "jsCode": "// Validate & Clean Contact1 \u2014 runOnceForAllItems\nconst items = $input.all();\nconst results = [];\n\nfunction validateEmail(email, fieldName, flags) {\n  if (!email) return null;\n  let cleaned = email.trim().toLowerCase();\n  const emailRegex = /^[a-zA-Z0-9._%+\\-]+@[a-zA-Z0-9.\\-]+\\.[a-zA-Z]{2,}$/;\n  if (!emailRegex.test(cleaned)) { flags.push(`${fieldName}_invalid_format: \"${email}\"`); return null; }\n  const junkPatterns = [/^noreply@/, /^no-reply@/, /^donotreply@/, /^do-not-reply@/, /^test@/, /^admin@example\\./, /^info@example\\./, /^user@example\\./, /^sample@/, /^fake@/, /^placeholder@/, /^null@/, /^none@/, /^na@/, /^n\\/a@/, /^unknown@/, /^abuse@/, /^postmaster@/, /^mailer-daemon@/];\n  if (junkPatterns.some(p => p.test(cleaned))) { flags.push(`${fieldName}_junk_pattern: \"${cleaned}\"`); return null; }\n  const rolePatterns = [/^info@/, /^contact@/, /^hello@/, /^support@/, /^sales@/, /^office@/, /^billing@/, /^reception@/, /^frontdesk@/, /^front\\.desk@/, /^appointments@/, /^booking@/, /^bookings@/, /^schedule@/, /^scheduling@/, /^inquiries@/, /^inquiry@/, /^general@/, /^team@/, /^staff@/];\n  if (rolePatterns.some(p => p.test(cleaned))) { flags.push(`${fieldName}_role_based_kept: \"${cleaned}\"`); }\n  const junkDomains = ['example.com','example.org','example.net','test.com','test.org','placeholder.com','fake.com','noemail.com','nomail.com','none.com','localhost','mailinator.com','guerrillamail.com','tempmail.com','throwaway.email','yopmail.com'];\n  const domain = cleaned.split('@')[1];\n  if (junkDomains.includes(domain)) { flags.push(`${fieldName}_junk_domain: \"${domain}\"`); return null; }\n  const localPart = cleaned.split('@')[0];\n  if (/^\\d+$/.test(localPart)) { flags.push(`${fieldName}_numeric_local: \"${cleaned}\"`); return null; }\n  if (localPart.startsWith('.') || localPart.endsWith('.') || localPart.includes('..')) { flags.push(`${fieldName}_malformed_local: \"${cleaned}\"`); return null; }\n  return cleaned;\n}\n\nfunction validatePhone(phone, fieldName, flags) {\n  if (!phone) return null;\n  if (typeof phone === 'object' && phone !== null) { phone = phone.sanitized_number || phone.raw_number || phone.number || ''; }\n  let cleaned = phone.toString().trim().replace(/[^\\d]/g, '');\n  if (!cleaned || cleaned.length === 0) { flags.push(`${fieldName}_empty_after_strip`); return null; }\n  if (cleaned.length === 11 && cleaned.startsWith('1')) { /* ok */ }\n  else if (cleaned.length === 10) { cleaned = '1' + cleaned; }\n  else if (cleaned.length < 10) { flags.push(`${fieldName}_too_short: \"${phone}\" (${cleaned.length} digits)`); return null; }\n  else if (cleaned.length > 11) { flags.push(`${fieldName}_possibly_international: \"${phone}\" (${cleaned.length} digits)`); return '+' + cleaned; }\n  const areaCode = cleaned.substring(1, 4);\n  if (areaCode.startsWith('0') || areaCode.startsWith('1')) { flags.push(`${fieldName}_invalid_area_code: \"${areaCode}\"`); return null; }\n  return '+' + cleaned;\n}\n\nfunction cleanName(name, fieldName, flags) {\n  if (!name) return null;\n  let cleaned = name.trim().replace(/\\*+$/, '').trim();\n  if (cleaned.length <= 1) { flags.push(`${fieldName}_too_short: \"${name}\"`); return null; }\n  if (/^\\d+$/.test(cleaned)) { flags.push(`${fieldName}_numeric: \"${name}\"`); return null; }\n  if (/\\d/.test(cleaned)) { flags.push(`${fieldName}_contains_digits: \"${name}\"`); return null; }\n  const junkNames = ['unknown','n/a','na','none','null','test','owner','manager','admin','info','contact'];\n  if (junkNames.includes(cleaned.toLowerCase())) { flags.push(`${fieldName}_junk_name: \"${name}\"`); return null; }\n  const credentials = ['lmt','cmt','rmt','lmbt','lmp','bctmb','nctmb','nctm','cpt','cst','mld','nmt','amt','abmp'];\n  if (credentials.includes(cleaned.toLowerCase())) { flags.push(`${fieldName}_credential_not_name: \"${name}\"`); return null; }\n  if (cleaned === cleaned.toUpperCase() || cleaned === cleaned.toLowerCase()) { cleaned = cleaned.charAt(0).toUpperCase() + cleaned.slice(1).toLowerCase(); }\n  return cleaned;\n}\n\nfunction validateLinkedIn(url, flags) {\n  if (!url) return null;\n  let cleaned = url.trim();\n  if (!/linkedin\\.com\\/in\\//i.test(cleaned)) {\n    if (/linkedin\\.com/i.test(cleaned)) { flags.push(`linkedin_not_personal_profile: \"${cleaned}\"`); }\n    else { flags.push(`linkedin_invalid_url: \"${cleaned}\"`); }\n    return null;\n  }\n  if (!cleaned.startsWith('http')) { cleaned = 'https://' + cleaned; }\n  cleaned = cleaned.replace(/^http:\\/\\//, 'https://');\n  return cleaned;\n}\n\nfor (const entry of items) {\n  const item = entry.json;\n  const contact = item._contact;\n  const flags = [];\n  if (!contact) { results.push({ json: { ...item, _validation_flags: ['no_contact_object'] } }); continue; }\n  contact.email_business = validateEmail(contact.email_business, 'email_business', flags);\n  contact.email_personal = validateEmail(contact.email_personal, 'email_personal', flags);\n  contact.phone_direct = validatePhone(contact.phone_direct, 'phone_direct', flags);\n  contact.first_name = cleanName(contact.first_name, 'first_name', flags);\n  contact.last_name = cleanName(contact.last_name, 'last_name', flags);\n  if (!contact.first_name) { flags.push('contact_has_no_valid_first_name'); }\n  contact.linkedin_url = validateLinkedIn(contact.linkedin_url, flags);\n  if (contact.location) {\n    contact.location = contact.location.trim();\n    if (!contact.location || contact.location === ',' || contact.location.length < 2) { contact.location = null; flags.push('location_empty_after_clean'); }\n  }\n  const hasValidContact = !!(contact.first_name);\n  if (flags.length > 0) { console.log(`Validation [${item._company_name}] (${item._source_method}): ${flags.join(', ')}`); }\n  results.push({ json: { _contact: contact, _company_name: item._company_name, _company_id: item._company_id, _source_method: item._source_method, _has_contact: hasValidContact, _validation_flags: flags } });\n}\n\nreturn results;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        6000,
        240
      ],
      "id": "7f799e2a-0c91-4e66-bc25-41a624f57f4f",
      "name": "Validate & Clean Contact1"
    },
    {
      "parameters": {
        "jsCode": "// Validate & Clean Contact2 \u2014 runOnceForAllItems\nconst items = $input.all();\nconst results = [];\n\nfunction validateEmail(email, fieldName, flags) {\n  if (!email) return null;\n  let cleaned = email.trim().toLowerCase();\n  const emailRegex = /^[a-zA-Z0-9._%+\\-]+@[a-zA-Z0-9.\\-]+\\.[a-zA-Z]{2,}$/;\n  if (!emailRegex.test(cleaned)) { flags.push(`${fieldName}_invalid_format: \"${email}\"`); return null; }\n  const junkPatterns = [/^noreply@/, /^no-reply@/, /^donotreply@/, /^do-not-reply@/, /^test@/, /^admin@example\\./, /^info@example\\./, /^user@example\\./, /^sample@/, /^fake@/, /^placeholder@/, /^null@/, /^none@/, /^na@/, /^n\\/a@/, /^unknown@/, /^abuse@/, /^postmaster@/, /^mailer-daemon@/];\n  if (junkPatterns.some(p => p.test(cleaned))) { flags.push(`${fieldName}_junk_pattern: \"${cleaned}\"`); return null; }\n  const rolePatterns = [/^info@/, /^contact@/, /^hello@/, /^support@/, /^sales@/, /^office@/, /^billing@/, /^reception@/, /^frontdesk@/, /^front\\.desk@/, /^appointments@/, /^booking@/, /^bookings@/, /^schedule@/, /^scheduling@/, /^inquiries@/, /^inquiry@/, /^general@/, /^team@/, /^staff@/];\n  if (rolePatterns.some(p => p.test(cleaned))) { flags.push(`${fieldName}_role_based_kept: \"${cleaned}\"`); }\n  const junkDomains = ['example.com','example.org','example.net','test.com','test.org','placeholder.com','fake.com','noemail.com','nomail.com','none.com','localhost','mailinator.com','guerrillamail.com','tempmail.com','throwaway.email','yopmail.com'];\n  const domain = cleaned.split('@')[1];\n  if (junkDomains.includes(domain)) { flags.push(`${fieldName}_junk_domain: \"${domain}\"`); return null; }\n  const localPart = cleaned.split('@')[0];\n  if (/^\\d+$/.test(localPart)) { flags.push(`${fieldName}_numeric_local: \"${cleaned}\"`); return null; }\n  if (localPart.startsWith('.') || localPart.endsWith('.') || localPart.includes('..')) { flags.push(`${fieldName}_malformed_local: \"${cleaned}\"`); return null; }\n  return cleaned;\n}\n\nfunction validatePhone(phone, fieldName, flags) {\n  if (!phone) return null;\n  if (typeof phone === 'object' && phone !== null) { phone = phone.sanitized_number || phone.raw_number || phone.number || ''; }\n  let cleaned = phone.toString().trim().replace(/[^\\d]/g, '');\n  if (!cleaned || cleaned.length === 0) { flags.push(`${fieldName}_empty_after_strip`); return null; }\n  if (cleaned.length === 11 && cleaned.startsWith('1')) { /* ok */ }\n  else if (cleaned.length === 10) { cleaned = '1' + cleaned; }\n  else if (cleaned.length < 10) { flags.push(`${fieldName}_too_short: \"${phone}\" (${cleaned.length} digits)`); return null; }\n  else if (cleaned.length > 11) { flags.push(`${fieldName}_possibly_international: \"${phone}\" (${cleaned.length} digits)`); return '+' + cleaned; }\n  const areaCode = cleaned.substring(1, 4);\n  if (areaCode.startsWith('0') || areaCode.startsWith('1')) { flags.push(`${fieldName}_invalid_area_code: \"${areaCode}\"`); return null; }\n  return '+' + cleaned;\n}\n\nfunction cleanName(name, fieldName, flags) {\n  if (!name) return null;\n  let cleaned = name.trim().replace(/\\*+$/, '').trim();\n  if (cleaned.length <= 1) { flags.push(`${fieldName}_too_short: \"${name}\"`); return null; }\n  if (/^\\d+$/.test(cleaned)) { flags.push(`${fieldName}_numeric: \"${name}\"`); return null; }\n  if (/\\d/.test(cleaned)) { flags.push(`${fieldName}_contains_digits: \"${name}\"`); return null; }\n  const junkNames = ['unknown','n/a','na','none','null','test','owner','manager','admin','info','contact'];\n  if (junkNames.includes(cleaned.toLowerCase())) { flags.push(`${fieldName}_junk_name: \"${name}\"`); return null; }\n  const credentials = ['lmt','cmt','rmt','lmbt','lmp','bctmb','nctmb','nctm','cpt','cst','mld','nmt','amt','abmp'];\n  if (credentials.includes(cleaned.toLowerCase())) { flags.push(`${fieldName}_credential_not_name: \"${name}\"`); return null; }\n  if (cleaned === cleaned.toUpperCase() || cleaned === cleaned.toLowerCase()) { cleaned = cleaned.charAt(0).toUpperCase() + cleaned.slice(1).toLowerCase(); }\n  return cleaned;\n}\n\nfunction validateLinkedIn(url, flags) {\n  if (!url) return null;\n  let cleaned = url.trim();\n  if (!/linkedin\\.com\\/in\\//i.test(cleaned)) {\n    if (/linkedin\\.com/i.test(cleaned)) { flags.push(`linkedin_not_personal_profile: \"${cleaned}\"`); }\n    else { flags.push(`linkedin_invalid_url: \"${cleaned}\"`); }\n    return null;\n  }\n  if (!cleaned.startsWith('http')) { cleaned = 'https://' + cleaned; }\n  cleaned = cleaned.replace(/^http:\\/\\//, 'https://');\n  return cleaned;\n}\n\nfor (const entry of items) {\n  const item = entry.json;\n  const contact = item._contact;\n  const flags = [];\n  if (!contact) { results.push({ json: { ...item, _validation_flags: ['no_contact_object'] } }); continue; }\n  contact.email_business = validateEmail(contact.email_business, 'email_business', flags);\n  contact.email_personal = validateEmail(contact.email_personal, 'email_personal', flags);\n  contact.phone_direct = validatePhone(contact.phone_direct, 'phone_direct', flags);\n  contact.first_name = cleanName(contact.first_name, 'first_name', flags);\n  contact.last_name = cleanName(contact.last_name, 'last_name', flags);\n  if (!contact.first_name) { flags.push('contact_has_no_valid_first_name'); }\n  contact.linkedin_url = validateLinkedIn(contact.linkedin_url, flags);\n  if (contact.location) {\n    contact.location = contact.location.trim();\n    if (!contact.location || contact.location === ',' || contact.location.length < 2) { contact.location = null; flags.push('location_empty_after_clean'); }\n  }\n  const hasValidContact = !!(contact.first_name);\n  if (flags.length > 0) { console.log(`Validation [${item._company_name}] (${item._source_method}): ${flags.join(', ')}`); }\n  results.push({ json: { _contact: contact, _company_name: item._company_name, _company_id: item._company_id, _source_method: item._source_method, _has_contact: hasValidContact, _validation_flags: flags } });\n}\n\nreturn results;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        5968,
        832
      ],
      "id": "ef9c827d-5398-4066-8a8a-a97dacd4cdd2",
      "name": "Validate & Clean Contact2"
    },
    {
      "parameters": {
        "jsCode": "// Validate & Clean Contact3 \u2014 runOnceForAllItems\nconst items = $input.all();\nconst results = [];\n\nfunction validateEmail(email, fieldName, flags) {\n  if (!email) return null;\n  let cleaned = email.trim().toLowerCase();\n  const emailRegex = /^[a-zA-Z0-9._%+\\-]+@[a-zA-Z0-9.\\-]+\\.[a-zA-Z]{2,}$/;\n  if (!emailRegex.test(cleaned)) { flags.push(`${fieldName}_invalid_format: \"${email}\"`); return null; }\n  const junkPatterns = [/^noreply@/, /^no-reply@/, /^donotreply@/, /^do-not-reply@/, /^test@/, /^admin@example\\./, /^info@example\\./, /^user@example\\./, /^sample@/, /^fake@/, /^placeholder@/, /^null@/, /^none@/, /^na@/, /^n\\/a@/, /^unknown@/, /^abuse@/, /^postmaster@/, /^mailer-daemon@/];\n  if (junkPatterns.some(p => p.test(cleaned))) { flags.push(`${fieldName}_junk_pattern: \"${cleaned}\"`); return null; }\n  const rolePatterns = [/^info@/, /^contact@/, /^hello@/, /^support@/, /^sales@/, /^office@/, /^billing@/, /^reception@/, /^frontdesk@/, /^front\\.desk@/, /^appointments@/, /^booking@/, /^bookings@/, /^schedule@/, /^scheduling@/, /^inquiries@/, /^inquiry@/, /^general@/, /^team@/, /^staff@/];\n  if (rolePatterns.some(p => p.test(cleaned))) { flags.push(`${fieldName}_role_based_kept: \"${cleaned}\"`); }\n  const junkDomains = ['example.com','example.org','example.net','test.com','test.org','placeholder.com','fake.com','noemail.com','nomail.com','none.com','localhost','mailinator.com','guerrillamail.com','tempmail.com','throwaway.email','yopmail.com'];\n  const domain = cleaned.split('@')[1];\n  if (junkDomains.includes(domain)) { flags.push(`${fieldName}_junk_domain: \"${domain}\"`); return null; }\n  const localPart = cleaned.split('@')[0];\n  if (/^\\d+$/.test(localPart)) { flags.push(`${fieldName}_numeric_local: \"${cleaned}\"`); return null; }\n  if (localPart.startsWith('.') || localPart.endsWith('.') || localPart.includes('..')) { flags.push(`${fieldName}_malformed_local: \"${cleaned}\"`); return null; }\n  return cleaned;\n}\n\nfunction validatePhone(phone, fieldName, flags) {\n  if (!phone) return null;\n  if (typeof phone === 'object' && phone !== null) { phone = phone.sanitized_number || phone.raw_number || phone.number || ''; }\n  let cleaned = phone.toString().trim().replace(/[^\\d]/g, '');\n  if (!cleaned || cleaned.length === 0) { flags.push(`${fieldName}_empty_after_strip`); return null; }\n  if (cleaned.length === 11 && cleaned.startsWith('1')) { /* ok */ }\n  else if (cleaned.length === 10) { cleaned = '1' + cleaned; }\n  else if (cleaned.length < 10) { flags.push(`${fieldName}_too_short: \"${phone}\" (${cleaned.length} digits)`); return null; }\n  else if (cleaned.length > 11) { flags.push(`${fieldName}_possibly_international: \"${phone}\" (${cleaned.length} digits)`); return '+' + cleaned; }\n  const areaCode = cleaned.substring(1, 4);\n  if (areaCode.startsWith('0') || areaCode.startsWith('1')) { flags.push(`${fieldName}_invalid_area_code: \"${areaCode}\"`); return null; }\n  return '+' + cleaned;\n}\n\nfunction cleanName(name, fieldName, flags) {\n  if (!name) return null;\n  let cleaned = name.trim().replace(/\\*+$/, '').trim();\n  if (cleaned.length <= 1) { flags.push(`${fieldName}_too_short: \"${name}\"`); return null; }\n  if (/^\\d+$/.test(cleaned)) { flags.push(`${fieldName}_numeric: \"${name}\"`); return null; }\n  if (/\\d/.test(cleaned)) { flags.push(`${fieldName}_contains_digits: \"${name}\"`); return null; }\n  const junkNames = ['unknown','n/a','na','none','null','test','owner','manager','admin','info','contact'];\n  if (junkNames.includes(cleaned.toLowerCase())) { flags.push(`${fieldName}_junk_name: \"${name}\"`); return null; }\n  const credentials = ['lmt','cmt','rmt','lmbt','lmp','bctmb','nctmb','nctm','cpt','cst','mld','nmt','amt','abmp'];\n  if (credentials.includes(cleaned.toLowerCase())) { flags.push(`${fieldName}_credential_not_name: \"${name}\"`); return null; }\n  if (cleaned === cleaned.toUpperCase() || cleaned === cleaned.toLowerCase()) { cleaned = cleaned.charAt(0).toUpperCase() + cleaned.slice(1).toLowerCase(); }\n  return cleaned;\n}\n\nfunction validateLinkedIn(url, flags) {\n  if (!url) return null;\n  let cleaned = url.trim();\n  if (!/linkedin\\.com\\/in\\//i.test(cleaned)) {\n    if (/linkedin\\.com/i.test(cleaned)) { flags.push(`linkedin_not_personal_profile: \"${cleaned}\"`); }\n    else { flags.push(`linkedin_invalid_url: \"${cleaned}\"`); }\n    return null;\n  }\n  if (!cleaned.startsWith('http')) { cleaned = 'https://' + cleaned; }\n  cleaned = cleaned.replace(/^http:\\/\\//, 'https://');\n  return cleaned;\n}\n\nfor (const entry of items) {\n  const item = entry.json;\n  const contact = item._contact;\n  const flags = [];\n  if (!contact) { results.push({ json: { ...item, _validation_flags: ['no_contact_object'] } }); continue; }\n  contact.email_business = validateEmail(contact.email_business, 'email_business', flags);\n  contact.email_personal = validateEmail(contact.email_personal, 'email_personal', flags);\n  contact.phone_direct = validatePhone(contact.phone_direct, 'phone_direct', flags);\n  contact.first_name = cleanName(contact.first_name, 'first_name', flags);\n  contact.last_name = cleanName(contact.last_name, 'last_name', flags);\n  if (!contact.first_name) { flags.push('contact_has_no_valid_first_name'); }\n  contact.linkedin_url = validateLinkedIn(contact.linkedin_url, flags);\n  if (contact.location) {\n    contact.location = contact.location.trim();\n    if (!contact.location || contact.location === ',' || contact.location.length < 2) { contact.location = null; flags.push('location_empty_after_clean'); }\n  }\n  const hasValidContact = !!(contact.first_name);\n  if (flags.length > 0) { console.log(`Validation [${item._company_name}] (${item._source_method}): ${flags.join(', ')}`); }\n  results.push({ json: { _contact: contact, _company_name: item._company_name, _company_id: item._company_id, _source_method: item._source_method, _has_contact: hasValidContact, _validation_flags: flags } });\n}\n\nreturn results;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        5888,
        448
      ],
      "id": "23432a36-a9b1-4fd6-a586-1467184c9ffc",
      "name": "Validate & Clean Contact3"
    },
    {
      "parameters": {
        "jsCode": "// Validate & Clean Contact4 \u2014 runOnceForAllItems\nconst items = $input.all();\nconst results = [];\n\nfunction validateEmail(email, fieldName, flags) {\n  if (!email) return null;\n  let cleaned = email.trim().toLowerCase();\n  const emailRegex = /^[a-zA-Z0-9._%+\\-]+@[a-zA-Z0-9.\\-]+\\.[a-zA-Z]{2,}$/;\n  if (!emailRegex.test(cleaned)) { flags.push(`${fieldName}_invalid_format: \"${email}\"`); return null; }\n  const junkPatterns = [/^noreply@/, /^no-reply@/, /^donotreply@/, /^do-not-reply@/, /^test@/, /^admin@example\\./, /^info@example\\./, /^user@example\\./, /^sample@/, /^fake@/, /^placeholder@/, /^null@/, /^none@/, /^na@/, /^n\\/a@/, /^unknown@/, /^abuse@/, /^postmaster@/, /^mailer-daemon@/];\n  if (junkPatterns.some(p => p.test(cleaned))) { flags.push(`${fieldName}_junk_pattern: \"${cleaned}\"`); return null; }\n  const rolePatterns = [/^info@/, /^contact@/, /^hello@/, /^support@/, /^sales@/, /^office@/, /^billing@/, /^reception@/, /^frontdesk@/, /^front\\.desk@/, /^appointments@/, /^booking@/, /^bookings@/, /^schedule@/, /^scheduling@/, /^inquiries@/, /^inquiry@/, /^general@/, /^team@/, /^staff@/];\n  if (rolePatterns.some(p => p.test(cleaned))) { flags.push(`${fieldName}_role_based_kept: \"${cleaned}\"`); }\n  const junkDomains = ['example.com','example.org','example.net','test.com','test.org','placeholder.com','fake.com','noemail.com','nomail.com','none.com','localhost','mailinator.com','guerrillamail.com','tempmail.com','throwaway.email','yopmail.com'];\n  const domain = cleaned.split('@')[1];\n  if (junkDomains.includes(domain)) { flags.push(`${fieldName}_junk_domain: \"${domain}\"`); return null; }\n  const localPart = cleaned.split('@')[0];\n  if (/^\\d+$/.test(localPart)) { flags.push(`${fieldName}_numeric_local: \"${cleaned}\"`); return null; }\n  if (localPart.startsWith('.') || localPart.endsWith('.') || localPart.includes('..')) { flags.push(`${fieldName}_malformed_local: \"${cleaned}\"`); return null; }\n  return cleaned;\n}\n\nfunction validatePhone(phone, fieldName, flags) {\n  if (!phone) return null;\n  if (typeof phone === 'object' && phone !== null) { phone = phone.sanitized_number || phone.raw_number || phone.number || ''; }\n  let cleaned = phone.toString().trim().replace(/[^\\d]/g, '');\n  if (!cleaned || cleaned.length === 0) { flags.push(`${fieldName}_empty_after_strip`); return null; }\n  if (cleaned.length === 11 && cleaned.startsWith('1')) { /* ok */ }\n  else if (cleaned.length === 10) { cleaned = '1' + cleaned; }\n  else if (cleaned.length < 10) { flags.push(`${fieldName}_too_short: \"${phone}\" (${cleaned.length} digits)`); return null; }\n  else if (cleaned.length > 11) { flags.push(`${fieldName}_possibly_international: \"${phone}\" (${cleaned.length} digits)`); return '+' + cleaned; }\n  const areaCode = cleaned.substring(1, 4);\n  if (areaCode.startsWith('0') || areaCode.startsWith('1')) { flags.push(`${fieldName}_invalid_area_code: \"${areaCode}\"`); return null; }\n  return '+' + cleaned;\n}\n\nfunction cleanName(name, fieldName, flags) {\n  if (!name) return null;\n  let cleaned = name.trim().replace(/\\*+$/, '').trim();\n  if (cleaned.length <= 1) { flags.push(`${fieldName}_too_short: \"${name}\"`); return null; }\n  if (/^\\d+$/.test(cleaned)) { flags.push(`${fieldName}_numeric: \"${name}\"`); return null; }\n  if (/\\d/.test(cleaned)) { flags.push(`${fieldName}_contains_digits: \"${name}\"`); return null; }\n  const junkNames = ['unknown','n/a','na','none','null','test','owner','manager','admin','info','contact'];\n  if (junkNames.includes(cleaned.toLowerCase())) { flags.push(`${fieldName}_junk_name: \"${name}\"`); return null; }\n  const credentials = ['lmt','cmt','rmt','lmbt','lmp','bctmb','nctmb','nctm','cpt','cst','mld','nmt','amt','abmp'];\n  if (credentials.includes(cleaned.toLowerCase())) { flags.push(`${fieldName}_credential_not_name: \"${name}\"`); return null; }\n  if (cleaned === cleaned.toUpperCase() || cleaned === cleaned.toLowerCase()) { cleaned = cleaned.charAt(0).toUpperCase() + cleaned.slice(1).toLowerCase(); }\n  return cleaned;\n}\n\nfunction validateLinkedIn(url, flags) {\n  if (!url) return null;\n  let cleaned = url.trim();\n  if (!/linkedin\\.com\\/in\\//i.test(cleaned)) {\n    if (/linkedin\\.com/i.test(cleaned)) { flags.push(`linkedin_not_personal_profile: \"${cleaned}\"`); }\n    else { flags.push(`linkedin_invalid_url: \"${cleaned}\"`); }\n    return null;\n  }\n  if (!cleaned.startsWith('http')) { cleaned = 'https://' + cleaned; }\n  cleaned = cleaned.replace(/^http:\\/\\//, 'https://');\n  return cleaned;\n}\n\nfor (const entry of items) {\n  const item = entry.json;\n  const contact = item._contact;\n  const flags = [];\n  if (!contact) { results.push({ json: { ...item, _validation_flags: ['no_contact_object'] } }); continue; }\n  contact.email_business = validateEmail(contact.email_business, 'email_business', flags);\n  contact.email_personal = validateEmail(contact.email_personal, 'email_personal', flags);\n  contact.phone_direct = validatePhone(contact.phone_direct, 'phone_direct', flags);\n  contact.first_name = cleanName(contact.first_name, 'first_name', flags);\n  contact.last_name = cleanName(contact.last_name, 'last_name', flags);\n  if (!contact.first_name) { flags.push('contact_has_no_valid_first_name'); }\n  contact.linkedin_url = validateLinkedIn(contact.linkedin_url, flags);\n  if (contact.location) {\n    contact.location = contact.location.trim();\n    if (!contact.location || contact.location === ',' || contact.location.length < 2) { contact.location = null; flags.push('location_empty_after_clean'); }\n  }\n  const hasValidContact = !!(contact.first_name);\n  if (flags.length > 0) { console.log(`Validation [${item._company_name}] (${item._source_method}): ${flags.join(', ')}`); }\n  results.push({ json: { _contact: contact, _company_name: item._company_name, _company_id: item._company_id, _source_method: item._source_method, _has_contact: hasValidContact, _validation_flags: flags } });\n}\n\nreturn results;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        5936,
        608
      ],
      "id": "f8e4ca4c-af65-407f-ad5c-255c26983df3",
      "name": "Validate & Clean Contact4"
    },
    {
      "parameters": {
        "jsCode": "// Collect stats from all paths\nconst config = $('Step 3a Config').first().json;\nlet companiesProcessed = 0;\nlet soloDetected = 0;\nlet soloWithName = 0;\nlet apolloSearched = 0;\nlet apolloFound = 0;\nlet apolloEnriched = 0;\nlet websiteScraped = 0;\nlet websiteFoundName = 0;\nlet noDomainFallback = 0;\nlet noDomainFoundName = 0;\nlet totalContactsInserted = 0;\n\n// Validation stats\nlet validationTotal = 0;\nlet emailsNulled = 0;\nlet phonesNulled = 0;\nlet namesNulled = 0;\nlet linkedinNulled = 0;\nlet roleBasedEmails = 0;\nlet contactsWithFlags = 0;\nlet allFlags = [];\n\ntry {\n  const batchItems = $('Filter & Parse Batch').all();\n  companiesProcessed = batchItems.filter(i => !i.json._empty).length;\n} catch(e) {}\n\ntry {\n  const soloItems = $('Prepare Solo Contact').all();\n  soloDetected = soloItems.length;\n  soloWithName = soloItems.filter(i => i.json._has_contact).length;\n} catch(e) {}\n\ntry {\n  const apolloItems = $('Parse Apollo Search').all();\n  apolloSearched = apolloItems.length;\n  apolloFound = apolloItems.filter(i => i.json._apollo_found).length;\n} catch(e) {}\n\ntry {\n  const enrichItems = $('Parse Apollo Enrich').all();\n  apolloEnriched = enrichItems.filter(i => i.json._has_contact).length;\n} catch(e) {}\n\ntry {\n  const searchOnlyItems = $('Apollo Search Only Contact').all();\n  apolloEnriched += searchOnlyItems.filter(i => i.json._has_contact).length;\n} catch(e) {}\n\ntry {\n  const aboutItems = $('Parse About Page').all();\n  websiteScraped = aboutItems.length;\n  websiteFoundName = aboutItems.filter(i => i.json._has_contact).length;\n} catch(e) {}\n\ntry {\n  const noDomainItems = $('No Domain Fallback').all();\n  noDomainFallback = noDomainItems.length;\n  noDomainFoundName = noDomainItems.filter(i => i.json._has_contact).length;\n} catch(e) {}\n\n// Collect validation stats from all 5 Validate & Clean nodes\nconst validateNodeNames = [\n  'Validate & Clean Contact',\n  'Validate & Clean Contact1',\n  'Validate & Clean Contact2',\n  'Validate & Clean Contact3',\n  'Validate & Clean Contact4'\n];\n\nfor (const nodeName of validateNodeNames) {\n  try {\n    const validatedItems = $(nodeName).all();\n    validationTotal += validatedItems.length;\n    for (const item of validatedItems) {\n      const flags = item.json._validation_flags || [];\n      if (flags.length > 0) {\n        contactsWithFlags++;\n        allFlags.push(...flags);\n      }\n    }\n  } catch(e) {\n    // Node didn't execute in this run (normal - not all paths fire every time)\n  }\n}\n\nemailsNulled = allFlags.filter(f => f.startsWith('email_business_') || f.startsWith('email_personal_')).length;\nphonesNulled = allFlags.filter(f => f.startsWith('phone_direct_')).length;\nnamesNulled = allFlags.filter(f => f.startsWith('first_name_') || f.startsWith('last_name_') || f === 'contact_has_no_valid_first_name').length;\nlinkedinNulled = allFlags.filter(f => f.startsWith('linkedin_')).length;\nroleBasedEmails = allFlags.filter(f => f.includes('_role_based')).length;\n\ntotalContactsInserted = soloWithName + apolloEnriched + websiteFoundName + noDomainFoundName;\n\nconst summary = {\n  run_completed_at: new Date().toISOString(),\n  batch_size: config.batch_size,\n  companies_processed: companiesProcessed,\n  solo_detected: soloDetected,\n  solo_with_name_extracted: soloWithName,\n  apollo_searched: apolloSearched,\n  apollo_found_people: apolloFound,\n  apollo_contacts_created: apolloEnriched,\n  website_scraped: websiteScraped,\n  website_names_found: websiteFoundName,\n  no_domain_fallback: noDomainFallback,\n  no_domain_names_found: noDomainFoundName,\n  total_contacts_inserted: totalContactsInserted,\n  companies_without_contacts: companiesProcessed - totalContactsInserted,\n  validation: {\n    contacts_validated: validationTotal,\n    contacts_with_issues: contactsWithFlags,\n    emails_nulled: emailsNulled,\n    role_based_emails_rejected: roleBasedEmails,\n    phones_nulled: phonesNulled,\n    names_nulled: namesNulled,\n    linkedin_nulled: linkedinNulled,\n    all_flags: allFlags\n  },\n  message: `Created ${totalContactsInserted} contacts from ${companiesProcessed} companies. Sources: ${soloWithName} solo, ${apolloEnriched} Apollo, ${websiteFoundName} website, ${noDomainFoundName} name extraction. Validation cleaned ${contactsWithFlags}/${validationTotal} contacts (${emailsNulled} emails, ${phonesNulled} phones, ${namesNulled} names nulled).`\n};\n\nconsole.log('=== STEP 3a: FIND PEOPLE SUMMARY ===');\nconsole.log(JSON.stringify(summary, null, 2));\n\nreturn [{ json: summary }];"
      },
      "id": "81ffb1a3-dddc-4389-986a-d0b69d280c2b",
      "name": "Run Summary3",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        6528,
        352
      ],
      "notes": "Final summary: contacts created from each source (solo detection, Apollo, website scrape, name extraction)."
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "name": "skip_hunter",
              "value": "false",
              "type": "string"
            },
            {
              "name": "skip_snovio",
              "value": "true",
              "type": "string"
            },
            {
              "name": "skip_hunter_verifier",
              "value": "false",
              "type": "string"
            },
            {
              "name": "skip_namsor",
              "value": "false",
              "type": "string"
            },
            {
              "name": "skip_phone_verifier",
              "value": "false",
              "type": "string"
            },
            {
              "name": "batch_size",
              "value": "1000",
              "type": "string"
            },
            {
              "name": "batch_offset",
              "value": "0",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "id": "28d78eda-3435-4c71-8976-ff2199966651",
      "name": "Step 4 Config",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        6976,
        352
      ],
      "notes": "Config for Step 4: Enrich People.\n- skip_hunter/skip_snovio: set to 'true' to disable. Set to 'false' when ready.\n- skip_hunter_verifier: 'true' = skip email verification, 'false' = verify emails via Hunter\n- skip_namsor: 'false' = enabled (NamSor API key required as NAMSOR_API_KEY env var)\n- batch_size: how many contacts to process"
    },
    {
      "parameters": {
        "url": "={{ $env.SUPABASE_URL }}/rest/v1/contacts?select=id,company_id,first_name,last_name,role,is_owner,email_business,email_personal,phone_direct,linkedin_url,cultural_affinity,source,email_status,phone_status,phone_line_type,phone_carrier&or=(email_status.is.null,email_status.eq.unverified,and(phone_direct.not.is.null,phone_status.is.null))&order=created_at.asc&limit={{ $json.batch_size }}&offset={{ $json.batch_offset }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "apikey",
              "value": "={{ $env.SUPABASE_SERVICE_KEY }}"
            },
            {
              "name": "Authorization",
              "value": "=Bearer {{ $env.SUPABASE_SERVICE_KEY }}"
            }
          ]
        },
        "options": {
          "timeout": 30000
        }
      },
      "id": "f722b2cc-4a9e-4e35-9f4d-392f03f00973",
      "name": "Fetch Contacts",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        7200,
        352
      ],
      "onError": "continueRegularOutput",
      "notes": "Fetches all contacts from Supabase for enrichment",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "jsCode": "// Merge contacts with their company data and filter to those needing enrichment\n// Metro-scoped: only process contacts whose company is in the current metro\nconst contactItems = $('Fetch Contacts').all();\nconst companyItems = $('Fetch Companies1').all();\n\n// Parse contacts - deduplicate by id\nlet rawContacts = [];\nfor (const item of contactItems) {\n  if (item.json && Array.isArray(item.json)) {\n    rawContacts.push(...item.json);\n  } else if (item.json && item.json.id) {\n    rawContacts.push(item.json);\n  }\n}\n\n// Deduplicate by contact id\nconst seenIds = new Set();\nlet contacts = [];\nfor (const c of rawContacts) {\n  if (c.id && !seenIds.has(c.id)) {\n    seenIds.add(c.id);\n    contacts.push(c);\n  }\n}\n\n// Parse companies into a lookup map (map deduplicates naturally)\n// NOTE: Fetch Companies1 is now metro-scoped, so this map only contains current metro companies\nlet companyMap = {};\nfor (const item of companyItems) {\n  if (Array.isArray(item.json)) {\n    for (const co of item.json) {\n      if (co.id) companyMap[co.id] = co;\n    }\n  } else if (item.json && item.json.id) {\n    companyMap[item.json.id] = item.json;\n  }\n}\n\n// Filter contacts that need enrichment:\n// any contact where there's still something to enrich\nconst needsEnrichment = contacts.filter(c => {\n  const missingEmail = !c.email_business;\n  const missingCulturalAffinity = !c.cultural_affinity;\n  const missingPhone = !c.phone_direct;\n  const missingLinkedin = !c.linkedin_url;\n  const verifiedStatuses = ['verified', 'invalid', 'risky', 'accept_all'];\n  const emailNeedsVerification = c.email_business && !verifiedStatuses.includes(c.email_status);\n  const phoneNeedsVerification = c.phone_direct && !c.phone_status;\n  return missingEmail || missingCulturalAffinity || missingPhone || missingLinkedin || emailNeedsVerification || phoneNeedsVerification;\n});\n\n// Metro filter: only keep contacts whose company is in the metro-scoped companyMap\nconst metroFiltered = needsEnrichment.filter(c => companyMap[c.company_id]);\nconst crossMetroSkipped = needsEnrichment.length - metroFiltered.length;\n\nconsole.log(`Contacts: ${rawContacts.length} raw, ${contacts.length} unique, ${needsEnrichment.length} need enrichment, ${crossMetroSkipped} skipped (other metro), ${metroFiltered.length} in current metro`);\n\nif (metroFiltered.length === 0) {\n  return [{ json: { _empty: true, _count: 0, _message: 'All contacts are already enriched or belong to other metros' } }];\n}\n\n// Merge company data into each contact\nconst merged = metroFiltered.map(c => {\n  const company = companyMap[c.company_id];\n  return {\n    json: {\n      ...c,\n      _company_name: company.name || null,\n      _company_domain: company.domain || null,\n      _company_phone: company.phone || null,\n      _company_email: company.email || null,\n      _company_email_status: company.email_status || null,\n      _company_phone_status: company.phone_status || null,\n      _company_phone_line_type: company.phone_line_type || null,\n      _company_city: company.city || null,\n      _company_state: company.state || null\n    }\n  };\n});\n\nreturn merged;"
      },
      "id": "424ffbc6-0f1d-45d5-84e5-d5ec97a212bf",
      "name": "Filter & Merge Contacts",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        7872,
        352
      ],
      "notes": "Merges contact data with company data. Filters to contacts that still need enrichment (missing email, cultural_affinity, phone, linkedin, OR email_status is unverified)."
    },
    {
      "parameters": {
        "url": "={{ $env.SUPABASE_URL }}/rest/v1/companies?select=id,name,phone,domain,email,email_status,phone_status,phone_line_type,city,state&enrichment_status=in.(partially_enriched,fully_enriched)&discovery_metro=eq.{{ $('Metro Config').first().json.metro_name }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "apikey",
              "value": "={{ $env.SUPABASE_SERVICE_KEY }}"
            },
            {
              "name": "Authorization",
              "value": "=Bearer {{ $env.SUPABASE_SERVICE_KEY }}"
            }
          ]
        },
        "options": {
          "timeout": 30000
        }
      },
      "id": "12495704-e95c-4ee8-854d-39cb85a6cf1c",
      "name": "Fetch Companies1",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        7648,
        352
      ],
      "onError": "continueRegularOutput",
      "notes": "Fetches company data (domain, phone, city) to support enrichment lookups"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose"
          },
          "conditions": [
            {
              "id": "is-empty",
              "leftValue": "={{ $json._empty }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "f0e8ee2e-ba25-4ddc-8fc9-f25bf468e1bb",
      "name": "Batch Empty?3",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        8096,
        352
      ]
    },
    {
      "parameters": {
        "jsCode": "return [{ json: { message: 'No contacts need enrichment. All done!', completed_at: new Date().toISOString() } }];"
      },
      "id": "0ae0b2d6-d1ac-4d25-bf41-a7817ebd95b2",
      "name": "No Records - Done3",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        8320,
        256
      ]
    },
    {
      "parameters": {
        "jsCode": "// Collapse all input items into a single trigger item for the next step\nreturn [{ json: { _trigger: 'continue', _timestamp: new Date().toISOString() } }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        6752,
        352
      ],
      "id": "29d1f7d6-d097-4eca-a42a-966f358a03fd",
      "name": "Bridge to 4"
    },
    {
      "parameters": {
        "jsCode": "// Collapse to single item - Fetch Contacts data is accessed by name in Filter & Merge\nreturn [{ json: { _trigger: 'fetch_companies' } }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        7424,
        352
      ],
      "id": "4a038b1f-ec8a-4141-b23a-181f1cfa1d08",
      "name": "Collapse to Single"
    },
    {
      "parameters": {
        "jsCode": "// Enrich Contacts \u2014 Single Code node replacing the entire Step 4 branching pipeline\n// Mode: runOnceForAllItems\n// Uses this.helpers.httpRequest() for inline HTTP calls (NOT $http which is unavailable)\n\nconst config = $('Step 4 Config').first().json;\nconst contacts = $input.all().filter(item => !item.json._empty);\n\nconst results = [];\n\n// Helper: delay between API calls for rate limiting\nconst delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));\n\n// Dedup guard: track companies that already had email set/verified this execution\nconst staticData = $getWorkflowStaticData('global');\nif (!staticData._companyEmailsSet) staticData._companyEmailsSet = {};\nconst companyEmailsSet = staticData._companyEmailsSet;\n\n// BUG-F019 FIX: Clear ALL stale keys from previous executions.\n// $getWorkflowStaticData('global') persists across executions, not just batches.\n// Without this, company phone/email dedup guards from previous runs permanently\n// block verification for companies that were already processed.\n// Within a single execution, keys are rebuilt as contacts are processed.\nfor (const key of Object.keys(companyEmailsSet)) {\n  delete companyEmailsSet[key];\n}\n\n// ADR-024: Per-contact dedup \u2014 track enriched contacts across convergence batches\nif (!staticData._enriched_contact_ids) {\n  staticData._enriched_contact_ids = {};\n}\n\n// Phone validation (from Prepare Contact Update)\nfunction validatePhone(phone) {\n  if (!phone) return null;\n  if (typeof phone === 'object' && phone !== null) {\n    phone = phone.sanitized_number || phone.raw_number || phone.number || '';\n  }\n  let cleaned = phone.toString().trim().replace(/[^\\d]/g, '');\n  if (!cleaned || cleaned.length === 0) return null;\n  if (cleaned.length === 11 && cleaned.startsWith('1')) { /* ok */ }\n  else if (cleaned.length === 10) { cleaned = '1' + cleaned; }\n  else if (cleaned.length < 10) { return null; }\n  else if (cleaned.length > 11 && cleaned.length <= 15) {\n    // International number - allow if not starting with 1 (NA)\n    if (cleaned.startsWith('1')) return null;  // NA number too long\n    return '+' + cleaned;\n  }\n  else if (cleaned.length > 15) { return null; }  // ITU max is 15 digits\n  const areaCode = cleaned.substring(1, 4);\n  if (areaCode.startsWith('0') || areaCode.startsWith('1')) return null;\n  return '+' + cleaned;\n}\n\n// Role-based email detection (same 19+1 patterns as Validate & Clean Contact)\nconst rolePatterns = [\n  /^info@/i, /^contact@/i, /^hello@/i, /^support@/i, /^sales@/i,\n  /^office@/i, /^billing@/i, /^reception@/i, /^frontdesk@/i, /^front\\.desk@/i,\n  /^appointments@/i, /^booking@/i, /^bookings@/i, /^schedule@/i, /^scheduling@/i,\n  /^inquiries@/i, /^inquiry@/i, /^general@/i, /^team@/i, /^staff@/i\n];\n\nfunction isRoleBased(email) {\n  if (!email) return false;\n  return rolePatterns.some(p => p.test(email));\n}\n\n// Free webmail domains (role-based check doesn't apply to these)\nconst freeWebmailDomains = [\n  'gmail.com', 'yahoo.com', 'outlook.com', 'hotmail.com', 'aol.com',\n  'icloud.com', 'me.com', 'mac.com', 'live.com', 'msn.com',\n  'protonmail.com', 'proton.me', 'zoho.com', 'yandex.com',\n  'mail.com', 'gmx.com', 'fastmail.com', 'tutanota.com'\n];\n\nfunction isFreeWebmail(email) {\n  if (!email) return false;\n  const domain = email.split('@')[1];\n  return freeWebmailDomains.includes(domain);\n}\n\n// Helper: verify an email via Hunter Verifier API\nasync function verifyEmail(email) {\n  try {\n    const verifyUrl = `https://api.hunter.io/v2/email-verifier?email=${encodeURIComponent(email)}&api_key=${$env.HUNTER_API_KEY}`;\n    const verifyResp = await this.helpers.httpRequest({ method: 'GET', url: verifyUrl, headers: { 'Accept': 'application/json' }, json: true });\n    const vBody = verifyResp.data || verifyResp;\n    if (vBody && vBody.status) {\n      let status;\n      switch (vBody.status) {\n        case 'valid': status = 'verified'; break;\n        case 'invalid': status = 'invalid'; break;\n        case 'accept_all': status = 'accept_all'; break;\n        case 'disposable': status = 'invalid'; break;\n        case 'webmail': status = 'verified'; break;\n        default: status = 'risky'; break;\n      }\n      return { status, score: vBody.score || null, verified_at: new Date().toISOString() };\n    }\n  } catch(e) {\n    console.log(`Verifier error for ${email}: ${e.message}`);\n  }\n  return null;\n}\n\n// Helper: verify a phone number via Telnyx Number Lookup API\nasync function verifyPhone(phoneNumber) {\n  try {\n    const resp = await this.helpers.httpRequest({\n      method: 'GET',\n      url: `https://api.telnyx.com/v2/number_lookup/${encodeURIComponent(phoneNumber)}?type=carrier`,\n      headers: {\n        'Authorization': `Bearer ${$env.TELNYX_API_KEY}`,\n        'Accept': 'application/json'\n      },\n      json: true\n    });\n    const data = resp.data || resp;\n    if (data && data.valid === false) {\n      return { phone_status: 'invalid', phone_line_type: null, phone_carrier: null };\n    }\n    // Map carrier type\n    let lineType = null;\n    const carrierType = (data.carrier && data.carrier.type) || null;\n    if (carrierType) {\n      const typeMap = { 'mobile': 'mobile', 'landline': 'landline', 'fixed line': 'landline', 'voip': 'voip', 'toll free': 'toll_free', 'toll_free': 'toll_free' };\n      lineType = typeMap[carrierType.toLowerCase()] || null;\n    }\n    const carrierName = (data.carrier && data.carrier.name) || null;\n    const phoneStatus = lineType === 'voip' ? 'voip' : 'valid';\n    return {\n      phone_status: phoneStatus,\n      phone_line_type: lineType,\n      phone_carrier: carrierName\n    };\n  } catch(e) {\n    // 404 or 422 = invalid number\n    if (e.statusCode === 404 || e.statusCode === 422) {\n      return { phone_status: 'invalid', phone_line_type: null, phone_carrier: null };\n    }\n    console.log(`Telnyx error for ${phoneNumber}: ${e.message} (status: ${e.statusCode || 'unknown'})`);\n    return { phone_status: null, phone_line_type: null, phone_carrier: null, _error: `${e.statusCode || 'unknown'}: ${e.message}` };\n  }\n}\n\nfor (const item of contacts) {\n  const contact = { ...item.json };\n\n  // ADR-024: Skip if already enriched in a previous convergence batch\n  const contactId = contact.id;\n  if (staticData._enriched_contact_ids[contactId]) {\n    results.push({\n      json: {\n        _contact_id: contactId,\n        _company_id: contact.company_id,\n        _first_name: contact.first_name,\n        _last_name: contact.last_name,\n        _company_name: contact._company_name,\n        _skip_reason: 'already_enriched_in_earlier_batch',\n        _has_updates: false\n      }\n    });\n    continue;\n  }\n  // Mark as enriched\n  staticData._enriched_contact_ids[contactId] = true;\n\n  // Initialize enrichment fields\n  contact._hunter_email = null;\n  contact._hunter_score = 0;\n  contact._hunter_linkedin = null;\n  contact._hunter_phone = null;\n  contact._snovio_email = null;\n  contact._email_source = null;\n  contact._best_email = contact.email_business || null;\n  contact._best_phone = contact.phone_direct || contact._company_phone || null;\n  contact._best_linkedin = contact.linkedin_url || null;\n  contact._email_status = null;\n  contact._email_verified_at = null;\n  contact._verifier_score = null;\n  contact._cultural_affinity = contact.cultural_affinity || null;\n  contact._namsor_country = null;\n  contact._namsor_region = null;\n  contact._namsor_probability = null;\n  contact._company_email_routed = false;\n  contact._company_email_verified = false;\n  contact._phone_status = null;\n  contact._phone_line_type = null;\n  contact._phone_carrier = null;\n  contact._company_phone_verified = false;\n  contact._phone_error = null;\n\n  const needsEmail = !contact.email_business;\n  const hasDomainAndName = contact._company_domain && contact.first_name;\n  const verifiedStatuses = ['verified', 'invalid', 'risky', 'accept_all'];\n  const emailNeedsVerification = contact.email_business && !verifiedStatuses.includes(contact.email_status);\n\n  // EMAIL WATERFALL\n\n  if (needsEmail && hasDomainAndName) {\n    // --- HUNTER EMAIL FINDER ---\n    if (config.skip_hunter !== 'true') {\n      try {\n        const hunterUrl = `https://api.hunter.io/v2/email-finder?domain=${encodeURIComponent(contact._company_domain)}&first_name=${encodeURIComponent(contact.first_name)}&last_name=${encodeURIComponent(contact.last_name || '')}&api_key=${$env.HUNTER_API_KEY}`;\n        const hunterResp = await this.helpers.httpRequest({ method: 'GET', url: hunterUrl, headers: { 'Accept': 'application/json' }, json: true });\n        const hData = hunterResp.data || hunterResp;\n        if (hData && hData.email && (hData.score === undefined || hData.score >= 50)) {\n          contact._hunter_email = hData.email;\n          contact._hunter_score = hData.score || 0;\n          contact._hunter_linkedin = hData.linkedin_url || null;\n          contact._hunter_phone = hData.phone_number || null;\n          contact._email_source = 'hunter';\n        }\n        await delay(200);\n      } catch(e) {\n        console.log(`Hunter error for ${contact.first_name}: ${e.message}`);\n      }\n    }\n\n    // --- SNOV.IO EMAIL FINDER (fallback) ---\n    if (!contact._hunter_email && config.skip_snovio !== 'true') {\n      try {\n        const snovResp = await this.helpers.httpRequest({\n          method: 'POST',\n          url: 'https://api.snov.io/v1/get-emails-from-names',\n          headers: { 'Content-Type': 'application/json' },\n          body: {\n            firstName: contact.first_name,\n            lastName: contact.last_name || '',\n            domain: contact._company_domain\n          },\n          json: true\n        });\n        const emails = snovResp.emails || snovResp.data?.emails || [];\n        if (Array.isArray(emails) && emails.length > 0) {\n          const valid = emails.find(e => e.emailStatus === 'valid' || e.status === 'valid') || emails[0];\n          contact._snovio_email = valid.email || valid.value || null;\n          if (contact._snovio_email) contact._email_source = 'snovio';\n        }\n        await delay(500);\n      } catch(e) {\n        console.log(`Snov.io error for ${contact.first_name}: ${e.message}`);\n      }\n    }\n\n    contact._best_email = contact._hunter_email || contact._snovio_email || null;\n    contact._best_phone = contact.phone_direct || contact._hunter_phone || contact._company_phone || null;\n    contact._best_linkedin = contact.linkedin_url || contact._hunter_linkedin || null;\n  } else if (contact.email_business) {\n    contact._best_email = contact.email_business;\n    contact._email_source = 'existing';\n  }\n\n  // COMPANY EMAIL ROUTING\n  // If contact's email is role-based, route it to the company\n\n  if (contact._best_email && isRoleBased(contact._best_email) && !isFreeWebmail(contact._best_email)) {\n    const companyId = contact.company_id;\n    const companyHasEmail = !!(contact._company_email);\n\n    if (!companyHasEmail && !companyEmailsSet[companyId]) {\n      contact._routed_company_email = contact._best_email;\n      contact._company_email_routed = true;\n      companyEmailsSet[companyId] = contact._best_email;\n      console.log(`Routed role-based email ${contact._best_email} to company ${contact._company_name || companyId}`);\n    }\n\n    if (contact.email_personal) {\n      contact._best_email = contact.email_personal;\n      contact._email_source = 'personal_promoted';\n      console.log(`Promoted personal email ${contact.email_personal} for ${contact.first_name} (role-based went to company)`);\n    }\n  }\n\n  // EMAIL VERIFICATION (contact email)\n\n  if (contact._best_email && config.skip_hunter_verifier !== 'true') {\n    const shouldVerify = !contact.email_business || emailNeedsVerification || contact._email_source === 'hunter' || contact._email_source === 'snovio' || contact._email_source === 'personal_promoted';\n    if (shouldVerify) {\n      const vResult = await verifyEmail.call(this, contact._best_email);\n      if (vResult) {\n        contact._email_status = vResult.status;\n        contact._email_verified_at = vResult.verified_at;\n        contact._verifier_score = vResult.score;\n      }\n      await delay(700);\n    }\n  } else if (contact._best_email) {\n    contact._email_status = 'unverified';\n  }\n\n  // COMPANY EMAIL VERIFICATION\n  // Verify company email if it hasn't been verified yet (from website scrape OR routing)\n\n  const companyEmailToVerify = contact._routed_company_email || contact._company_email;\n  const companyEmailNeedsVerification = companyEmailToVerify && !contact._company_email_status;\n  const companyId = contact.company_id;\n\n  if (companyEmailNeedsVerification && config.skip_hunter_verifier !== 'true' && !companyEmailsSet[companyId + '_verified']) {\n    const vResult = await verifyEmail.call(this, companyEmailToVerify);\n    let companyPatch = {};\n\n    if (contact._routed_company_email) {\n      companyPatch.email = contact._routed_company_email;\n    }\n\n    if (vResult) {\n      companyPatch.email_status = vResult.status;\n      contact._company_email_verified = true;\n      console.log(`Verified company email ${companyEmailToVerify}: ${vResult.status}`);\n    }\n\n    if (Object.keys(companyPatch).length > 0) {\n      try {\n        await this.helpers.httpRequest({\n          method: 'PATCH',\n          url: `${$env.SUPABASE_URL}/rest/v1/companies?id=eq.${companyId}`,\n          headers: {\n            'apikey': $env.SUPABASE_SERVICE_KEY,\n            'Authorization': `Bearer ${$env.SUPABASE_SERVICE_KEY}`,\n            'Content-Type': 'application/json',\n            'Prefer': 'return=minimal'\n          },\n          body: companyPatch,\n          json: true\n        });\n        console.log(`PATCHed company ${contact._company_name || companyId}: ${JSON.stringify(companyPatch)}`);\n      } catch(e) {\n        console.log(`Company PATCH error for ${companyId}: ${e.message}`);\n      }\n    }\n\n    companyEmailsSet[companyId + '_verified'] = true;\n    await delay(700);\n  } else if (contact._routed_company_email && !companyEmailsSet[companyId + '_verified']) {\n    try {\n      await this.helpers.httpRequest({\n        method: 'PATCH',\n        url: `${$env.SUPABASE_URL}/rest/v1/companies?id=eq.${companyId}`,\n        headers: {\n          'apikey': $env.SUPABASE_SERVICE_KEY,\n          'Authorization': `Bearer ${$env.SUPABASE_SERVICE_KEY}`,\n          'Content-Type': 'application/json',\n          'Prefer': 'return=minimal'\n        },\n        body: { email: contact._routed_company_email },\n        json: true\n      });\n      console.log(`PATCHed company email (unverified) ${contact._company_name || companyId}: ${contact._routed_company_email}`);\n    } catch(e) {\n      console.log(`Company PATCH error for ${companyId}: ${e.message}`);\n    }\n    companyEmailsSet[companyId + '_verified'] = true;\n    await delay(50);\n  }\n\n  // NAMSOR CULTURAL AFFINITY\n\n  if (!contact.cultural_affinity && contact.first_name && (contact.last_name || '').length > 0 && config.skip_namsor !== 'true') {\n    try {\n      const namsorUrl = `https://v2.namsor.com/NamSorAPIv2/api2/json/origin/${encodeURIComponent(contact.first_name)}/${encodeURIComponent(contact.last_name || 'Unknown')}`;\n      const namsorResp = await this.helpers.httpRequest({ method: 'GET', url: namsorUrl, headers: { 'X-API-KEY': $env.NAMSOR_API_KEY, 'Accept': 'application/json' }, json: true });\n      if (namsorResp && namsorResp.countryOrigin) {\n        const parts = [];\n        if (namsorResp.regionOrigin) parts.push(namsorResp.regionOrigin);\n        if (namsorResp.subRegionOrigin && namsorResp.subRegionOrigin !== namsorResp.regionOrigin) parts.push(namsorResp.subRegionOrigin);\n        if (namsorResp.countryOrigin) parts.push(namsorResp.countryOrigin);\n        contact._cultural_affinity = parts.join(' / ');\n        if (namsorResp.probabilityCalibrated && namsorResp.probabilityCalibrated < 0.3) {\n          contact._cultural_affinity += ' (low confidence)';\n        }\n        contact._namsor_country = namsorResp.countryOrigin;\n        contact._namsor_region = namsorResp.regionOrigin;\n        contact._namsor_probability = namsorResp.probabilityCalibrated;\n      }\n      await delay(100);\n    } catch(e) {\n      console.log(`NamSor error for ${contact.first_name}: ${e.message}`);\n    }\n  }\n\n  // PHONE VERIFICATION (Telnyx Number Lookup)\n\n  if (contact._best_phone && !contact.phone_status && config.skip_phone_verifier !== 'true') {\n    const phoneResult = await verifyPhone.call(this, contact._best_phone);\n    if (phoneResult) {\n      contact._phone_status = phoneResult.phone_status;\n      contact._phone_line_type = phoneResult.phone_line_type;\n      contact._phone_carrier = phoneResult.phone_carrier;\n      if (phoneResult._error) {\n        contact._phone_error = phoneResult._error;\n      } else {\n        console.log(`Phone verified ${contact._best_phone}: ${phoneResult.phone_status} (${phoneResult.phone_line_type || 'unknown type'}, ${phoneResult.phone_carrier || 'unknown carrier'})`);\n      }\n    }\n    await delay(100);\n  }\n\n  // COMPANY PHONE VERIFICATION (Telnyx)\n  if (contact._company_phone && !contact._company_phone_status && config.skip_phone_verifier !== 'true' && !companyEmailsSet[companyId + '_phone_verified']) {\n    const compPhoneResult = await verifyPhone.call(this, contact._company_phone);\n    if (compPhoneResult && !compPhoneResult._error) {\n      try {\n        await this.helpers.httpRequest({\n          method: 'PATCH',\n          url: `${$env.SUPABASE_URL}/rest/v1/companies?id=eq.${companyId}`,\n          headers: {\n            'apikey': $env.SUPABASE_SERVICE_KEY,\n            'Authorization': `Bearer ${$env.SUPABASE_SERVICE_KEY}`,\n            'Content-Type': 'application/json',\n            'Prefer': 'return=minimal'\n          },\n          body: {\n            phone_status: compPhoneResult.phone_status,\n            phone_line_type: compPhoneResult.phone_line_type\n          },\n          json: true\n        });\n        contact._company_phone_verified = true;\n        console.log(`Company phone verified ${contact._company_phone}: ${compPhoneResult.phone_status} (${compPhoneResult.phone_line_type || 'unknown'})`);\n      } catch(e) {\n        console.log(`Company phone PATCH error for ${companyId}: ${e.message}`);\n      }\n    } else if (compPhoneResult && compPhoneResult._error) {\n      contact._phone_error = contact._phone_error || compPhoneResult._error;\n    }\n    companyEmailsSet[companyId + '_phone_verified'] = true;\n    await delay(100);\n  }\n\n  // BUILD UPDATE PAYLOAD\n\n  const update = {};\n  if (contact._best_email && !contact.email_business) {\n    update.email_business = contact._best_email;\n  }\n  if (contact._email_status && contact._email_status !== 'unverified') {\n    update.email_status = contact._email_status;\n    update.email_verified_at = contact._email_verified_at;\n    if (contact._email_status === 'invalid') {\n      update.email_business = null;\n    }\n  } else if (contact._best_email || contact.email_business) {\n    update.email_status = 'unverified';\n  }\n\n  const newPhone = validatePhone(contact._best_phone);\n  if (newPhone && !contact.phone_direct) update.phone_direct = newPhone;\n  if (contact._best_linkedin && !contact.linkedin_url) update.linkedin_url = contact._best_linkedin;\n  if (contact._cultural_affinity && !contact.cultural_affinity) update.cultural_affinity = contact._cultural_affinity;\n\n  // Phone verification fields\n  if (contact._phone_status) {\n    update.phone_status = contact._phone_status;\n    update.phone_verified_at = new Date().toISOString();\n    update.phone_line_type = contact._phone_line_type;\n    update.phone_carrier = contact._phone_carrier;\n    if (contact._phone_status === 'invalid' || contact._phone_status === 'disconnected') {\n      update.phone_direct = null;  // Remove bad numbers, keep status for audit\n    }\n  }\n\n  contact._update_payload = Object.keys(update).length > 0 ? update : null;\n  contact._has_updates = Object.keys(update).length > 0;\n\n  // SUPABASE UPDATE (inline)\n\n  if (contact._has_updates) {\n    try {\n      await this.helpers.httpRequest({\n        method: 'PATCH',\n        url: `${$env.SUPABASE_URL}/rest/v1/contacts?id=eq.${contact.id}`,\n        headers: {\n          'apikey': $env.SUPABASE_SERVICE_KEY,\n          'Authorization': `Bearer ${$env.SUPABASE_SERVICE_KEY}`,\n          'Content-Type': 'application/json',\n          'Prefer': 'return=minimal'\n        },\n        body: update,\n        json: true\n      });\n      console.log(`Updated ${contact.first_name} ${contact.last_name || ''}: ${JSON.stringify(update)}`);\n    } catch(e) {\n      console.log(`Supabase update error for ${contact.id}: ${e.message}`);\n      contact._update_error = e.message;\n    }\n    await delay(50);\n  }\n\n  results.push({\n    json: {\n      _contact_id: contact.id,\n      _company_id: contact.company_id,\n      _first_name: contact.first_name,\n      _last_name: contact.last_name,\n      _company_name: contact._company_name,\n      _update_payload: contact._update_payload,\n      _has_updates: contact._has_updates,\n      _email_source: contact._email_source,\n      _email_status: contact._email_status,\n      _verifier_score: contact._verifier_score,\n      _namsor_country: contact._namsor_country,\n      _namsor_probability: contact._namsor_probability,\n      _company_email_routed: contact._company_email_routed,\n      _company_email_verified: contact._company_email_verified,\n      _routed_company_email: contact._routed_company_email || null,\n      _phone_status: contact._phone_status,\n      _phone_line_type: contact._phone_line_type,\n      _phone_carrier: contact._phone_carrier,\n      _company_phone_verified: contact._company_phone_verified,\n      _phone_error: contact._phone_error,\n      _update_error: contact._update_error || null\n    }\n  });\n}\n\nif (results.length === 0) {\n  return [{ json: { _empty: true, _count: 0 } }];\n}\n\nreturn results;"
      },
      "id": "aec203c3-be0e-40bb-9ada-7d85d644ab16",
      "name": "Enrich Contacts",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        8320,
        448
      ],
      "notes": "Replaces the entire Step 4 branching pipeline (31 nodes) with a single sequential loop.\nFor each contact: Hunter Email Finder \u2192 Snov.io fallback \u2192 Hunter Email Verifier \u2192 NamSor Origin \u2192 Supabase PATCH.\nAll API calls happen inline via $http.request(). No convergence = no batching bugs.\nConfig toggles (skip_hunter, skip_snovio, etc.) are checked inside the loop."
    },
    {
      "parameters": {
        "jsCode": "const config = $('Step 4 Config').first().json;\nconst items = $input.all();\n\nlet totalProcessed = 0;\nlet emailsFound = 0;\nlet emailsFromHunter = 0;\nlet emailsFromSnovio = 0;\nlet emailsExisting = 0;\nlet emailsPersonalPromoted = 0;\nlet phonesEnriched = 0;\nlet linkedinEnriched = 0;\nlet namsorProcessed = 0;\nlet namsorSuccess = 0;\nlet contactsUpdated = 0;\nlet contactsSkipped = 0;\n\nlet emailsVerified = 0;\nlet emailsInvalid = 0;\nlet emailsRisky = 0;\nlet emailsAcceptAll = 0;\nlet emailsUnverified = 0;\nlet verificationTotal = 0;\nlet updateErrors = 0;\n\n// Company email routing stats\nlet companyEmailsRouted = 0;\nlet companyEmailsVerified = 0;\n\n// Phone verification stats\nlet phonesVerifiedValid = 0;\nlet phonesInvalidRemoved = 0;\nlet phonesVoipFlagged = 0;\nlet phonesDisconnectedRemoved = 0;\nlet companyPhonesVerified = 0;\n\nfor (const item of items) {\n  const d = item.json;\n  if (d._empty) continue;\n  totalProcessed++;\n\n  if (d._has_updates) contactsUpdated++;\n  else contactsSkipped++;\n\n  if (d._email_source === 'hunter') emailsFromHunter++;\n  else if (d._email_source === 'snovio') emailsFromSnovio++;\n  else if (d._email_source === 'existing') emailsExisting++;\n  else if (d._email_source === 'personal_promoted') emailsPersonalPromoted++;\n\n  if (d._update_payload && d._update_payload.email_business) emailsFound++;\n  if (d._update_payload && d._update_payload.phone_direct) phonesEnriched++;\n  if (d._update_payload && d._update_payload.linkedin_url) linkedinEnriched++;\n  if (d._namsor_country) namsorProcessed++;\n  if (d._namsor_country && d._update_payload && d._update_payload.cultural_affinity) namsorSuccess++;\n\n  if (d._email_status) {\n    verificationTotal++;\n    switch (d._email_status) {\n      case 'verified': emailsVerified++; break;\n      case 'invalid': emailsInvalid++; break;\n      case 'risky': emailsRisky++; break;\n      case 'accept_all': emailsAcceptAll++; break;\n      case 'unverified': emailsUnverified++; break;\n    }\n  }\n\n  if (d._company_email_routed) companyEmailsRouted++;\n  if (d._company_email_verified) companyEmailsVerified++;\n  if (d._update_error) updateErrors++;\n\n  // Phone verification stats\n  if (d._phone_status) {\n    switch (d._phone_status) {\n      case 'valid': phonesVerifiedValid++; break;\n      case 'invalid': phonesInvalidRemoved++; break;\n      case 'voip': phonesVoipFlagged++; break;\n      case 'disconnected': phonesDisconnectedRemoved++; break;\n    }\n  }\n  if (d._company_phone_verified) companyPhonesVerified++;\n}\n\nconst summary = {\n  run_completed_at: new Date().toISOString(),\n  config: {\n    batch_size: config.batch_size,\n    hunter_finder_enabled: config.skip_hunter !== 'true',\n    hunter_verifier_enabled: config.skip_hunter_verifier !== 'true',\n    snovio_enabled: config.skip_snovio !== 'true',\n    namsor_enabled: config.skip_namsor !== 'true',\n    phone_verifier_enabled: config.skip_phone_verifier !== 'true'\n  },\n  contacts_processed: totalProcessed,\n  contacts_updated: contactsUpdated,\n  contacts_no_changes: contactsSkipped,\n  update_errors: updateErrors,\n  email_enrichment: {\n    new_emails_found: emailsFound,\n    from_hunter: emailsFromHunter,\n    from_snovio: emailsFromSnovio,\n    personal_promoted: emailsPersonalPromoted,\n    already_had_email: emailsExisting\n  },\n  email_verification: {\n    total_checked: verificationTotal,\n    verified: emailsVerified,\n    invalid_removed: emailsInvalid,\n    risky: emailsRisky,\n    accept_all: emailsAcceptAll,\n    not_verified: emailsUnverified\n  },\n  company_email_routing: {\n    role_based_routed_to_company: companyEmailsRouted,\n    company_emails_verified: companyEmailsVerified\n  },\n  phone_verification: {\n    verified_valid: phonesVerifiedValid,\n    invalid_removed: phonesInvalidRemoved,\n    voip_flagged: phonesVoipFlagged,\n    disconnected_removed: phonesDisconnectedRemoved,\n    company_phones_verified: companyPhonesVerified\n  },\n  phone_enrichment: { phones_added: phonesEnriched },\n  linkedin_enrichment: { linkedin_added: linkedinEnriched },\n  namsor_enrichment: { names_sent: namsorProcessed, cultural_affinity_set: namsorSuccess },\n  message: `Processed ${totalProcessed} contacts. Updated ${contactsUpdated} (${emailsFound} emails, ${phonesEnriched} phones, ${linkedinEnriched} LinkedIn, ${namsorSuccess} cultural affinity). Email verification: ${emailsVerified} valid, ${emailsInvalid} invalid, ${emailsRisky} risky, ${emailsAcceptAll} accept_all. Phone verification: ${phonesVerifiedValid} valid, ${phonesInvalidRemoved} invalid removed, ${phonesVoipFlagged} voip, ${phonesDisconnectedRemoved} disconnected removed, ${companyPhonesVerified} company phones. Company emails: ${companyEmailsRouted} routed, ${companyEmailsVerified} verified. ${contactsSkipped} no changes. ${updateErrors} errors.`\n};\n\nconsole.log('=== STEP 4: ENRICH PEOPLE SUMMARY ===');\nconsole.log(JSON.stringify(summary, null, 2));\n\nreturn [{ json: summary }];"
      },
      "id": "fca629db-4e74-42e6-9fc0-e652ba284137",
      "name": "Run Summary4",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        8768,
        448
      ],
      "notes": "Final summary: contacts enriched, emails found (Hunter/Snov.io), verification stats, NamSor stats, update counts."
    },
    {
      "parameters": {
        "path": "001b878c-b5af-4c3c-8b78-d41e526049f4",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2.1,
      "position": [
        -11184,
        304
      ],
      "id": "1425be88-641d-4abd-a094-acab6b05acd7",
      "name": "Webhook",
      "webhookId": "001b878c-b5af-4c3c-8b78-d41e526049f4"
    },
    {
      "id": "a1b2c3d4-lead-score-http-0001",
      "name": "Calculate Lead Scores",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        9216,
        352
      ],
      "parameters": {
        "method": "POST",
        "url": "={{ $env.SUPABASE_URL }}/rest/v1/rpc/calculate_lead_scores",
        "authentication": "none",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "apikey",
              "value": "={{ $env.SUPABASE_SERVICE_KEY }}"
            },
            {
              "name": "Authorization",
              "value": "=Bearer {{ $env.SUPABASE_SERVICE_KEY }}"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "{}",
        "options": {
          "response": {
            "response": {
              "neverError": true
            }
          }
        }
      },
      "notes": "Step 5: Call Supabase RPC to recalculate all lead scores based on scoring_rules table."
    },
    {
      "id": "a1b2c3d4-lead-score-summary-02",
      "name": "Run Summary5",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        9440,
        352
      ],
      "parameters": {
        "jsCode": "// Step 5: Lead Scoring Summary\nconst input = $input.first().json;\n\n// Check if the RPC call succeeded\n// Supabase RPC for void functions returns empty string or null on success\nconst rpcFailed = input.error || input.message || (typeof input === 'object' && input.code);\n\nconst summary = {\n  run_completed_at: new Date().toISOString(),\n  step: 'Step 5: Lead Scoring',\n  scoring_status: rpcFailed ? 'FAILED' : 'SUCCESS',\n  rpc_response: rpcFailed ? JSON.stringify(input) : 'calculate_lead_scores() executed successfully',\n  message: rpcFailed\n    ? `Lead scoring FAILED: ${JSON.stringify(input)}. Scores not updated \u2014 pipeline still completed.`\n    : 'Lead scoring complete. All company lead_score values recalculated from scoring_rules table.'\n};\n\nconsole.log('=== STEP 5: LEAD SCORING SUMMARY ===');\nconsole.log(JSON.stringify(summary, null, 2));\n\nreturn [{ json: summary }];"
      },
      "notes": "Logs whether the lead scoring RPC call succeeded or failed."
    },
    {
      "id": "66759275-0ca5-4b3c-ab6d-b3e52db64922",
      "name": "Metro Config",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -10960,
        192
      ],
      "parameters": {
        "jsCode": "// Clear convergence-suppression flags from previous execution\nconst staticData = $getWorkflowStaticData('global');\ndelete staticData._collapse1_fired;\ndelete staticData._collapse2_fired;\ndelete staticData._enriched_contact_ids;\n\n// Dynamic Metro Config \u2014 reads metro_name from webhook query parameter\nconst METROS = {\n  'Austin, TX':     { latitude: '30.2672',  longitude: '-97.7431',  yelp_location: 'Austin, TX', radius_meters: '15000' },\n  'Denver, CO':     { latitude: '39.7392',  longitude: '-104.9903', yelp_location: 'Denver, CO', radius_meters: '15000' },\n  'Phoenix, AZ':    { latitude: '33.4484',  longitude: '-112.0740', yelp_location: 'Phoenix, AZ', radius_meters: '15000' },\n  'Toronto, ON':    { latitude: '43.6532',  longitude: '-79.3832',  yelp_location: 'Toronto, ON', radius_meters: '15000' },\n  'San Diego, CA':  { latitude: '32.7157',  longitude: '-117.1611', yelp_location: 'San Diego, CA', radius_meters: '15000' },\n  'Boise, ID':      { latitude: '43.6150',  longitude: '-116.2023', yelp_location: 'Boise, ID', radius_meters: '25000' },\n  'Portland, OR':   { latitude: '45.5152',  longitude: '-122.6784', yelp_location: 'Portland, OR', radius_meters: '15000' },\n};\n\nconst webhookData = $('Webhook').first().json;\nconst metroName = (webhookData.query && webhookData.query.metro_name) || '';\n\nif (!metroName) {\n  throw new Error('Missing required query parameter: metro_name. Use ?metro_name=City, ST');\n}\n\nconst metro = METROS[metroName];\nif (!metro) {\n  const available = Object.keys(METROS).join(', ');\n  throw new Error(`Unknown metro: \"${metroName}\". Available: ${available}`);\n}\n\nreturn [{\n  json: {\n    metro_name: metroName,\n    latitude: metro.latitude,\n    longitude: metro.longitude,\n    radius_meters: metro.radius_meters,\n    search_queries: 'massage therapy,massage clinic,massage therapist,spa massage,therapeutic massage,deep tissue massage,sports massage,bodywork,day spa,wellness spa,relaxation massage,licensed massage therapist',\n    yelp_location: metro.yelp_location\n  }\n}];"
      },
      "notes": "Dynamic metro lookup \u2014 reads metro_name from webhook ?metro_name=City, ST query parameter. Add new metros to the METROS object."
    },
    {
      "id": "a1b2c3d4-collapse-summary1-01",
      "name": "Collapse to Single1",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -104,
        432
      ],
      "parameters": {
        "jsCode": "// Collapse 7 convergence paths into single item to prevent Task Runner crash loop\n// ADR-024: Suppress redundant convergence batches \u2014 only fire once per execution\nconst staticData = $getWorkflowStaticData('global');\nif (staticData._collapse1_fired) {\n  return [];\n}\nstaticData._collapse1_fired = true;\n\n// ADR-026: Stabilization polling \u2014 wait for Step 2 to finish enriching ALL companies\n// before triggering Step 3a. Without this, Step 3a fires after the first company\n// exits Step 2, missing ~95% of companies for new cities.\nconst metro = $('Metro Config').first().json.metro_name;\nconst headers = {\n  'apikey': $env.SUPABASE_SERVICE_KEY,\n  'Authorization': 'Bearer ' + $env.SUPABASE_SERVICE_KEY\n};\n\nlet prevCount = -1;\nlet stableRounds = 0;\n\nfor (let i = 0; i < 80; i++) {\n  await new Promise(r => setTimeout(r, 15000));\n\n  const rows = await this.helpers.httpRequest({\n    method: 'GET',\n    url: $env.SUPABASE_URL + '/rest/v1/companies?enrichment_status=eq.discovered&discovery_metro=eq.' + encodeURIComponent(metro) + '&select=id',\n    headers,\n    json: true\n  });\n  const count = Array.isArray(rows) ? rows.length : 0;\n\n  // Wait for discovered count to reach 0 (all companies processed by Step 2)\n  if (count === prevCount && count === 0) {\n    stableRounds++;\n    if (stableRounds >= 2) break;\n  } else {\n    stableRounds = 0;\n  }\n  prevCount = count;\n}\n\nreturn [{ json: { _trigger: 'social_processing_complete', _remaining_discovered: prevCount } }];"
      }
    },
    {
      "id": "a1b2c3d4-collapse-summary2-01",
      "name": "Collapse to Single2",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -7712,
        192
      ],
      "parameters": {
        "jsCode": "// Collapse 2 convergence paths (Insert + Insert Flagged) into single item\n// ADR-024: Fire once per execution (suppress secondary batches)\n// ADR-025: Wait for all Step 1 inserts to complete before triggering Step 2\n// Google results arrive in ~5s, Yelp/Apify takes 60-120s.\n// Poll discovered count until stable, then fire.\n// BUG-028: Require count > 0 to prevent race condition where Insert to Supabase\n// hasn't committed yet. Max iterations raised from 10 to 30 (450s max).\nconst staticData = $getWorkflowStaticData('global');\nif (staticData._collapse2_fired) {\n  return [];\n}\nstaticData._collapse2_fired = true;\n\nconst metro = $('Metro Config').first().json.metro_name;\nconst headers = {\n  'apikey': $env.SUPABASE_SERVICE_KEY,\n  'Authorization': 'Bearer ' + $env.SUPABASE_SERVICE_KEY\n};\n\nlet prevCount = -1;\nlet stableRounds = 0;\n\nfor (let i = 0; i < 30; i++) {\n  // Wait 15 seconds between checks\n  await new Promise(r => setTimeout(r, 15000));\n\n  // Count discovered companies for this metro\n  const rows = await this.helpers.httpRequest({\n    method: 'GET',\n    url: $env.SUPABASE_URL + '/rest/v1/companies?enrichment_status=eq.discovered&discovery_metro=eq.' + encodeURIComponent(metro) + '&select=id',\n    headers,\n    json: true\n  });\n  const count = Array.isArray(rows) ? rows.length : 0;\n\n  if (count === prevCount && count > 0) {\n    stableRounds++;\n    if (stableRounds >= 2) break; // Stable for 30s \u2014 all inserts done\n  } else {\n    stableRounds = 0;\n  }\n  prevCount = count;\n}\n\nreturn [{ json: { _trigger: 'step1_insert_complete', _discovered_count: prevCount } }];"
      }
    },
    {
      "id": "a1b2c3d4-collapse-summary3-01",
      "name": "Collapse to Single3",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        6384,
        432
      ],
      "parameters": {
        "jsCode": "// Collapse 3+ convergence paths (Insert Contact + About no-name + No Domain no-name) into single item\n// Prevents 5-7x batch multiplication on Step 4 pre-collapse path\n// Run Summary3 uses $('NodeName').all() references which resolve globally by name\nreturn [{ json: { _trigger: 'step3a_contacts_complete' } }];"
      }
    }
  ],
  "connections": {
    "Split Search Queries": {
      "main": [
        [
          {
            "node": "Google Places - Text Search",
            "type": "main",
            "index": 0
          },
          {
            "node": "Start Apify Run",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Google Places - Text Search": {
      "main": [
        [
          {
            "node": "Normalize Google Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Normalize Google Results": {
      "main": [
        [
          {
            "node": "Merge All Sources",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge All Sources": {
      "main": [
        [
          {
            "node": "Deduplicate Records",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Deduplicate Records": {
      "main": [
        [
          {
            "node": "Prepare for Supabase",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare for Supabase": {
      "main": [
        [
          {
            "node": "Fuzzy Match?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fuzzy Match?": {
      "main": [
        [
          {
            "node": "Insert Flagged (Needs Review)",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Insert to Supabase",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Run ID": {
      "main": [
        [
          {
            "node": "Wait 30s",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Wait 30s": {
      "main": [
        [
          {
            "node": "Check Run Status",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Run Status": {
      "main": [
        [
          {
            "node": "Parse Status",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Status": {
      "main": [
        [
          {
            "node": "Run Succeeded?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Run Succeeded?": {
      "main": [
        [
          {
            "node": "Fetch Apify Results",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Wait 30s",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Start Apify Run": {
      "main": [
        [
          {
            "node": "Extract Run ID",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Normalize Yelp Results": {
      "main": [
        [
          {
            "node": "Merge All Sources",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Fetch Apify Results": {
      "main": [
        [
          {
            "node": "Normalize Yelp Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Run Summary": {
      "main": [
        [
          {
            "node": "Enrichment Config",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Enrichment Config": {
      "main": [
        [
          {
            "node": "Fetch Batch from Supabase",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Batch from Supabase": {
      "main": [
        [
          {
            "node": "Parse Batch",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Batch": {
      "main": [
        [
          {
            "node": "Batch Empty?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Batch Empty?": {
      "main": [
        [
          {
            "node": "No Records - Done",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Needs Backfill?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Has Website?": {
      "main": [
        [
          {
            "node": "Fetch Website HTML",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Skip - No Website",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Website HTML": {
      "main": [
        [
          {
            "node": "Analyze Website HTML",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Analyze Website HTML": {
      "main": [
        [
          {
            "node": "Merge Website Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Skip - No Website": {
      "main": [
        [
          {
            "node": "Merge Website Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Website Results": {
      "main": [
        [
          {
            "node": "Has Google Place ID?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Has Google Place ID?": {
      "main": [
        [
          {
            "node": "Google Places Details",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Skip Google Details",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Google Places Details": {
      "main": [
        [
          {
            "node": "Parse Google Details",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Google Details": {
      "main": [
        [
          {
            "node": "Prepare Company Update",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Skip Google Details": {
      "main": [
        [
          {
            "node": "Prepare Company Update",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Company Update": {
      "main": [
        [
          {
            "node": "Update Company in Supabase",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Company in Supabase": {
      "main": [
        [
          {
            "node": "Prepare Social Processing",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Social Processing": {
      "main": [
        [
          {
            "node": "Has Social Links?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Has Social Links?": {
      "main": [
        [
          {
            "node": "Prepare Social Profiles Insert",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Needs Social Discovery?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Social Profiles Insert": {
      "main": [
        [
          {
            "node": "Insert Social Profiles",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Needs Social Discovery?": {
      "main": [
        [
          {
            "node": "Build Social Discovery Batch",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Collapse to Single1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Social Discovery Batch": {
      "main": [
        [
          {
            "node": "Discovery Queries Exist?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Discovery Queries Exist?": {
      "main": [
        [
          {
            "node": "Prepare FB Search Input",
            "type": "main",
            "index": 0
          },
          {
            "node": "Prepare IG Search Input",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Collapse to Single1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare FB Search Input": {
      "main": [
        [
          {
            "node": "Start FB Search Run",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Start FB Search Run": {
      "main": [
        [
          {
            "node": "Extract FB Run ID",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract FB Run ID": {
      "main": [
        [
          {
            "node": "Wait FB 30s",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Wait FB 30s": {
      "main": [
        [
          {
            "node": "Check FB Run Status",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check FB Run Status": {
      "main": [
        [
          {
            "node": "Parse FB Status",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse FB Status": {
      "main": [
        [
          {
            "node": "FB Run Succeeded?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "FB Run Succeeded?": {
      "main": [
        [
          {
            "node": "Fetch FB Search Results",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Wait FB 30s",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch FB Search Results": {
      "main": [
        [
          {
            "node": "Match FB Results to Companies",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Match FB Results to Companies": {
      "main": [
        [
          {
            "node": "FB Matches Found?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "FB Matches Found?": {
      "main": [
        [
          {
            "node": "Insert FB Social Profiles",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Collapse to Single1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare IG Search Input": {
      "main": [
        [
          {
            "node": "Start IG Search Run",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Start IG Search Run": {
      "main": [
        [
          {
            "node": "Extract IG Run ID",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract IG Run ID": {
      "main": [
        [
          {
            "node": "Wait IG 30s",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Wait IG 30s": {
      "main": [
        [
          {
            "node": "Check IG Run Status",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check IG Run Status": {
      "main": [
        [
          {
            "node": "Parse IG Status",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse IG Status": {
      "main": [
        [
          {
            "node": "IG Run Succeeded?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IG Run Succeeded?": {
      "main": [
        [
          {
            "node": "Fetch IG Search Results",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Wait IG 30s",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch IG Search Results": {
      "main": [
        [
          {
            "node": "Match IG Results to Companies",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Match IG Results to Companies": {
      "main": [
        [
          {
            "node": "IG Matches Found?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IG Matches Found?": {
      "main": [
        [
          {
            "node": "Insert IG Social Profiles",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Collapse to Single1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Step 3b Config": {
      "main": [
        [
          {
            "node": "Fetch Unenriched Social Profiles",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Unenriched Social Profiles": {
      "main": [
        [
          {
            "node": "Parse Batch1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build SociaVault Request": {
      "main": [
        [
          {
            "node": "Should Enrich?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Should Enrich?": {
      "main": [
        [
          {
            "node": "Call SociaVault API",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Run Summary2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Call SociaVault API": {
      "main": [
        [
          {
            "node": "Parse SociaVault Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse SociaVault Response": {
      "main": [
        [
          {
            "node": "Update Social Profile in Supabase",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Social Profile in Supabase": {
      "main": [
        [
          {
            "node": "Run Summary2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Batch1": {
      "main": [
        [
          {
            "node": "Batch Empty?1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Batch Empty?1": {
      "main": [
        [
          {
            "node": "No Records - Done1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Build SociaVault Request",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Run Summary1": {
      "main": [
        [
          {
            "node": "Bridge to 3b",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Needs Backfill?": {
      "main": [
        [
          {
            "node": "Google Places Lookup",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Merge Backfill",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Google Places Lookup": {
      "main": [
        [
          {
            "node": "Extract & Patch Domain",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract & Patch Domain": {
      "main": [
        [
          {
            "node": "Merge Backfill",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Backfill": {
      "main": [
        [
          {
            "node": "Has Website?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Step 3a Config": {
      "main": [
        [
          {
            "node": "Fetch Companies",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Companies": {
      "main": [
        [
          {
            "node": "Fetch Existing Contacts",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Existing Contacts": {
      "main": [
        [
          {
            "node": "Filter & Parse Batch",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Filter & Parse Batch": {
      "main": [
        [
          {
            "node": "Batch Empty?2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Solo Practitioner Check": {
      "main": [
        [
          {
            "node": "Is Solo?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Is Solo?": {
      "main": [
        [
          {
            "node": "Prepare Solo Contact",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Has Domain & Apollo?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Solo Contact": {
      "main": [
        [
          {
            "node": "Validate & Clean Contact",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Has Domain & Apollo?": {
      "main": [
        [
          {
            "node": "Apollo People Search",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "No Domain Fallback",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Apollo People Search": {
      "main": [
        [
          {
            "node": "Parse Apollo Search",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Apollo Search": {
      "main": [
        [
          {
            "node": "Apollo Found People?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Apollo Found People?": {
      "main": [
        [
          {
            "node": "Enrich Enabled?",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Fetch About Page",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Enrich Enabled?": {
      "main": [
        [
          {
            "node": "Apollo People Enrich",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Apollo Search Only Contact",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Apollo People Enrich": {
      "main": [
        [
          {
            "node": "Parse Apollo Enrich",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Apollo Enrich": {
      "main": [
        [
          {
            "node": "Validate & Clean Contact1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Apollo Search Only Contact": {
      "main": [
        [
          {
            "node": "Validate & Clean Contact3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch About Page": {
      "main": [
        [
          {
            "node": "Parse About Page",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse About Page": {
      "main": [
        [
          {
            "node": "About Found Name?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "About Found Name?": {
      "main": [
        [
          {
            "node": "Validate & Clean Contact4",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Collapse to Single3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "No Domain Fallback": {
      "main": [
        [
          {
            "node": "No Domain Found Name?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "No Domain Found Name?": {
      "main": [
        [
          {
            "node": "Validate & Clean Contact2",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Collapse to Single3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Batch Empty?2": {
      "main": [
        [
          {
            "node": "No Records - Done2",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Solo Practitioner Check",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Run Summary2": {
      "main": [
        [
          {
            "node": "Bridge to 3a",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Bridge to 3b": {
      "main": [
        [
          {
            "node": "Step 3b Config",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Bridge to 3a": {
      "main": [
        [
          {
            "node": "Step 3a Config",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate & Clean Contact": {
      "main": [
        [
          {
            "node": "Insert Contact to Supabase",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate & Clean Contact1": {
      "main": [
        [
          {
            "node": "Insert Contact to Supabase",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate & Clean Contact3": {
      "main": [
        [
          {
            "node": "Insert Contact to Supabase",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate & Clean Contact4": {
      "main": [
        [
          {
            "node": "Insert Contact to Supabase",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate & Clean Contact2": {
      "main": [
        [
          {
            "node": "Insert Contact to Supabase",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Run Summary3": {
      "main": [
        [
          {
            "node": "Bridge to 4",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Step 4 Config": {
      "main": [
        [
          {
            "node": "Fetch Contacts",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Contacts": {
      "main": [
        [
          {
            "node": "Collapse to Single",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Filter & Merge Contacts": {
      "main": [
        [
          {
            "node": "Batch Empty?3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Companies1": {
      "main": [
        [
          {
            "node": "Filter & Merge Contacts",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Batch Empty?3": {
      "main": [
        [
          {
            "node": "No Records - Done3",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Enrich Contacts",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Bridge to 4": {
      "main": [
        [
          {
            "node": "Step 4 Config",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Collapse to Single": {
      "main": [
        [
          {
            "node": "Fetch Companies1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Enrich Contacts": {
      "main": [
        [
          {
            "node": "Run Summary4",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Run Summary4": {
      "main": [
        [
          {
            "node": "Calculate Lead Scores",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "No Records - Done3": {
      "main": [
        [
          {
            "node": "Calculate Lead Scores",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Calculate Lead Scores": {
      "main": [
        [
          {
            "node": "Run Summary5",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "No Records - Done": {
      "main": [
        [
          {
            "node": "Bridge to 3b",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "No Records - Done1": {
      "main": [
        [
          {
            "node": "Bridge to 3a",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "No Records - Done2": {
      "main": [
        [
          {
            "node": "Bridge to 4",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Webhook": {
      "main": [
        [
          {
            "node": "Metro Config",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Metro Config": {
      "main": [
        [
          {
            "node": "Split Search Queries",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Insert Social Profiles": {
      "main": [
        [
          {
            "node": "Collapse to Single1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Insert FB Social Profiles": {
      "main": [
        [
          {
            "node": "Collapse to Single1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Insert IG Social Profiles": {
      "main": [
        [
          {
            "node": "Collapse to Single1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Collapse to Single1": {
      "main": [
        [
          {
            "node": "Run Summary1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Insert to Supabase": {
      "main": [
        [
          {
            "node": "Collapse to Single2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Insert Flagged (Needs Review)": {
      "main": [
        [
          {
            "node": "Collapse to Single2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Collapse to Single2": {
      "main": [
        [
          {
            "node": "Run Summary",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Insert Contact to Supabase": {
      "main": [
        [
          {
            "node": "Collapse to Single3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Collapse to Single3": {
      "main": [
        [
          {
            "node": "Run Summary3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "availableInMCP": false,
    "timeSavedMode": "fixed",
    "callerPolicy": "workflowsFromSameOwner",
    "saveExecutionProgress": true
  },
  "staticData": {
    "global": {
      "_enrichedContactIds": [
        "e12e1c8c-229f-4a31-942a-640d39307742",
        "9d55aa62-f0d1-4dfe-b72d-94f0c3c94403",
        "9529e172-53a9-47ad-9a63-cfd6a8d36ce5",
        "6d28afc3-b027-4a16-87fd-96793bdb458f",
        "f6b4b240-f7bb-4a59-9ea2-7ac994b470c1",
        "14140444-30cc-4381-abac-feb23b5094b6",
        "a8025314-784c-42be-9041-bcd741263327",
        "4a2679b1-60e9-474b-af07-e213173fab8f",
        "4801c886-956c-4bba-b730-b378a6f51d6d",
        "4d1f71d9-1dec-4d78-8a32-cbed015fcdec"
      ],
      "_companyEmailsSet": {}
    }
  },
  "meta": null,
  "pinData": {},
  "versionId": "a7f4ec81-3742-4681-af9d-9f01382828f4",
  "activeVersionId": "a7f4ec81-3742-4681-af9d-9f01382828f4",
  "versionCounter": 290,
  "triggerCount": 1,
  "shared": [
    {
      "updatedAt": "2026-02-18T03:19:26.158Z",
      "createdAt": "2026-02-18T03:19:26.158Z",
      "role": "workflow:owner",
      "workflowId": "yxvQst30sWlNIeZq",
      "projectId": "333cvByoNUNJEvRJ",
      "project": {
        "updatedAt": "2026-02-14T18:27:04.985Z",
        "createdAt": "2026-02-14T18:04:34.656Z",
        "id": "333cvByoNUNJEvRJ",
        "name": "Phillip Schuman <2fa@spamarketing.com>",
        "type": "personal",
        "icon": null,
        "description": null,
        "creatorId": "a0f6ea10-aac2-4dd7-a7bc-df1184531a06",
        "projectRelations": [
          {
            "updatedAt": "2026-02-14T18:04:34.656Z",
            "createdAt": "2026-02-14T18:04:34.656Z",
            "userId": "a0f6ea10-aac2-4dd7-a7bc-df1184531a06",
            "projectId": "333cvByoNUNJEvRJ",
            "user": {
              "updatedAt": "2026-02-20T00:55:28.285Z",
              "createdAt": "2026-02-14T18:04:33.805Z",
              "id": "a0f6ea10-aac2-4dd7-a7bc-df1184531a06",
              "email": "2fa@spamarketing.com",
              "firstName": "Phillip",
              "lastName": "Schuman",
              "personalizationAnswers": {
                "version": "v4",
                "personalization_survey_submitted_at": "2026-02-14T18:27:56.226Z",
                "personalization_survey_n8n_version": "2.1.5",
                "companyIndustryExtended": [
                  "other"
                ],
                "otherCompanyIndustryExtended": "Agency - Massage Clinics",
                "companySize": "<20",
                "companyType": "other",
                "role": "business-owner",
                "reportedSource": "friend"
              },
              "settings": {
                "userActivated": true,
                "firstSuccessfulWorkflowId": "yxvQst30sWlNIeZq",
                "userActivatedAt": 1771388100462
              },
              "disabled": false,
              "mfaEnabled": false,
              "lastActiveAt": "2026-02-20",
              "isPending": false
            }
          }
        ]
      }
    }
  ],
  "tags": [],
  "activeVersion": {
    "updatedAt": "2026-02-20T06:02:50.865Z",
    "createdAt": "2026-02-20T06:02:50.865Z",
    "versionId": "a7f4ec81-3742-4681-af9d-9f01382828f4",
    "workflowId": "yxvQst30sWlNIeZq",
    "nodes": [
      {
        "parameters": {
          "jsCode": "const config = $input.first().json;\nconst queries = config.search_queries.split(',').map(q => q.trim());\nreturn queries.map(query => ({\n  json: {\n    query,\n    latitude: config.latitude,\n    longitude: config.longitude,\n    radius_meters: config.radius_meters,\n    metro_name: config.metro_name,\n    yelp_location: config.yelp_location\n  }\n}));"
        },
        "id": "3bbcf320-b713-415a-aca4-1f8fd1e54409",
        "name": "Split Search Queries",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          -10736,
          192
        ]
      },
      {
        "parameters": {
          "method": "POST",
          "url": "https://places.googleapis.com/v1/places:searchText",
          "sendHeaders": true,
          "headerParameters": {
            "parameters": [
              {
                "name": "X-Goog-FieldMask",
                "value": "places.id,places.displayName,places.formattedAddress,places.nationalPhoneNumber,places.internationalPhoneNumber,places.websiteUri,places.googleMapsUri,places.rating,places.userRatingCount,places.primaryType,places.primaryTypeDisplayName,places.addressComponents,nextPageToken"
              },
              {
                "name": "X-Goog-Api-Key",
                "value": "={{ $env.GOOGLE_PLACES_API_KEY }}"
              }
            ]
          },
          "sendBody": true,
          "specifyBody": "json",
          "jsonBody": "={\n  \"textQuery\": \"{{ $json.query }}\",\n  \"locationBias\": {\n    \"circle\": {\n      \"center\": {\n        \"latitude\": {{ $json.latitude }},\n        \"longitude\": {{ $json.longitude }}\n      },\n      \"radius\": {{ $json.radius_meters }}\n    }\n  },\n  \"maxResultCount\": 20\n}",
          "options": {}
        },
        "id": "ecf3e8c2-15ac-4259-8944-94009fae0e13",
        "name": "Google Places - Text Search",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.2,
        "position": [
          -9168,
          48
        ],
        "notes": "Google Places API (v1). Needs HTTP Header Auth credential: name='X-Goog-Api-Key', value=your API key."
      },
      {
        "parameters": {
          "jsCode": "const allInputs = JSON.parse(JSON.stringify($input.all().map(i => i.json)));\nconst allPlaces = [];\n\nfor (const input of allInputs) {\n  const places = input.places || [];\n  const q = input.query || '';\n  places.forEach(p => { p._query = q; });\n  allPlaces.push(...places);\n}\n\nconst metro = JSON.parse(JSON.stringify($('Metro Config').first().json)).metro_name;\n\n// Booking platform domain blocklist\nconst BLOCKED_DOMAINS = ['wixsite.com','wix.com','setmore.com','schedulista.com','glossgenius.com','square.site','genbook.com','jane.app','acuityscheduling.com','mindbodyonline.com','mindbody.io','vagaro.com','fresha.com','schedulicity.com','booksy.com','massagebook.com','noterro.com','clinicsense.com','calendly.com','squarespace.com'];\n// Business type blocklist - filter non-target businesses before Supabase insert\nconst BUSINESS_TYPE_BLOCKLIST = ['school','college','university','association','federation','union','board of','institute','academy','program'];\n\n\nreturn allPlaces.map(place => {\n  // Business type filter - skip non-target businesses\n  const _bizName = (place.displayName && place.displayName.text) || '';\n  const _bizCategory = (place.primaryTypeDisplayName && place.primaryTypeDisplayName.text) || place.primaryType || '';\n  const _bizNameLower = _bizName.toLowerCase();\n  const _bizCatLower = _bizCategory.toLowerCase();\n  if (BUSINESS_TYPE_BLOCKLIST.some(kw => _bizNameLower.includes(kw) || _bizCatLower.includes(kw))) return null;\n\n  let city = '', state = '', country = '';\n  if (place.addressComponents) {\n    for (const comp of place.addressComponents) {\n      if (comp.types && comp.types.includes('locality')) city = comp.longText || '';\n      if (comp.types && comp.types.includes('administrative_area_level_1')) state = comp.shortText || '';\n      if (comp.types && comp.types.includes('country')) country = comp.shortText || '';\n    }\n  }\n\n  let phone = place.internationalPhoneNumber || place.nationalPhoneNumber || '';\n  let phoneNormalized = phone.replace(/[^\\d+]/g, '');\n  if (phoneNormalized && !phoneNormalized.startsWith('+')) {\n    phoneNormalized = '+1' + phoneNormalized.replace(/^1/, '');\n  }\n\n  const website = place.websiteUri || '';\n  let domain = '';\n  if (website) {\n    const match = website.match(/^https?:\\/\\/(?:www\\.)?([^\\/]+)/i);\n    if (match) domain = match[1];\n  }\n\n  // Check domain against blocklist\n  let _domain_blocked = false;\n  let _domain_blocked_platform = '';\n  if (domain) {\n    const lowerDomain = domain.toLowerCase();\n    for (const blocked of BLOCKED_DOMAINS) {\n      if (lowerDomain === blocked || lowerDomain.endsWith('.' + blocked)) {\n        _domain_blocked = true;\n        _domain_blocked_platform = blocked;\n        domain = '';\n        break;\n      }\n    }\n  }\n\n  return {\n    json: {\n      name: (place.displayName && place.displayName.text) || '',\n      phone: phoneNormalized,\n      domain: domain,\n      address: place.formattedAddress || '',\n      city, state, country: country || 'US',\n      google_place_id: place.id || '',\n      category: (place.primaryTypeDisplayName && place.primaryTypeDisplayName.text) || place.primaryType || '',\n      google_rating: place.rating || null,\n      google_review_count: place.userRatingCount || 0,\n      has_website: _domain_blocked ? false : !!website,\n      google_maps_url: place.googleMapsUri || '',\n      source_urls: [{source: 'google_places', url: place.googleMapsUri || '', query_used: place._query || ''}],\n      discovery_metro: metro,\n      discovery_source: 'google_places',\n      _domain_blocked,\n      _domain_blocked_platform\n    }\n  };\n}).filter(Boolean);"
        },
        "id": "a9c14e44-5d37-4994-8a7a-b9283a47f5fe",
        "name": "Normalize Google Results",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          -8944,
          48
        ]
      },
      {
        "parameters": {},
        "id": "8fcec5c5-45b7-4b87-b2cb-a32c6d692aab",
        "name": "Merge All Sources",
        "type": "n8n-nodes-base.merge",
        "typeVersion": 3,
        "position": [
          -8720,
          192
        ]
      },
      {
        "parameters": {
          "jsCode": "const items = $input.all().map(i => i.json);\nconst canonical = [];\nconst phoneIndex = {};\nconst domainIndex = {};\n\nfunction normalizePhone(p) { return (p || '').replace(/[^\\d+]/g, ''); }\nfunction normalizeDomain(d) { return (d || '').toLowerCase().replace(/^www\\./, '').trim(); }\nfunction normalizeName(n) { return (n || '').toLowerCase().replace(/[^a-z0-9\\s]/g, '').trim(); }\nfunction nameSimilarity(a, b) {\n  const setA = new Set(normalizeName(a).split(/\\s+/));\n  const setB = new Set(normalizeName(b).split(/\\s+/));\n  const intersection = new Set([...setA].filter(x => setB.has(x)));\n  const union = new Set([...setA, ...setB]);\n  return union.size === 0 ? 0 : intersection.size / union.size;\n}\n\nfor (const item of items) {\n  const phone = normalizePhone(item.phone);\n  const domain = normalizeDomain(item.domain);\n  const city = (item.city || '').toLowerCase();\n  let matched = false;\n\n  if (phone && phone.length >= 10 && phoneIndex[phone] !== undefined) {\n    const existing = canonical[phoneIndex[phone]];\n    existing.source_urls = [...(existing.source_urls || []), ...(item.source_urls || [])];\n    if (!existing.domain && item.domain) existing.domain = item.domain;\n    if (!existing.google_place_id && item.google_place_id) existing.google_place_id = item.google_place_id;\n    if (!existing.has_website && item.has_website) existing.has_website = item.has_website;\n    if (item.google_rating) existing.google_rating = item.google_rating;\n    if (item.google_review_count) existing.google_review_count = item.google_review_count;\n    if (item.yelp_rating) existing.yelp_rating = item.yelp_rating;\n    if (item.yelp_review_count) existing.yelp_review_count = item.yelp_review_count;\n    if (item.yelp_url) existing.yelp_url = item.yelp_url;\n    matched = true;\n  }\n\n  if (!matched && domain && domainIndex[domain] !== undefined) {\n    const existing = canonical[domainIndex[domain]];\n    existing.source_urls = [...(existing.source_urls || []), ...(item.source_urls || [])];\n    if (!existing.phone && item.phone) existing.phone = item.phone;\n    if (!existing.google_place_id && item.google_place_id) existing.google_place_id = item.google_place_id;\n    if (item.google_rating) existing.google_rating = item.google_rating;\n    if (item.google_review_count) existing.google_review_count = item.google_review_count;\n    if (item.yelp_rating) existing.yelp_rating = item.yelp_rating;\n    if (item.yelp_review_count) existing.yelp_review_count = item.yelp_review_count;\n    if (item.yelp_url) existing.yelp_url = item.yelp_url;\n    matched = true;\n  }\n\n  if (!matched) {\n    let fuzzyMatch = false;\n    for (let i = 0; i < canonical.length; i++) {\n      const existing = canonical[i];\n      if ((existing.city || '').toLowerCase() === city && city !== '') {\n        if (nameSimilarity(existing.name, item.name) >= 0.85) {\n          existing.source_urls = [...(existing.source_urls || []), ...(item.source_urls || [])];\n          existing._fuzzy_match_flag = true;\n          existing._fuzzy_match_names = [...(existing._fuzzy_match_names || [existing.name]), item.name];\n          fuzzyMatch = true;\n          break;\n        }\n      }\n    }\n    if (!fuzzyMatch) {\n      const idx = canonical.length;\n      canonical.push({...item});\n      if (phone && phone.length >= 10) phoneIndex[phone] = idx;\n      if (domain) domainIndex[domain] = idx;\n    }\n  }\n}\n\nconsole.log('Dedup:', items.length, 'raw ->', canonical.length, 'unique,', canonical.filter(c => c._fuzzy_match_flag).length, 'fuzzy flagged');\nreturn canonical.map(item => ({ json: item }));"
        },
        "id": "50caf015-dd4e-4183-8124-b35fddffa354",
        "name": "Deduplicate Records",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          -8496,
          192
        ]
      },
      {
        "parameters": {
          "jsCode": "const now = new Date().toISOString();\nreturn $input.all().map(item => {\n  const r = item.json;\n  return { json: {\n    name: r.name, phone: r.phone || null, domain: r.domain || null,\n    address: r.address || null, city: r.city || null, state: r.state || null,\n    country: r.country || 'US', google_place_id: r.google_place_id || null,\n    category: r.category || null, has_website: r.has_website || false,\n    has_online_booking: false, booking_platform: null, has_paid_ads: false,\n    on_groupon: false,\n    on_yelp: (r.source_urls || []).some(s => s.source === 'yelp_apify'),\n    google_review_count: r.google_review_count || 0,\n    google_rating: r.google_rating || null,\n    estimated_size: null, source_urls: r.source_urls || [],\n    enrichment_status: r._fuzzy_match_flag ? 'needs_review' : 'discovered',\n    lead_score: 0, discovered_at: now, enriched_at: null,\n    discovery_metro: r.discovery_metro || null,\n    _fuzzy_match_flag: r._fuzzy_match_flag || false\n  }};\n});"
        },
        "id": "59bd4554-e739-4428-bd72-53b502f85f61",
        "name": "Prepare for Supabase",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          -8272,
          192
        ]
      },
      {
        "parameters": {
          "conditions": {
            "options": {
              "caseSensitive": true,
              "leftValue": "",
              "typeValidation": "strict",
              "version": 1
            },
            "conditions": [
              {
                "id": "fuzzy-check",
                "leftValue": "={{ $json._fuzzy_match_flag }}",
                "rightValue": true,
                "operator": {
                  "type": "boolean",
                  "operation": "equals",
                  "singleValue": true
                }
              }
            ],
            "combinator": "and"
          },
          "options": {}
        },
        "id": "21269bb4-ab43-49df-94ec-17640d94777d",
        "name": "Fuzzy Match?",
        "type": "n8n-nodes-base.if",
        "typeVersion": 2,
        "position": [
          -8048,
          192
        ]
      },
      {
        "parameters": {
          "method": "POST",
          "url": "={{ $env.SUPABASE_URL }}/rest/v1/companies?on_conflict=google_place_id",
          "sendHeaders": true,
          "headerParameters": {
            "parameters": [
              {
                "name": "apikey",
                "value": "={{ $env.SUPABASE_SERVICE_KEY }}"
              },
              {
                "name": "Authorization",
                "value": "=Bearer {{ $env.SUPABASE_SERVICE_KEY }}"
              },
              {
                "name": "Content-Type",
                "value": "application/json"
              },
              {
                "name": "Prefer",
                "value": "resolution=merge-duplicates"
              }
            ]
          },
          "sendBody": true,
          "specifyBody": "json",
          "jsonBody": "={{ JSON.stringify({ name: $json.name, phone: $json.phone, domain: $json.domain, address: $json.address, city: $json.city, state: $json.state, country: $json.country, google_place_id: $json.google_place_id, category: $json.category, has_website: $json.has_website, source_urls: $json.source_urls, discovery_metro: $json.discovery_metro, enrichment_status: 'discovered', discovered_at: new Date().toISOString() }) }}",
          "options": {
            "batching": {
              "batch": {}
            }
          }
        },
        "id": "f4cdac90-eda5-4c9c-8e3e-aa2f04cf45ab",
        "name": "Insert to Supabase",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.2,
        "position": [
          -7824,
          288
        ],
        "alwaysOutputData": true,
        "onError": "continueRegularOutput",
        "notes": "Clean records. Uses service_role key (bypasses RLS)."
      },
      {
        "parameters": {
          "method": "POST",
          "url": "={{ $env.SUPABASE_URL }}/rest/v1/companies?on_conflict=google_place_id",
          "sendHeaders": true,
          "headerParameters": {
            "parameters": [
              {
                "name": "apikey",
                "value": "={{ $env.SUPABASE_SERVICE_KEY }}"
              },
              {
                "name": "Authorization",
                "value": "=Bearer {{ $env.SUPABASE_SERVICE_KEY }}"
              },
              {
                "name": "Content-Type",
                "value": "application/json"
              },
              {
                "name": "Prefer",
                "value": "resolution=merge-duplicates"
              }
            ]
          },
          "sendBody": true,
          "specifyBody": "json",
          "jsonBody": "={{ JSON.stringify({ name: $json.name, phone: $json.phone, domain: $json.domain, address: $json.address, city: $json.city, state: $json.state, country: $json.country, google_place_id: $json.google_place_id, category: $json.category, has_website: $json.has_website, source_urls: $json.source_urls, discovery_metro: $json.discovery_metro, enrichment_status: 'needs_review', discovered_at: new Date().toISOString() }) }}",
          "options": {}
        },
        "id": "6014b12d-87d3-45bc-9a6c-678a3c1031a2",
        "name": "Insert Flagged (Needs Review)",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.2,
        "position": [
          -7824,
          96
        ],
        "notes": "Fuzzy-matched records. Status = needs_review for manual dedup.",
        "onError": "continueRegularOutput"
      },
      {
        "parameters": {
          "jsCode": "const allItems = $('Deduplicate Records').all();\nconst metro = $('Metro Config').first().json.metro_name;\nconst fromGoogle = allItems.filter(i => (i.json.source_urls || []).some(s => s.source === 'google_places')).length;\nconst fromYelp = allItems.filter(i => (i.json.source_urls || []).some(s => s.source === 'yelp_apify')).length;\nconst bothSources = allItems.filter(i => { const s = (i.json.source_urls || []).map(x => x.source); return s.includes('google_places') && s.includes('yelp_apify'); }).length;\nconst fuzzyFlagged = allItems.filter(i => i.json._fuzzy_match_flag).length;\n\nconst summary = {\n  metro, run_timestamp: new Date().toISOString(),\n  total_unique_records: allItems.length,\n  found_on_google: fromGoogle, found_on_yelp: fromYelp, found_on_both: bothSources,\n  flagged_for_review: fuzzyFlagged,\n  clean_records: allItems.length - fuzzyFlagged,\n  sources_used: ['google_places', 'yelp_apify']\n};\nconsole.log('=== DISCOVERY RUN SUMMARY ===');\nconsole.log(JSON.stringify(summary, null, 2));\nreturn [{ json: summary }];"
        },
        "id": "d53e0354-3695-4aaf-948e-92e8bf3e80c4",
        "name": "Run Summary",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          -7600,
          192
        ]
      },
      {
        "parameters": {
          "jsCode": "const response = $input.first().json;\nlet runId = '';\nlet datasetId = '';\n\nif (response.data) {\n  runId = response.data.id || '';\n  datasetId = response.data.defaultDatasetId || '';\n}\n\nif (!runId) {\n  throw new Error('Failed to start Apify run. Response: ' + JSON.stringify(response).substring(0, 500));\n}\n\nreturn [{ json: { runId, datasetId, pollCount: 0 } }];"
        },
        "id": "ca8aee6f-7b5b-40b6-8d16-3902dceea5c6",
        "name": "Extract Run ID",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          -10288,
          288
        ]
      },
      {
        "parameters": {
          "amount": 20
        },
        "id": "13385ec3-d78d-4bbd-8579-d67fd6d52395",
        "name": "Wait 30s",
        "type": "n8n-nodes-base.wait",
        "typeVersion": 1.1,
        "position": [
          -10064,
          288
        ],
        "webhookId": "58f36f86-6055-45a5-84d5-f71b858202b8"
      },
      {
        "parameters": {
          "url": "=https://api.apify.com/v2/actor-runs/{{ $('Extract Run ID').first().json.runId }}?token={{ $env.APIFY_API_TOKEN }}",
          "options": {
            "timeout": 15000
          }
        },
        "id": "6ce308da-fda1-430e-a1ed-ef0605941bcd",
        "name": "Check Run Status",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.2,
        "position": [
          -9840,
          224
        ],
        "alwaysOutputData": true,
        "onError": "continueRegularOutput"
      },
      {
        "parameters": {
          "jsCode": "const response = $input.first().json;\nconst prevData = $('Extract Run ID').first().json;\n\nlet status = 'UNKNOWN';\nlet datasetId = prevData.datasetId || '';\n\n// Single run response\nif (response.data && response.data.status && !response.data.items) {\n  status = response.data.status;\n  if (response.data.defaultDatasetId) datasetId = response.data.defaultDatasetId;\n}\n// List response\nelse if (response.data && response.data.items && response.data.items.length > 0) {\n  status = response.data.items[0].status;\n  if (response.data.items[0].defaultDatasetId) datasetId = response.data.items[0].defaultDatasetId;\n}\n\n// Increment poll count from previous Parse Status if looping, otherwise from Extract Run ID\nlet pollCount = 0;\ntry {\n  pollCount = $('Parse Status').first().json.pollCount || 0;\n} catch(e) {\n  pollCount = prevData.pollCount || 0;\n}\npollCount++;\n\nreturn [{ json: { runId: prevData.runId, datasetId, pollCount, status } }];"
        },
        "id": "d7861f94-bfc5-4f69-9f11-b82f2815ba8c",
        "name": "Parse Status",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          -9616,
          224
        ]
      },
      {
        "parameters": {
          "conditions": {
            "options": {
              "caseSensitive": true,
              "leftValue": "",
              "typeValidation": "strict"
            },
            "conditions": [
              {
                "id": "succeeded",
                "leftValue": "={{ $json.status }}",
                "rightValue": "SUCCEEDED",
                "operator": {
                  "type": "string",
                  "operation": "equals"
                }
              }
            ],
            "combinator": "and"
          },
          "options": {}
        },
        "id": "deb02ddd-d3e5-4f68-a564-a4380714224d",
        "name": "Run Succeeded?",
        "type": "n8n-nodes-base.if",
        "typeVersion": 2,
        "position": [
          -9392,
          288
        ]
      },
      {
        "parameters": {
          "method": "POST",
          "url": "=https://api.apify.com/v2/actor-tasks/uplifted_veranda~yelp-scraper-task/runs?token={{ $env.APIFY_API_TOKEN }}",
          "sendHeaders": true,
          "headerParameters": {
            "parameters": [
              {
                "name": "Content-Type",
                "value": "application/json"
              }
            ]
          },
          "sendBody": true,
          "specifyBody": "json",
          "jsonBody": "={\n  \"searchTerms\": [\"{{ $json.query }}\"],\n  \"locations\": [\"{{ $json.yelp_location }}\"],\n  \"searchLimit\": 100,\n  \"maxImages\": 0,\n  \"reviewLimit\": 0\n}",
          "options": {
            "timeout": 30000
          }
        },
        "id": "b0bba0ff-f1a6-4e25-bdea-6002b7ed869c",
        "name": "Start Apify Run",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.2,
        "position": [
          -10512,
          288
        ],
        "alwaysOutputData": true,
        "onError": "continueRegularOutput",
        "notes": "Starts the Apify task. Returns run object with data.id for polling."
      },
      {
        "parameters": {
          "jsCode": "const metro = $('Metro Config').first().json.metro_name;\nconst query = $('Split Search Queries').first().json.query || '';\nconst results = [];\n\n// Booking platform domain blocklist\nconst BLOCKED_DOMAINS = ['wixsite.com','wix.com','setmore.com','schedulista.com','glossgenius.com','square.site','genbook.com','jane.app','acuityscheduling.com','mindbodyonline.com','mindbody.io','vagaro.com','fresha.com','schedulicity.com','booksy.com','massagebook.com','noterro.com','clinicsense.com','calendly.com','squarespace.com'];\n// Business type blocklist - filter non-target businesses before Supabase insert\nconst BUSINESS_TYPE_BLOCKLIST = ['school','college','university','association','federation','union','board of','institute','academy','program'];\n\n\nfor (const item of items) {\n  const biz = item.json;\n  if (!biz.name) continue;\n\n  // Business type filter - skip non-target businesses\n  const _bizNameLower = biz.name.toLowerCase();\n  const _bizCatLower = ((biz.categories || []).join(', ')).toLowerCase();\n  if (BUSINESS_TYPE_BLOCKLIST.some(kw => _bizNameLower.includes(kw) || _bizCatLower.includes(kw))) continue;\n\n  let phone = (biz.phone || '').replace(/[^\\d+]/g, '');\n  if (phone && !phone.startsWith('+')) {\n    phone = '+1' + phone.replace(/^1/, '');\n  }\n\n  let domain = '';\n  if (biz.website) {\n    try {\n      domain = new URL(biz.website.startsWith('http') ? biz.website : 'https://' + biz.website)\n        .hostname.replace(/^www\\./, '');\n    } catch(e) {}\n  }\n\n  // Check domain against blocklist\n  let _domain_blocked = false;\n  let _domain_blocked_platform = '';\n  if (domain) {\n    const lowerDomain = domain.toLowerCase();\n    for (const blocked of BLOCKED_DOMAINS) {\n      if (lowerDomain === blocked || lowerDomain.endsWith('.' + blocked)) {\n        _domain_blocked = true;\n        _domain_blocked_platform = blocked;\n        domain = '';\n        break;\n      }\n    }\n  }\n\n  const addr = biz.address || {};\n  const fullAddress = [addr.addressLine1, addr.addressLine2, addr.addressLine3]\n    .filter(Boolean).join(', ');\n\n  results.push({\n    json: {\n      name: biz.name,\n      phone: phone,\n      domain: domain,\n      address: fullAddress,\n      city: addr.city || '',\n      state: addr.regionCode || '',\n      country: addr.country || 'US',\n      google_place_id: '',\n      category: (biz.categories || []).join(', '),\n      google_rating: null,\n      google_review_count: 0,\n      yelp_rating: biz.aggregatedRating || null,\n      yelp_review_count: biz.reviewCount || 0,\n      has_website: _domain_blocked ? false : !!biz.website,\n      yelp_url: biz.directUrl || '',\n      yelp_is_claimed: biz.claimed || false,\n      yelp_is_advertiser: biz.advertiser || false,\n      source_urls: [{source: 'yelp_apify', url: biz.directUrl || '', query_used: query}],\n      discovery_metro: metro,\n      discovery_source: 'yelp_apify',\n      _domain_blocked,\n      _domain_blocked_platform\n    }\n  });\n}\n\nreturn results.length > 0 ? results : [{ json: { _empty: true } }];"
        },
        "id": "ca715d3a-ef73-4e5b-82cc-2f181555ee2a",
        "name": "Normalize Yelp Results",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          -8944,
          288
        ],
        "notes": "After testing, change $('Test Input (Remove After Testing)') to $('Metro Config') and $('Split Search Queries')."
      },
      {
        "parameters": {
          "url": "=https://api.apify.com/v2/datasets/{{ $json.datasetId }}/items?token={{ $env.APIFY_API_TOKEN }}",
          "options": {
            "timeout": 60000
          }
        },
        "id": "78eece76-1e81-4ce4-aef2-637dfd3815be",
        "name": "Fetch Apify Results",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.2,
        "position": [
          -9168,
          288
        ],
        "alwaysOutputData": true
      },
      {
        "parameters": {
          "assignments": {
            "assignments": [
              {
                "id": "batch-size",
                "name": "batch_size",
                "value": "1000",
                "type": "string"
              },
              {
                "id": "batch-offset",
                "name": "batch_offset",
                "value": "0",
                "type": "string"
              },
              {
                "id": "http-timeout",
                "name": "http_timeout_ms",
                "value": "15000",
                "type": "string"
              },
              {
                "id": "skip-google-details",
                "name": "skip_google_details",
                "value": "false",
                "type": "string"
              },
              {
                "id": "skip-social-discovery",
                "name": "skip_social_discovery",
                "value": "true",
                "type": "string"
              }
            ]
          },
          "options": {}
        },
        "id": "e5d5b057-40c0-4930-bc05-b3bcc0b8f1bb",
        "name": "Enrichment Config",
        "type": "n8n-nodes-base.set",
        "typeVersion": 3.4,
        "position": [
          -7376,
          192
        ],
        "notes": "CONFIGURE: batch_size = how many companies to process per run. batch_offset = starting offset (for resuming). http_timeout_ms = timeout for website fetches. Set skip flags to 'true' to bypass sub-steps."
      },
      {
        "parameters": {
          "url": "={{ $env.SUPABASE_URL }}/rest/v1/companies?enrichment_status=in.(discovered,partially_enriched)&discovery_metro=eq.{{ $('Metro Config').first().json.metro_name }}&order=discovered_at.asc&limit={{ $json.batch_size }}&offset={{ $json.batch_offset }}&select=id,name,phone,domain,address,city,state,country,google_place_id,category,has_website,google_review_count,google_rating,source_urls,on_yelp,on_groupon",
          "sendHeaders": true,
          "headerParameters": {
            "parameters": [
              {
                "name": "apikey",
                "value": "={{ $env.SUPABASE_SERVICE_KEY }}"
              },
              {
                "name": "Authorization",
                "value": "=Bearer {{ $env.SUPABASE_SERVICE_KEY }}"
              }
            ]
          },
          "options": {
            "timeout": 30000
          }
        },
        "id": "abaeeae8-e237-4efb-b319-f5234498f039",
        "name": "Fetch Batch from Supabase",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.2,
        "position": [
          -7152,
          192
        ],
        "alwaysOutputData": true
      },
      {
        "parameters": {
          "jsCode": "// Supabase HTTP node may return items individually (one per row) or as a single array.\n// Handle both cases.\nconst allInputs = $input.all();\n\nlet companies = [];\n\nif (allInputs.length === 1 && Array.isArray(allInputs[0].json)) {\n  // Single item containing an array\n  companies = allInputs[0].json;\n} else if (allInputs.length === 1 && allInputs[0].json[0]) {\n  // Single item with nested array\n  companies = allInputs[0].json;\n} else {\n  // Multiple items, one company per item (this is what n8n HTTP node does)\n  companies = allInputs.map(i => i.json);\n}\n\nif (!companies || companies.length === 0 || (companies.length === 1 && !companies[0].id)) {\n  return [{ json: { _empty: true, _count: 0, _message: 'No companies to enrich in this batch' } }];\n}\n\nconsole.log(`Batch loaded: ${companies.length} companies to enrich`);\n\nreturn companies.map(c => ({ json: c }));"
        },
        "id": "1f84094c-dbc7-488f-8c63-8b30d1d23217",
        "name": "Parse Batch",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          -6928,
          192
        ]
      },
      {
        "parameters": {
          "conditions": {
            "options": {
              "caseSensitive": true,
              "leftValue": "",
              "typeValidation": "loose"
            },
            "conditions": [
              {
                "id": "empty-check",
                "leftValue": "={{ $json._empty }}",
                "rightValue": true,
                "operator": {
                  "type": "boolean",
                  "operation": "equals",
                  "singleValue": true
                }
              }
            ],
            "combinator": "and"
          },
          "options": {}
        },
        "id": "292b2adf-daa2-478b-8d42-53696df8b73d",
        "name": "Batch Empty?",
        "type": "n8n-nodes-base.if",
        "typeVersion": 2,
        "position": [
          -6704,
          192
        ]
      },
      {
        "parameters": {
          "jsCode": "return [{ json: { message: 'No companies with enrichment_status=discovered found. Step 2 complete or no Step 1 data available.', completed_at: new Date().toISOString() } }];"
        },
        "id": "137601ae-3d7c-425d-8c75-f5fae5575bf7",
        "name": "No Records - Done",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          -6480,
          96
        ]
      },
      {
        "parameters": {
          "conditions": {
            "options": {
              "caseSensitive": true,
              "leftValue": "",
              "typeValidation": "loose"
            },
            "conditions": [
              {
                "id": "has-domain",
                "leftValue": "={{ $json.has_website }}",
                "rightValue": true,
                "operator": {
                  "type": "boolean",
                  "operation": "equals",
                  "singleValue": true
                }
              }
            ],
            "combinator": "and"
          },
          "options": {}
        },
        "id": "2358770c-9b07-4173-b8a5-ac37cce4ed99",
        "name": "Has Website?",
        "type": "n8n-nodes-base.if",
        "typeVersion": 2,
        "position": [
          -5584,
          288
        ]
      },
      {
        "parameters": {
          "jsCode": "// For companies without a website, pass through with empty enrichment\n// but still check domain for booking platform signals\nconst items = $input.all();\nconst results = [];\n\nconst bookingSignatures = {\n  'jane_app': ['jane.app', 'janeapp.com'],\n  'acuity': ['acuityscheduling.com', 'squareup.com/appointments'],\n  'mindbody': ['mindbodyonline.com', 'clients.mindbodyonline.com', 'mindbody.io'],\n  'square': ['square.site', 'squareup.com'],\n  'vagaro': ['vagaro.com'],\n  'fresha': ['fresha.com', 'shedul.com'],\n  'schedulicity': ['schedulicity.com'],\n  'schedulista': ['schedulista.com'],\n  'booksy': ['booksy.com'],\n  'massagebook': ['massagebook.com'],\n  'genbook': ['genbook.com'],\n  'noterro': ['noterro.com'],\n  'clinicsense': ['clinicsense.com'],\n  'wix_bookings': ['wix.com/booking'],\n  'calendly': ['calendly.com']\n};\n\nfor (const entry of items) {\n  const item = entry.json;\n  const domain = (item.domain || '').toLowerCase();\n\n  let booking_platform = null;\n  let has_online_booking = false;\n\n  for (const [platform, signatures] of Object.entries(bookingSignatures)) {\n    for (const sig of signatures) {\n      if (domain.includes(sig)) {\n        booking_platform = platform;\n        has_online_booking = true;\n        break;\n      }\n    }\n    if (has_online_booking) break;\n  }\n\n  results.push({\n    json: {\n      ...item,\n      _website_enrichment: {\n        has_online_booking,\n        booking_platform,\n        has_paid_ads: false,\n        estimated_size: null,\n        social_links_found: [],\n        _website_fetch_status: 'skipped_no_website'\n      }\n    }\n  });\n}\n\nreturn results;"
        },
        "id": "3b7bfe86-1088-4850-bf9c-0c19122519b8",
        "name": "Skip - No Website",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          -5136,
          384
        ]
      },
      {
        "parameters": {
          "url": "=https://{{ $json.domain }}",
          "sendHeaders": true,
          "headerParameters": {
            "parameters": [
              {
                "name": "User-Agent",
                "value": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36"
              },
              {
                "name": "Accept",
                "value": "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8"
              }
            ]
          },
          "options": {
            "redirect": {
              "redirect": {
                "maxRedirects": 5
              }
            },
            "response": {
              "response": {
                "fullResponse": true,
                "responseFormat": "text"
              }
            },
            "timeout": "={{ Number($('Enrichment Config').first().json.http_timeout_ms) }}"
          }
        },
        "id": "89b0f41d-00bc-4b6c-aed8-d1dc8ba4269d",
        "name": "Fetch Website HTML",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.2,
        "position": [
          -5360,
          192
        ],
        "onError": "continueRegularOutput",
        "notes": "Fetches homepage HTML. On error (timeout, SSL, 403, etc.) continues with error data so the pipeline doesn't break."
      },
      {
        "parameters": {
          "jsCode": "// runOnceForAllItems \u2014 index-paired with Has Website?\nconst upstreamAll = $('Has Website?').all();\nconst inputAll = $input.all();\nconst results = [];\n\n// === HOISTED CONSTANTS ===\nconst bookingSignatures = {\n  'jane_app': ['jane.app', 'janeapp.com'],\n  'acuity': ['acuityscheduling.com', 'squareup.com/appointments', 'app.acuityscheduling.com'],\n  'mindbody': ['mindbodyonline.com', 'clients.mindbodyonline.com', 'mindbody.io', 'healcode.com'],\n  'square': ['square.site', 'squareup.com'],\n  'vagaro': ['vagaro.com'],\n  'fresha': ['fresha.com', 'shedul.com'],\n  'schedulicity': ['schedulicity.com'],\n  'schedulista': ['schedulista.com'],\n  'booksy': ['booksy.com'],\n  'massagebook': ['massagebook.com'],\n  'genbook': ['genbook.com'],\n  'noterro': ['noterro.com'],\n  'clinicsense': ['clinicsense.com'],\n  'wix_bookings': ['wix.com/booking', 'bookings.wixapps.net'],\n  'calendly': ['calendly.com']\n};\n\nconst junkEmailDomains = [\n  'sentry.io', 'schema.org', 'w3.org', 'wordpress.com', 'wordpress.org',\n  'squarespace.com', 'wix.com', 'gravatar.com', 'facebook.com', 'twitter.com',\n  'instagram.com', 'youtube.com', 'linkedin.com', 'pinterest.com', 'tiktok.com',\n  'cloudflare.com', 'googleapis.com', 'googletagmanager.com', 'google-analytics.com',\n  'gstatic.com', 'jsdelivr.net', 'cdnjs.cloudflare.com', 'unpkg.com',\n  'bootstrapcdn.com', 'fontawesome.com', 'typekit.net', 'fonts.googleapis.com',\n  'example.com', 'example.org', 'test.com', 'localhost',\n  'mailinator.com', 'guerrillamail.com', 'tempmail.com', 'yopmail.com'\n];\n\nconst junkLocalPatterns = [\n  /^noreply$/i, /^no-reply$/i, /^donotreply$/i, /^do-not-reply$/i,\n  /^postmaster$/i, /^mailer-daemon$/i, /^webmaster$/i, /^root$/i,\n  /^null$/i, /^test$/i, /^admin$/i, /^abuse$/i\n];\n\nconst roleBasedPrefixes = ['info', 'contact', 'hello', 'office', 'reception',\n  'frontdesk', 'front.desk', 'appointments', 'booking', 'bookings',\n  'schedule', 'scheduling', 'inquiries', 'inquiry', 'general', 'team', 'staff',\n  'support', 'sales', 'billing'];\n\nconst adSignatures = [\n  'googleadservices.com', 'googlesyndication.com', 'googleads.g.doubleclick.net',\n  'google_conversion', 'conversion_async', 'ads/ga-audiences',\n  'fbevents.js', 'fbq(', 'snap.licdn.com', 'linkedin.com/insight',\n  'analytics.tiktok.com', 'tiktok.com/i18n/pixel', 'ads-twitter.com', 'static.ads-twitter.com'\n];\n\nconst socialPatterns = {\n  facebook: /https?:\\/\\/(?:www\\.)?facebook\\.com\\/[a-zA-Z0-9._-]+/gi,\n  instagram: /https?:\\/\\/(?:www\\.)?instagram\\.com\\/[a-zA-Z0-9._-]+/gi,\n  tiktok: /https?:\\/\\/(?:www\\.)?tiktok\\.com\\/@[a-zA-Z0-9._-]+/gi,\n  linkedin: /https?:\\/\\/(?:www\\.)?linkedin\\.com\\/(?:company|in)\\/[a-zA-Z0-9._-]+/gi,\n  x: /https?:\\/\\/(?:www\\.)?(?:twitter\\.com|x\\.com)\\/[a-zA-Z0-9._-]+/gi,\n  youtube: /https?:\\/\\/(?:www\\.)?youtube\\.com\\/(?:c\\/|channel\\/|@)[a-zA-Z0-9._-]+/gi\n};\n\nconst teamPatterns = [\n  /our\\s+team/i, /meet\\s+(?:the\\s+)?team/i, /our\\s+(?:therapists|practitioners|staff|massage\\s+therapists)/i,\n  /meet\\s+(?:our|the)\\s+(?:therapists|practitioners|staff)/i\n];\n\nconst emailRegex = /[a-zA-Z0-9._%+\\-]+@[a-zA-Z0-9.\\-]+\\.[a-zA-Z]{2,}/g;\nconst mailtoRegex = /mailto:([a-zA-Z0-9._%+\\-]+@[a-zA-Z0-9.\\-]+\\.[a-zA-Z]{2,})/gi;\n\nconst bookingPatterns = ['book now', 'book online', 'book appointment', 'schedule now', 'schedule online', 'book a massage', 'online booking'];\n\nconst soloSignals = ['sole proprietor', 'solo practice', 'independent massage',\n  'i am a licensed', \"i'm a licensed\", 'about me', 'my practice', 'my approach',\n  'my services', 'i specialize', 'i provide'];\n\nfor (let i = 0; i < inputAll.length; i++) {\n  const company = upstreamAll[i].json;\n  const response = inputAll[i].json;\n  const domain = (company.domain || '').toLowerCase();\n\n  // === DOMAIN-BASED BOOKING DETECTION (runs even if fetch fails) ===\n  let booking_platform = null;\n  let has_online_booking = false;\n\n  // Check domain first\n  for (const [platform, signatures] of Object.entries(bookingSignatures)) {\n    for (const sig of signatures) {\n      if (domain.includes(sig)) {\n        booking_platform = platform;\n        has_online_booking = true;\n        break;\n      }\n    }\n    if (has_online_booking) break;\n  }\n\n  // Handle fetch errors\n  if (response.error || (!response.body && !response.data)) {\n    results.push({\n      json: {\n        ...company,\n        _website_enrichment: {\n          has_online_booking,\n          booking_platform,\n          has_paid_ads: false,\n          estimated_size: null,\n          social_links_found: [],\n          emails_found: [],\n          best_email: null,\n          _website_fetch_status: 'error',\n          _website_error: response.error || 'Empty response'\n        }\n      }\n    });\n    continue;\n  }\n\n  const rawHtml = response.body || response.data || '';\n  const html = (typeof rawHtml === 'string' ? rawHtml : '').toLowerCase();\n  const htmlOriginal = typeof rawHtml === 'string' ? rawHtml : '';\n\n  // === EMAIL EXTRACTION ===\n  const allEmailMatches = htmlOriginal.match(emailRegex) || [];\n\n  // Also extract from mailto: links (higher confidence)\n  // Reset regex lastIndex since we reuse it across loop iterations\n  mailtoRegex.lastIndex = 0;\n  const mailtoEmails = new Set();\n  let mailtoMatch;\n  while ((mailtoMatch = mailtoRegex.exec(htmlOriginal)) !== null) {\n    mailtoEmails.add(mailtoMatch[1].toLowerCase());\n  }\n\n  // Deduplicate and filter\n  const uniqueEmails = [...new Set(allEmailMatches.map(e => e.toLowerCase()))];\n  const scoredEmails = [];\n\n  for (const email of uniqueEmails) {\n    const [localPart, emailDomain] = email.split('@');\n    if (!emailDomain) continue;\n\n    // Filter out junk domains\n    if (junkEmailDomains.some(d => emailDomain.includes(d))) continue;\n\n    // Filter out junk local parts\n    if (junkLocalPatterns.some(p => p.test(localPart))) continue;\n\n    // Filter out numeric-only local parts\n    if (/^\\d+$/.test(localPart)) continue;\n\n    // Score the email\n    let score = 0;\n    if (domain && emailDomain.includes(domain.replace('www.', ''))) score += 20;\n    if (mailtoEmails.has(email)) score += 10;\n    if (roleBasedPrefixes.some(p => localPart === p || localPart.startsWith(p + '.'))) score += 5;\n\n    scoredEmails.push({ email, score, from_mailto: mailtoEmails.has(email) });\n  }\n\n  // Sort by score descending\n  scoredEmails.sort((a, b) => b.score - a.score);\n  const best_email = scoredEmails.length > 0 ? scoredEmails[0].email : null;\n\n  // === HTML-BASED BOOKING DETECTION ===\n  if (!has_online_booking) {\n    for (const [platform, signatures] of Object.entries(bookingSignatures)) {\n      for (const sig of signatures) {\n        if (html.includes(sig)) {\n          booking_platform = platform;\n          has_online_booking = true;\n          break;\n        }\n      }\n      if (has_online_booking) break;\n    }\n  }\n\n  if (!has_online_booking) {\n    for (const pattern of bookingPatterns) {\n      if (html.includes(pattern)) {\n        has_online_booking = true;\n        booking_platform = 'unknown';\n        break;\n      }\n    }\n  }\n\n  // === PAID ADS DETECTION ===\n  let has_paid_ads = false;\n  for (const sig of adSignatures) {\n    if (html.includes(sig)) {\n      has_paid_ads = true;\n      break;\n    }\n  }\n\n  // === SOCIAL LINKS EXTRACTION ===\n  const social_links_found = [];\n  const seenPlatforms = new Set();\n\n  for (const [platform, regex] of Object.entries(socialPatterns)) {\n    // Reset regex lastIndex since we reuse across loop iterations\n    regex.lastIndex = 0;\n    const matches = htmlOriginal.match(regex) || [];\n    for (const url of matches) {\n      const lowerUrl = url.toLowerCase();\n      if (lowerUrl.includes('/sharer') || lowerUrl.includes('/share') ||\n          lowerUrl.includes('/intent') || lowerUrl.includes('/login') ||\n          lowerUrl.includes('/help') || lowerUrl.includes('/about') ||\n          lowerUrl.includes('/policies') || lowerUrl.includes('/privacy')) {\n        continue;\n      }\n      if (!seenPlatforms.has(platform)) {\n        social_links_found.push({ platform, url: url.replace(/\\/+$/, '') });\n        seenPlatforms.add(platform);\n      }\n    }\n  }\n\n  // === TEAM SIZE ESTIMATION ===\n  let estimated_size = null;\n\n  let hasTeamPage = false;\n  for (const p of teamPatterns) {\n    if (p.test(htmlOriginal)) {\n      hasTeamPage = true;\n      break;\n    }\n  }\n\n  if (hasTeamPage) {\n    const namePatterns = htmlOriginal.match(/<h[2-4][^>]*>[^<]{2,40}<\\/h[2-4]>/gi) || [];\n    const staffLinks = htmlOriginal.match(/\\/(?:team|staff|therapist|practitioner)s?\\/[a-z-]+/gi) || [];\n    const memberCount = Math.max(namePatterns.length, staffLinks.length);\n    if (memberCount <= 1) estimated_size = 'solo';\n    else if (memberCount <= 5) estimated_size = 'small';\n    else estimated_size = 'medium';\n  } else {\n    const isSolo = soloSignals.some(s => html.includes(s));\n    if (isSolo) estimated_size = 'solo';\n  }\n\n  results.push({\n    json: {\n      ...company,\n      _website_enrichment: {\n        has_online_booking,\n        booking_platform,\n        has_paid_ads,\n        estimated_size,\n        social_links_found,\n        emails_found: scoredEmails.slice(0, 5),\n        best_email,\n        _website_fetch_status: 'success'\n      }\n    }\n  });\n}\n\nreturn results;"
        },
        "id": "9fc33b79-32fd-4245-9b47-b645a1dc7c58",
        "name": "Analyze Website HTML",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          -5136,
          192
        ],
        "notes": "Detects booking platforms, paid ads scripts, social media links, and estimates team size from website HTML."
      },
      {
        "parameters": {
          "jsCode": "// Merge website-enriched (from both paths: with website and without)\nconst items = $input.all();\nconst results = [];\n// Enrichment Config is a single-item node, .first() is correct here\nconst config = $('Enrichment Config').first().json;\nconst skipGoogleDetails = config.skip_google_details === 'true' || config.skip_google_details === true;\n\nfor (const entry of items) {\n  const item = entry.json;\n  const enrichment = item._website_enrichment || {};\n\n  // Prepare the enriched company object\n  const enriched = {\n    id: item.id,\n    name: item.name,\n    phone: item.phone,\n    domain: item.domain,\n    address: item.address,\n    city: item.city,\n    state: item.state,\n    country: item.country,\n    google_place_id: item.google_place_id,\n    category: item.category,\n    has_website: item.has_website,\n    google_review_count: item.google_review_count,\n    google_rating: item.google_rating,\n    source_urls: item.source_urls,\n    on_yelp: item.on_yelp,\n    on_groupon: item.on_groupon,\n\n    // Enriched fields from website analysis\n    has_online_booking: enrichment.has_online_booking || false,\n    booking_platform: enrichment.booking_platform || null,\n    has_paid_ads: enrichment.has_paid_ads || false,\n    estimated_size: enrichment.estimated_size || null,\n\n    // Email fields from website scraping (BUG-F012 fix)\n    _emails_found: enrichment.emails_found || [],\n    _best_email: enrichment.best_email || null,\n\n    // Backfill data from Google Places lookup (BUG-F013 fix)\n    _backfill_patch: item._backfill_patch || null,\n\n    // Social links for later processing\n    _social_links_found: enrichment.social_links_found || [],\n    _website_fetch_status: enrichment._website_fetch_status || 'unknown',\n    _website_error: enrichment._website_error || null,\n    _needs_social_discovery: (enrichment.social_links_found || []).length === 0,\n    _skip_google_details: skipGoogleDetails\n  };\n\n  results.push({ json: enriched });\n}\n\nreturn results;"
        },
        "id": "5ab890a5-77ce-4e02-afff-9a58b1cf852c",
        "name": "Merge Website Results",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          -4912,
          288
        ]
      },
      {
        "parameters": {
          "conditions": {
            "options": {
              "caseSensitive": true,
              "leftValue": "",
              "typeValidation": "loose"
            },
            "conditions": [
              {
                "id": "has-place-id",
                "leftValue": "={{ $json.google_place_id }}",
                "rightValue": "",
                "operator": {
                  "type": "string",
                  "operation": "notEquals"
                }
              },
              {
                "id": "not-skipped",
                "leftValue": "={{ $json._skip_google_details }}",
                "rightValue": true,
                "operator": {
                  "type": "boolean",
                  "operation": "notEquals"
                }
              }
            ],
            "combinator": "and"
          },
          "options": {}
        },
        "id": "75afb43c-2b57-4603-9062-bbb20e5a8bfe",
        "name": "Has Google Place ID?",
        "type": "n8n-nodes-base.if",
        "typeVersion": 2,
        "position": [
          -4688,
          288
        ]
      },
      {
        "parameters": {
          "url": "=https://places.googleapis.com/v1/places/{{ $json.google_place_id }}",
          "sendHeaders": true,
          "headerParameters": {
            "parameters": [
              {
                "name": "X-Goog-FieldMask",
                "value": "currentOpeningHours,regularOpeningHours,types,photos,priceLevel,businessStatus"
              },
              {
                "name": "X-Goog-Api-Key",
                "value": "={{ $env.GOOGLE_PLACES_API_KEY }}"
              }
            ]
          },
          "options": {
            "timeout": 15000
          }
        },
        "id": "b5388f46-798b-4b64-81b3-93e6e088b48d",
        "name": "Google Places Details",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.2,
        "position": [
          -4464,
          192
        ],
        "onError": "continueRegularOutput",
        "notes": "Fetches ONLY incremental fields not captured in Step 1 Text Search: opening hours, business status, price level, photo count."
      },
      {
        "parameters": {
          "jsCode": "// runOnceForAllItems \u2014 index-paired with Has Google Place ID?\nconst upstreamAll = $('Has Google Place ID?').all();\nconst inputAll = $input.all();\nconst results = [];\n\nfor (let i = 0; i < inputAll.length; i++) {\n  const company = upstreamAll[i].json;\n  const details = inputAll[i].json;\n\n  // Extract incremental data from Google Places Details\n  let opening_hours = null;\n  let business_status = null;\n  let photo_count = 0;\n  let price_level = null;\n  let additional_types = [];\n\n  if (details && !details.error) {\n    if (details.regularOpeningHours && details.regularOpeningHours.periods) {\n      opening_hours = details.regularOpeningHours;\n    } else if (details.currentOpeningHours && details.currentOpeningHours.periods) {\n      opening_hours = details.currentOpeningHours;\n    }\n    business_status = details.businessStatus || null;\n    if (details.photos && Array.isArray(details.photos)) {\n      photo_count = details.photos.length;\n    }\n    price_level = details.priceLevel || null;\n    if (details.types && Array.isArray(details.types)) {\n      additional_types = details.types;\n    }\n  }\n\n  results.push({\n    json: {\n      ...company,\n      _google_details: {\n        opening_hours,\n        business_status,\n        photo_count,\n        price_level,\n        additional_types,\n        _fetch_status: details.error ? 'error' : 'success'\n      }\n    }\n  });\n}\n\nreturn results;"
        },
        "id": "86bf32b5-7f8b-477d-bc0f-46cd919e314f",
        "name": "Parse Google Details",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          -4240,
          192
        ]
      },
      {
        "parameters": {
          "jsCode": "// Companies without Google Place ID skip details fetch\nconst items = $input.all();\nconst results = [];\n\nfor (const entry of items) {\n  const company = entry.json;\n  results.push({\n    json: {\n      ...company,\n      _google_details: {\n        opening_hours: null,\n        business_status: null,\n        photo_count: 0,\n        price_level: null,\n        additional_types: [],\n        _fetch_status: 'skipped'\n      }\n    }\n  });\n}\n\nreturn results;"
        },
        "id": "2a557f09-9a93-4fee-a243-b5ac2aa3aac4",
        "name": "Skip Google Details",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          -4352,
          400
        ]
      },
      {
        "parameters": {
          "jsCode": "const items = $input.all();\nconst results = [];\n\nfor (const entry of items) {\n  const item = entry.json;\n  const now = new Date().toISOString();\n\n  // Build the PATCH payload for Supabase\n  const updatePayload = {\n    has_online_booking: item.has_online_booking || false,\n    booking_platform: item.booking_platform || null,\n    has_paid_ads: item.has_paid_ads || false,\n    estimated_size: item.estimated_size || null,\n    enrichment_status: 'partially_enriched',\n    enriched_at: now\n  };\n\n  // Include backfill data ONLY from companies that went through the backfill path\n  // This prevents 409 conflicts when PATCHing domain on companies that already have one\n  const backfill = item._backfill_patch || {};\n  if (backfill.domain) updatePayload.domain = backfill.domain;\n  if (backfill.google_place_id) updatePayload.google_place_id = backfill.google_place_id;\n  if (backfill.google_rating) updatePayload.google_rating = backfill.google_rating;\n  if (backfill.google_review_count) updatePayload.google_review_count = backfill.google_review_count;\n\n  // has_website can change via website analysis (not just backfill)\n  if (item.has_website) updatePayload.has_website = item.has_website;\n\n  // Include website-scraped email if found (BUG-F012 fix: read from flat field)\n  const websiteEmail = item._best_email || null;\n  if (websiteEmail) {\n    updatePayload.email = websiteEmail;\n    // email_status stays NULL - will be verified in Step 4\n  }\n\n  results.push({\n    json: {\n      _company_id: item.id,\n      _update_payload: updatePayload,\n      // Pass through everything for social discovery\n      ...item\n    }\n  });\n}\n\nreturn results;"
        },
        "id": "b8406b5a-6d4c-4fd6-a5dc-10d327214c6d",
        "name": "Prepare Company Update",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          -4016,
          288
        ]
      },
      {
        "parameters": {
          "method": "PATCH",
          "url": "={{ $env.SUPABASE_URL }}/rest/v1/companies?id=eq.{{ $json._company_id }}",
          "sendHeaders": true,
          "headerParameters": {
            "parameters": [
              {
                "name": "apikey",
                "value": "={{ $env.SUPABASE_SERVICE_KEY }}"
              },
              {
                "name": "Authorization",
                "value": "=Bearer {{ $env.SUPABASE_SERVICE_KEY }}"
              },
              {
                "name": "Content-Type",
                "value": "application/json"
              },
              {
                "name": "Prefer",
                "value": "return=minimal"
              }
            ]
          },
          "sendBody": true,
          "specifyBody": "json",
          "jsonBody": "={{ JSON.stringify($json._update_payload) }}",
          "options": {
            "batching": {
              "batch": {
                "batchSize": 10,
                "batchInterval": 500
              }
            }
          }
        },
        "id": "5d505629-0622-4b1d-9221-f8be1c207a94",
        "name": "Update Company in Supabase",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.2,
        "position": [
          -3792,
          288
        ],
        "onError": "continueRegularOutput",
        "notes": "PATCH updates enrichment fields. Batched 10 at a time with 500ms delay to avoid overwhelming Supabase."
      },
      {
        "parameters": {
          "jsCode": "// runOnceForAllItems \u2014 index-paired with Prepare Company Update\n// Enrichment Config is a single-item node, hoisted outside loop\nconst upstreamAll = $('Prepare Company Update').all();\nconst inputAll = $input.all();\nconst config = $('Enrichment Config').first().json;\nconst skipSocial = config.skip_social_discovery === 'true' || config.skip_social_discovery === true;\nconst results = [];\n\nfor (let i = 0; i < inputAll.length; i++) {\n  const item = upstreamAll[i].json;\n\n  const socialLinks = item._social_links_found || [];\n  const needsDiscovery = item._needs_social_discovery && !skipSocial;\n\n  results.push({\n    json: {\n      company_id: item.id,\n      company_name: item.name,\n      city: item.city,\n      state: item.state,\n      domain: item.domain,\n      social_links_found: socialLinks,\n      needs_social_discovery: needsDiscovery,\n      _skip_social: skipSocial\n    }\n  });\n}\n\nreturn results;"
        },
        "id": "34e24a4d-6e12-4c13-95b9-d417e5a19d82",
        "name": "Prepare Social Processing",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          -3568,
          288
        ]
      },
      {
        "parameters": {
          "conditions": {
            "options": {
              "caseSensitive": true,
              "leftValue": "",
              "typeValidation": "loose"
            },
            "conditions": [
              {
                "id": "has-social-links",
                "leftValue": "={{ $json.social_links_found.length }}",
                "rightValue": "0",
                "operator": {
                  "type": "number",
                  "operation": "gt"
                }
              }
            ],
            "combinator": "and"
          },
          "options": {}
        },
        "id": "e77bb9db-36cc-479e-8d0c-13ef6b6482c1",
        "name": "Has Social Links?",
        "type": "n8n-nodes-base.if",
        "typeVersion": 2,
        "position": [
          -3344,
          288
        ]
      },
      {
        "parameters": {
          "jsCode": "// Insert social profiles found from website HTML into Supabase social_profiles table\nconst items = $input.all();\nconst results = [];\n\nfor (const entry of items) {\n  const item = entry.json;\n  const links = item.social_links_found || [];\n\n  if (links.length === 0) {\n    results.push({ json: { _social_inserts: 0, company_id: item.company_id } });\n    continue;\n  }\n\n  // Build an array of social_profiles rows\n  const rows = links.map(link => ({\n    company_id: item.company_id,\n    platform: link.platform,\n    profile_url: link.url,\n    follower_count: null,\n    post_count: null,\n    last_post_date: null,\n    scraped_at: new Date().toISOString()\n  }));\n\n  results.push({\n    json: {\n      _social_rows: rows,\n      _social_inserts: rows.length,\n      company_id: item.company_id,\n      company_name: item.company_name,\n      city: item.city,\n      state: item.state,\n      needs_social_discovery: false\n    }\n  });\n}\n\nreturn results;"
        },
        "id": "be72a227-8bf1-49a5-9c84-229905aab929",
        "name": "Prepare Social Profiles Insert",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          -432,
          0
        ]
      },
      {
        "parameters": {
          "method": "POST",
          "url": "={{ $env.SUPABASE_URL }}/rest/v1/social_profiles",
          "sendHeaders": true,
          "headerParameters": {
            "parameters": [
              {
                "name": "apikey",
                "value": "={{ $env.SUPABASE_SERVICE_KEY }}"
              },
              {
                "name": "Authorization",
                "value": "=Bearer {{ $env.SUPABASE_SERVICE_KEY }}"
              },
              {
                "name": "Content-Type",
                "value": "application/json"
              },
              {
                "name": "Prefer",
                "value": "resolution=merge-duplicates,return=minimal"
              }
            ]
          },
          "sendBody": true,
          "specifyBody": "json",
          "jsonBody": "={{ JSON.stringify($json._social_rows) }}",
          "options": {}
        },
        "id": "7256fe4c-eff0-4345-ba69-bc010db8f0d8",
        "name": "Insert Social Profiles",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.2,
        "position": [
          -208,
          0
        ],
        "onError": "continueRegularOutput",
        "notes": "Inserts social profiles found from website HTML. Uses merge-duplicates to handle re-runs gracefully."
      },
      {
        "parameters": {
          "conditions": {
            "options": {
              "caseSensitive": true,
              "leftValue": "",
              "typeValidation": "loose"
            },
            "conditions": [
              {
                "id": "needs-discovery",
                "leftValue": "={{ $json.needs_social_discovery }}",
                "rightValue": true,
                "operator": {
                  "type": "boolean",
                  "operation": "equals",
                  "singleValue": true
                }
              }
            ],
            "combinator": "and"
          },
          "options": {}
        },
        "id": "60910ba9-01e0-4cbd-b8f9-6bf01758ff14",
        "name": "Needs Social Discovery?",
        "type": "n8n-nodes-base.if",
        "typeVersion": 2,
        "position": [
          -3120,
          368
        ]
      },
      {
        "parameters": {
          "jsCode": "// Collect all companies that need social discovery into a single batch for Apify\n// This node collects items from the loop and builds the search queries\nconst items = $input.all();\n\nconst searchQueries = [];\nconst companyMap = {};\n\nfor (const item of items) {\n  const data = item.json;\n  if (!data.company_name || !data.city) continue;\n  \n  const searchTerm = `${data.company_name} ${data.city} ${data.state || ''} massage`.trim();\n  searchQueries.push({\n    company_id: data.company_id,\n    company_name: data.company_name,\n    city: data.city,\n    state: data.state,\n    search_term: searchTerm\n  });\n}\n\nif (searchQueries.length === 0) {\n  return [{ json: { _no_social_discovery_needed: true, _count: 0 } }];\n}\n\nconsole.log(`Social discovery needed for ${searchQueries.length} companies`);\n\nreturn [{\n  json: {\n    _social_discovery_queries: searchQueries,\n    _count: searchQueries.length,\n    _no_social_discovery_needed: false\n  }\n}];"
        },
        "id": "a51849ff-dd51-4d07-8412-227e5088f00d",
        "name": "Build Social Discovery Batch",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          -2896,
          560
        ]
      },
      {
        "parameters": {
          "conditions": {
            "options": {
              "caseSensitive": true,
              "leftValue": "",
              "typeValidation": "loose"
            },
            "conditions": [
              {
                "id": "has-queries",
                "leftValue": "={{ $json._no_social_discovery_needed }}",
                "rightValue": true,
                "operator": {
                  "type": "boolean",
                  "operation": "notEquals"
                }
              }
            ],
            "combinator": "and"
          },
          "options": {}
        },
        "id": "648e916d-ca2d-4e54-bcbf-a0fe2bb2a905",
        "name": "Discovery Queries Exist?",
        "type": "n8n-nodes-base.if",
        "typeVersion": 2,
        "position": [
          -2672,
          560
        ]
      },
      {
        "parameters": {
          "jsCode": "// Build the Apify Facebook Search Scraper input\n// Actor: apify/facebook-search-scraper\n// Input fields: categories (array of search terms), locations (array), resultsLimit (number)\nconst data = $input.first().json;\nconst queries = data._social_discovery_queries || [];\n\n// Build category search terms: \"CompanyName City\" for each company\nconst categories = queries.map(q => \n  `${q.company_name} ${q.city}`.trim()\n).slice(0, 100);\n\n// Get unique locations in \"City, State\" format\nconst locations = [...new Set(\n  queries.map(q => `${q.city}, ${q.state}`.trim()).filter(l => l !== ',')\n)];\n\nreturn [{\n  json: {\n    _queries: queries,\n    _apify_input: {\n      categories: categories,\n      locations: locations,\n      resultsLimit: 3\n    }\n  }\n}];"
        },
        "id": "b83c7e7e-e460-43f5-a53f-5b9d143df069",
        "name": "Prepare FB Search Input",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          -2448,
          368
        ]
      },
      {
        "parameters": {
          "method": "POST",
          "url": "=https://api.apify.com/v2/actor-tasks/uplifted_veranda~facebook-search-scraper-task/runs?token={{ $env.APIFY_API_TOKEN }}",
          "sendHeaders": true,
          "headerParameters": {
            "parameters": [
              {
                "name": "Content-Type",
                "value": "application/json"
              }
            ]
          },
          "sendBody": true,
          "specifyBody": "json",
          "jsonBody": "={{ JSON.stringify($json._apify_input) }}",
          "options": {
            "timeout": 30000
          }
        },
        "id": "618804e0-dd9b-40fb-9c93-d7cb851b271c",
        "name": "Start FB Search Run",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.2,
        "position": [
          -2224,
          368
        ],
        "onError": "continueRegularOutput",
        "notes": "Starts the Apify Facebook Search Scraper actor to find Facebook pages for companies without social links."
      },
      {
        "parameters": {
          "jsCode": "const response = $input.first().json;\nconst queries = $('Prepare FB Search Input').first().json._queries;\nlet runId = '';\nlet datasetId = '';\n\nif (response.data) {\n  runId = response.data.id || '';\n  datasetId = response.data.defaultDatasetId || '';\n}\n\nif (!runId) {\n  console.log('Facebook Search: Failed to start run. Response:', JSON.stringify(response).substring(0, 500));\n  return [{ json: { _fb_search_failed: true, _fb_error: 'Failed to start Apify run', _queries: queries, runId: '', datasetId: '' } }];\n}\n\nreturn [{ json: { runId, datasetId, pollCount: 0, _queries: queries, _fb_search_failed: false } }];"
        },
        "id": "11bb7aa4-8482-4397-811a-27e5c22f530c",
        "name": "Extract FB Run ID",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          -2000,
          368
        ]
      },
      {
        "parameters": {
          "amount": 30
        },
        "id": "e6d428ec-8df0-4e7f-b06f-55f00585e56e",
        "name": "Wait FB 30s",
        "type": "n8n-nodes-base.wait",
        "typeVersion": 1.1,
        "position": [
          -1776,
          368
        ],
        "webhookId": "e1d8796f-0e93-4645-bf79-d1bb08239994"
      },
      {
        "parameters": {
          "url": "=https://api.apify.com/v2/actor-runs/{{ $('Extract FB Run ID').first().json.runId }}?token={{ $env.APIFY_API_TOKEN }}",
          "options": {
            "timeout": 15000
          }
        },
        "id": "331a19fa-7e04-48fc-8f22-1c6177a4e1c2",
        "name": "Check FB Run Status",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.2,
        "position": [
          -1552,
          288
        ]
      },
      {
        "parameters": {
          "jsCode": "const response = $input.first().json;\nconst prevData = $('Extract FB Run ID').first().json;\n\nlet status = 'UNKNOWN';\nlet datasetId = prevData.datasetId || '';\n\nif (response.data && response.data.status) {\n  status = response.data.status;\n  if (response.data.defaultDatasetId) datasetId = response.data.defaultDatasetId;\n}\n\nlet pollCount = 0;\ntry {\n  pollCount = $('Parse FB Status').first().json.pollCount || 0;\n} catch(e) {\n  pollCount = prevData.pollCount || 0;\n}\npollCount++;\n\n// Timeout after 20 polls (10 minutes)\nif (pollCount > 20 && status !== 'SUCCEEDED' && status !== 'FAILED') {\n  status = 'TIMED_OUT';\n}\n\nreturn [{ json: { runId: prevData.runId, datasetId, pollCount, status, _queries: prevData._queries } }];"
        },
        "id": "a9662999-475f-4e3b-8c41-6fc80b66da99",
        "name": "Parse FB Status",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          -1328,
          288
        ]
      },
      {
        "parameters": {
          "conditions": {
            "options": {
              "caseSensitive": true,
              "leftValue": "",
              "typeValidation": "loose"
            },
            "conditions": [
              {
                "id": "fb-succeeded",
                "leftValue": "={{ $json.status }}",
                "rightValue": "SUCCEEDED",
                "operator": {
                  "type": "string",
                  "operation": "equals"
                }
              }
            ],
            "combinator": "and"
          },
          "options": {}
        },
        "id": "3ec5754f-95ca-4bba-8622-98a661019b1f",
        "name": "FB Run Succeeded?",
        "type": "n8n-nodes-base.if",
        "typeVersion": 2,
        "position": [
          -1104,
          368
        ]
      },
      {
        "parameters": {
          "url": "=https://api.apify.com/v2/datasets/{{ $json.datasetId }}/items?token={{ $env.APIFY_API_TOKEN }}",
          "options": {
            "timeout": 60000
          }
        },
        "id": "fe058fde-038b-4047-99e1-f607a4d3a4e5",
        "name": "Fetch FB Search Results",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.2,
        "position": [
          -880,
          368
        ]
      },
      {
        "parameters": {
          "jsCode": "// Match Facebook search results back to companies and build social_profiles rows\nconst results = $input.first().json;\nconst queries = $('Extract FB Run ID').first().json._queries || [];\n\n// results should be an array of Facebook page results\nconst fbPages = Array.isArray(results) ? results : [results];\n\nconst socialRows = [];\nconst matchLog = [];\n\nfor (const query of queries) {\n  const companyNameLower = (query.company_name || '').toLowerCase();\n  const cityLower = (query.city || '').toLowerCase();\n\n  let bestMatch = null;\n  let bestScore = 0;\n\n  for (const page of fbPages) {\n    // FB Search Scraper output fields: title, description, url, address, email, \n    // website, phone, likes, checkins, categories, messenger, adStatus\n    const pageName = (page.title || page.name || '').toLowerCase();\n    const pageAddress = (page.address || '').toLowerCase();\n    const pageDescription = (page.description || '').toLowerCase();\n    \n    // Score based on name similarity\n    const companyWords = companyNameLower.split(/\\s+/).filter(w => w.length > 2);\n    const matchingWords = companyWords.filter(w => pageName.includes(w));\n    let score = companyWords.length > 0 ? matchingWords.length / companyWords.length : 0;\n    \n    // Bonus for city match in address or description\n    if (cityLower && (pageAddress.includes(cityLower) || pageDescription.includes(cityLower))) {\n      score += 0.2;\n    }\n    \n    // Bonus for massage/spa/therapy keywords\n    const relevantKeywords = ['massage', 'spa', 'therapy', 'therapist', 'bodywork', 'wellness'];\n    const pageText = `${pageName} ${pageDescription} ${(page.categories || []).join(' ')}`.toLowerCase();\n    if (relevantKeywords.some(kw => pageText.includes(kw))) {\n      score += 0.15;\n    }\n    \n    if (score > bestScore && score >= 0.5) {\n      bestScore = score;\n      bestMatch = page;\n    }\n  }\n\n  if (bestMatch) {\n    const pageUrl = bestMatch.url || bestMatch.facebookUrl || '';\n    if (pageUrl) {\n      socialRows.push({\n        company_id: query.company_id,\n        platform: 'facebook',\n        profile_url: pageUrl,\n        follower_count: bestMatch.likes || bestMatch.followers || null,\n        post_count: null,\n        last_post_date: null,\n        scraped_at: new Date().toISOString()\n      });\n      matchLog.push({ \n        company: query.company_name, \n        matched_to: bestMatch.title || bestMatch.name, \n        score: bestScore,\n        fb_url: pageUrl\n      });\n    }\n  }\n}\n\nconsole.log(`Facebook discovery: ${socialRows.length} matches from ${fbPages.length} results for ${queries.length} queries`);\n\nreturn [{\n  json: {\n    _fb_social_rows: socialRows,\n    _fb_match_count: socialRows.length,\n    _fb_total_results: fbPages.length,\n    _match_log: matchLog\n  }\n}];"
        },
        "id": "f38c97f4-5519-4234-8877-4fc51d2af24a",
        "name": "Match FB Results to Companies",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          -656,
          368
        ]
      },
      {
        "parameters": {
          "conditions": {
            "options": {
              "caseSensitive": true,
              "leftValue": "",
              "typeValidation": "loose"
            },
            "conditions": [
              {
                "id": "has-fb-results",
                "leftValue": "={{ $json._fb_match_count }}",
                "rightValue": "0",
                "operator": {
                  "type": "number",
                  "operation": "gt"
                }
              }
            ],
            "combinator": "and"
          },
          "options": {}
        },
        "id": "8e8275ce-a89c-4e91-b4bc-1fabb85b4577",
        "name": "FB Matches Found?",
        "type": "n8n-nodes-base.if",
        "typeVersion": 2,
        "position": [
          -432,
          368
        ]
      },
      {
        "parameters": {
          "method": "POST",
          "url": "={{ $env.SUPABASE_URL }}/rest/v1/social_profiles",
          "sendHeaders": true,
          "headerParameters": {
            "parameters": [
              {
                "name": "apikey",
                "value": "={{ $env.SUPABASE_SERVICE_KEY }}"
              },
              {
                "name": "Authorization",
                "value": "=Bearer {{ $env.SUPABASE_SERVICE_KEY }}"
              },
              {
                "name": "Content-Type",
                "value": "application/json"
              },
              {
                "name": "Prefer",
                "value": "resolution=merge-duplicates,return=minimal"
              }
            ]
          },
          "sendBody": true,
          "specifyBody": "json",
          "jsonBody": "={{ JSON.stringify($json._fb_social_rows) }}",
          "options": {}
        },
        "id": "ecff84ca-7e3d-428f-ad89-236f5e0d9698",
        "name": "Insert FB Social Profiles",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.2,
        "position": [
          -208,
          288
        ],
        "onError": "continueRegularOutput"
      },
      {
        "parameters": {
          "jsCode": "// Build the Apify Instagram Search Scraper input\n// Actor: apify/instagram-search-scraper\n// Input fields: search (single string), searchType (string), searchLimit (number),\n//               enhanceUserSearchWithFacebookPage (boolean)\n//\n// LIMITATION: IG Search Scraper takes ONE search string per run.\n// Strategy: We search for \"massage therapy [city] [state]\" to find local businesses,\n// then match results back to individual companies.\nconst data = $input.first().json;\nconst queries = data._social_discovery_queries || [];\n\nif (queries.length === 0) {\n  return [{ json: { _queries: queries, _apify_input: {}, _ig_skip: true } }];\n}\n\n// Get the most common city from the batch (they're likely all the same metro)\nconst cityCounts = {};\nfor (const q of queries) {\n  const loc = `${q.city} ${q.state}`.trim();\n  cityCounts[loc] = (cityCounts[loc] || 0) + 1;\n}\nconst primaryCity = Object.entries(cityCounts).sort((a, b) => b[1] - a[1])[0][0];\n\nreturn [{\n  json: {\n    _queries: queries,\n    _apify_input: {\n      search: `massage therapy ${primaryCity}`,\n      searchType: \"user\",\n      searchLimit: Math.min(queries.length * 2, 50),\n      enhanceUserSearchWithFacebookPage: false\n    },\n    _ig_skip: false\n  }\n}];"
        },
        "id": "07ffe709-bd8d-4a1a-835d-8f4ecf6e0516",
        "name": "Prepare IG Search Input",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          -2448,
          768
        ]
      },
      {
        "parameters": {
          "method": "POST",
          "url": "=https://api.apify.com/v2/actor-tasks/uplifted_veranda~instagram-search-scraper-task/runs?token={{ $env.APIFY_API_TOKEN }}",
          "sendHeaders": true,
          "headerParameters": {
            "parameters": [
              {
                "name": "Content-Type",
                "value": "application/json"
              }
            ]
          },
          "sendBody": true,
          "specifyBody": "json",
          "jsonBody": "={{ JSON.stringify($json._apify_input) }}",
          "options": {
            "timeout": 30000
          }
        },
        "id": "dc2c0c09-619b-4e41-a8a9-9a8222d36d17",
        "name": "Start IG Search Run",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.2,
        "position": [
          -2224,
          768
        ],
        "onError": "continueRegularOutput",
        "notes": "Starts the Apify Instagram Search Scraper actor to discover Instagram profiles."
      },
      {
        "parameters": {
          "jsCode": "const response = $input.first().json;\nconst prevInput = $('Prepare IG Search Input').first().json;\nconst queries = prevInput._queries;\n\n// If we skipped IG search\nif (prevInput._ig_skip) {\n  return [{ json: { _ig_search_failed: true, _ig_error: 'No queries - skipped', _queries: queries, runId: '', datasetId: '' } }];\n}\n\nlet runId = '';\nlet datasetId = '';\n\nif (response.data) {\n  runId = response.data.id || '';\n  datasetId = response.data.defaultDatasetId || '';\n}\n\nif (!runId) {\n  console.log('Instagram Search: Failed to start run. Response:', JSON.stringify(response).substring(0, 500));\n  return [{ json: { _ig_search_failed: true, _ig_error: 'Failed to start Apify run', _queries: queries, runId: '', datasetId: '' } }];\n}\n\nreturn [{ json: { runId, datasetId, pollCount: 0, _queries: queries, _ig_search_failed: false } }];"
        },
        "id": "6111a6c3-a138-4910-b799-9303a0e9f511",
        "name": "Extract IG Run ID",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          -2000,
          768
        ]
      },
      {
        "parameters": {
          "amount": 30
        },
        "id": "c512e75a-b7d5-4c4a-b944-3ad81a568191",
        "name": "Wait IG 30s",
        "type": "n8n-nodes-base.wait",
        "typeVersion": 1.1,
        "position": [
          -1776,
          768
        ],
        "webhookId": "a4c07964-b9f7-418a-9217-471299bbaa53"
      },
      {
        "parameters": {
          "url": "=https://api.apify.com/v2/actor-runs/{{ $('Extract IG Run ID').first().json.runId }}?token={{ $env.APIFY_API_TOKEN }}",
          "options": {
            "timeout": 15000
          }
        },
        "id": "8daea210-10b2-44bb-8820-408888bcbb62",
        "name": "Check IG Run Status",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.2,
        "position": [
          -1552,
          704
        ]
      },
      {
        "parameters": {
          "jsCode": "const response = $input.first().json;\nconst prevData = $('Extract IG Run ID').first().json;\n\nlet status = 'UNKNOWN';\nlet datasetId = prevData.datasetId || '';\n\nif (response.data && response.data.status) {\n  status = response.data.status;\n  if (response.data.defaultDatasetId) datasetId = response.data.defaultDatasetId;\n}\n\nlet pollCount = 0;\ntry {\n  pollCount = $('Parse IG Status').first().json.pollCount || 0;\n} catch(e) {\n  pollCount = prevData.pollCount || 0;\n}\npollCount++;\n\nif (pollCount > 20 && status !== 'SUCCEEDED' && status !== 'FAILED') {\n  status = 'TIMED_OUT';\n}\n\nreturn [{ json: { runId: prevData.runId, datasetId, pollCount, status, _queries: prevData._queries } }];"
        },
        "id": "06bbd7b4-b14e-49da-a5e1-a7852ee42db9",
        "name": "Parse IG Status",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          -1328,
          704
        ]
      },
      {
        "parameters": {
          "conditions": {
            "options": {
              "caseSensitive": true,
              "leftValue": "",
              "typeValidation": "loose"
            },
            "conditions": [
              {
                "id": "ig-succeeded",
                "leftValue": "={{ $json.status }}",
                "rightValue": "SUCCEEDED",
                "operator": {
                  "type": "string",
                  "operation": "equals"
                }
              }
            ],
            "combinator": "and"
          },
          "options": {}
        },
        "id": "cd7738b4-5846-4b33-b42c-16c57376b4d9",
        "name": "IG Run Succeeded?",
        "type": "n8n-nodes-base.if",
        "typeVersion": 2,
        "position": [
          -1104,
          768
        ]
      },
      {
        "parameters": {
          "url": "=https://api.apify.com/v2/datasets/{{ $json.datasetId }}/items?token={{ $env.APIFY_API_TOKEN }}",
          "options": {
            "timeout": 60000
          }
        },
        "id": "d805fc7a-6c73-415f-b351-2607899dd6ab",
        "name": "Fetch IG Search Results",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.2,
        "position": [
          -880,
          768
        ]
      },
      {
        "parameters": {
          "jsCode": "// Match Instagram search results back to companies\nconst results = $input.first().json;\nconst queries = $('Extract IG Run ID').first().json._queries || [];\n\n// IG Search Scraper returns profiles with fields like:\n// username, fullName, biography, followersCount, followsCount, \n// postsCount, isBusinessAccount, profilePicUrl, externalUrl, etc.\nconst igProfiles = Array.isArray(results) ? results : [results];\n\nconst socialRows = [];\nconst matchLog = [];\n\nfor (const query of queries) {\n  const companyNameLower = (query.company_name || '').toLowerCase().replace(/[^a-z0-9\\s]/g, '');\n  const cityLower = (query.city || '').toLowerCase();\n\n  let bestMatch = null;\n  let bestScore = 0;\n\n  for (const profile of igProfiles) {\n    const profileName = (profile.fullName || profile.name || '').toLowerCase().replace(/[^a-z0-9\\s]/g, '');\n    const profileBio = (profile.biography || profile.bio || '').toLowerCase();\n    const username = (profile.username || '').toLowerCase();\n    \n    // Score based on name similarity\n    const companyWords = companyNameLower.split(/\\s+/).filter(w => w.length > 2);\n    const matchingWords = companyWords.filter(w => \n      profileName.includes(w) || username.includes(w)\n    );\n    let score = companyWords.length > 0 ? matchingWords.length / companyWords.length : 0;\n    \n    // Bonus for city mention in bio\n    if (cityLower && profileBio.includes(cityLower)) score += 0.2;\n    \n    // Bonus for massage/spa/therapy keywords in bio or name\n    const relevantKeywords = ['massage', 'spa', 'therapy', 'therapist', 'bodywork', 'wellness', 'rmt'];\n    if (relevantKeywords.some(kw => profileBio.includes(kw) || profileName.includes(kw))) score += 0.15;\n    \n    // Bonus for business account\n    const isBusinessAccount = profile.isBusinessAccount || profile.isBusiness || false;\n    if (isBusinessAccount) score += 0.1;\n    \n    if (score > bestScore && score >= 0.5) {\n      bestScore = score;\n      bestMatch = profile;\n    }\n  }\n\n  if (bestMatch) {\n    const profileUrl = bestMatch.url || bestMatch.profileUrl || \n      (bestMatch.username ? `https://www.instagram.com/${bestMatch.username}` : '');\n    \n    if (profileUrl) {\n      socialRows.push({\n        company_id: query.company_id,\n        platform: 'instagram',\n        profile_url: profileUrl,\n        follower_count: bestMatch.followersCount || bestMatch.followers || null,\n        post_count: bestMatch.postsCount || bestMatch.posts || null,\n        last_post_date: null,\n        scraped_at: new Date().toISOString()\n      });\n      matchLog.push({ \n        company: query.company_name, \n        matched_to: bestMatch.username || bestMatch.fullName, \n        score: bestScore \n      });\n    }\n  }\n}\n\nconsole.log(`Instagram discovery: ${socialRows.length} matches from ${igProfiles.length} results for ${queries.length} queries`);\n\nreturn [{\n  json: {\n    _ig_social_rows: socialRows,\n    _ig_match_count: socialRows.length,\n    _ig_total_results: igProfiles.length,\n    _match_log: matchLog\n  }\n}];"
        },
        "id": "ba2a1c03-8e73-449e-9fa4-98d1c404b18c",
        "name": "Match IG Results to Companies",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          -656,
          768
        ]
      },
      {
        "parameters": {
          "conditions": {
            "options": {
              "caseSensitive": true,
              "leftValue": "",
              "typeValidation": "loose"
            },
            "conditions": [
              {
                "id": "has-ig-results",
                "leftValue": "={{ $json._ig_match_count }}",
                "rightValue": "0",
                "operator": {
                  "type": "number",
                  "operation": "gt"
                }
              }
            ],
            "combinator": "and"
          },
          "options": {}
        },
        "id": "84b243fa-2ecb-4b93-9078-21e3a1d267d9",
        "name": "IG Matches Found?",
        "type": "n8n-nodes-base.if",
        "typeVersion": 2,
        "position": [
          -432,
          768
        ]
      },
      {
        "parameters": {
          "method": "POST",
          "url": "={{ $env.SUPABASE_URL }}/rest/v1/social_profiles",
          "sendHeaders": true,
          "headerParameters": {
            "parameters": [
              {
                "name": "apikey",
                "value": "={{ $env.SUPABASE_SERVICE_KEY }}"
              },
              {
                "name": "Authorization",
                "value": "=Bearer {{ $env.SUPABASE_SERVICE_KEY }}"
              },
              {
                "name": "Content-Type",
                "value": "application/json"
              },
              {
                "name": "Prefer",
                "value": "resolution=merge-duplicates,return=minimal"
              }
            ]
          },
          "sendBody": true,
          "specifyBody": "json",
          "jsonBody": "={{ JSON.stringify($json._ig_social_rows) }}",
          "options": {}
        },
        "id": "6a6ed64e-9e32-4808-a6bb-19dd17be9892",
        "name": "Insert IG Social Profiles",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.2,
        "position": [
          -208,
          848
        ],
        "onError": "continueRegularOutput"
      },
      {
        "parameters": {
          "jsCode": "// Final summary of the enrichment batch run\nconst config = $('Enrichment Config').first().json;\n\n// Collect stats from various paths\nlet companiesProcessed = 0;\nlet websitesFetched = 0;\nlet websiteErrors = 0;\nlet bookingDetected = 0;\nlet paidAdsDetected = 0;\nlet socialFromWebsite = 0;\nlet fbDiscovered = 0;\nlet igDiscovered = 0;\n\ntry {\n  const batchItems = $('Parse Batch').all();\n  companiesProcessed = batchItems.filter(i => !i.json._empty).length;\n} catch(e) {}\n\ntry {\n  const websiteItems = $('Analyze Website HTML').all();\n  for (const item of websiteItems) {\n    const enrichment = item.json._website_enrichment || {};\n    if (enrichment._website_fetch_status === 'success') websitesFetched++;\n    if (enrichment._website_fetch_status === 'error') websiteErrors++;\n    if (enrichment.has_online_booking) bookingDetected++;\n    if (enrichment.has_paid_ads) paidAdsDetected++;\n    socialFromWebsite += (enrichment.social_links_found || []).length;\n  }\n} catch(e) {}\n\ntry {\n  const fbResults = $('Match FB Results to Companies').first().json;\n  fbDiscovered = fbResults._fb_match_count || 0;\n} catch(e) {}\n\ntry {\n  const igResults = $('Match IG Results to Companies').first().json;\n  igDiscovered = igResults._ig_match_count || 0;\n} catch(e) {}\n\nconst summary = {\n  run_completed_at: new Date().toISOString(),\n  batch_size: config.batch_size,\n  batch_offset: config.batch_offset,\n  companies_processed: companiesProcessed,\n  websites_fetched_successfully: websitesFetched,\n  website_fetch_errors: websiteErrors,\n  booking_platforms_detected: bookingDetected,\n  paid_ads_detected: paidAdsDetected,\n  social_links_from_websites: socialFromWebsite,\n  facebook_pages_discovered: fbDiscovered,\n  instagram_profiles_discovered: igDiscovered,\n  total_social_profiles_created: socialFromWebsite + fbDiscovered + igDiscovered,\n  next_offset: Number(config.batch_offset) + Number(config.batch_size),\n  message: `Enriched ${companiesProcessed} companies. Update batch_offset to ${Number(config.batch_offset) + Number(config.batch_size)} for next run.`\n};\n\nconsole.log('=== ENRICHMENT RUN SUMMARY ===');\nconsole.log(JSON.stringify(summary, null, 2));\n\nreturn [{ json: summary }];"
        },
        "id": "47056c12-3c0f-4263-a32e-307da26ff9e5",
        "name": "Run Summary1",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          16,
          432
        ],
        "notes": "Final summary of the enrichment batch. Shows stats for websites analyzed, booking/ads detected, social profiles found. Provides next_offset for continuing with next batch."
      },
      {
        "parameters": {
          "assignments": {
            "assignments": [
              {
                "id": "batch-size",
                "name": "batch_size",
                "value": "100",
                "type": "string"
              },
              {
                "id": "batch-offset",
                "name": "batch_offset",
                "value": "0",
                "type": "string"
              },
              {
                "id": "skip-instagram",
                "name": "skip_instagram",
                "value": "true",
                "type": "string"
              },
              {
                "id": "skip-facebook",
                "name": "skip_facebook",
                "value": "true",
                "type": "string"
              },
              {
                "id": "skip-tiktok",
                "name": "skip_tiktok",
                "value": "true",
                "type": "string"
              },
              {
                "id": "skip-twitter",
                "name": "skip_twitter",
                "value": "true",
                "type": "string"
              },
              {
                "id": "skip-linkedin",
                "name": "skip_linkedin",
                "value": "true",
                "type": "string"
              },
              {
                "id": "skip-youtube",
                "name": "skip_youtube",
                "value": "true",
                "type": "string"
              }
            ]
          },
          "options": {}
        },
        "id": "03f635b7-5fb7-47b0-b0de-20be39e9d0d5",
        "name": "Step 3b Config",
        "type": "n8n-nodes-base.set",
        "typeVersion": 3.4,
        "position": [
          448,
          432
        ],
        "notes": "CONFIGURE: batch_size = how many social profiles to process. Set skip_<platform> to 'true' to skip that platform."
      },
      {
        "parameters": {
          "url": "={{ $env.SUPABASE_URL }}/rest/v1/social_profiles?follower_count=is.null&order=scraped_at.asc&limit={{ $json.batch_size }}&offset={{ $json.batch_offset }}&select=id,company_id,platform,profile_url,follower_count,post_count,last_post_date,scraped_at",
          "sendHeaders": true,
          "headerParameters": {
            "parameters": [
              {
                "name": "apikey",
                "value": "={{ $env.SUPABASE_SERVICE_KEY }}"
              },
              {
                "name": "Authorization",
                "value": "=Bearer {{ $env.SUPABASE_SERVICE_KEY }}"
              }
            ]
          },
          "options": {
            "timeout": 30000
          }
        },
        "id": "dacf43aa-0530-45b3-b9a5-b97f4f84ec65",
        "name": "Fetch Unenriched Social Profiles",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.2,
        "position": [
          672,
          432
        ],
        "notes": "Fetches social_profiles rows where follower_count is NULL (not yet enriched by SociaVault).",
        "alwaysOutputData": true
      },
      {
        "parameters": {
          "jsCode": "const items = $input.all();\nconst results = [];\nconst config = $('Step 3b Config').first().json;\nconst baseUrl = 'https://api.sociavault.com/v1/scrape';\n\nconst skipMap = {\n  instagram: config.skip_instagram,\n  facebook: config.skip_facebook,\n  tiktok: config.skip_tiktok,\n  x: config.skip_twitter,\n  twitter: config.skip_twitter,\n  linkedin: config.skip_linkedin,\n  youtube: config.skip_youtube\n};\n\nconst invalidHandles = [\n  'sharer', 'share', 'intent', 'login', 'help', 'about', 'policies', 'privacy',\n  'hashtag', 'explore', 'watch', 'results', 'search',\n  // Facebook non-profile paths (tracking pixels, SDK, plugins, etc.)\n  'tr', 'flx', 'plugins', 'dialog', 'ajax', 'ads', 'business', 'events',\n  'groups', 'marketplace', 'gaming', 'watch', 'reels', 'stories'\n];\n\nfor (const entry of items) {\n  const profile = entry.json;\n  const platform = (profile.platform || '').toLowerCase();\n  const url = (profile.profile_url || '').trim();\n\n  const shouldSkip = skipMap[platform] === 'true' || skipMap[platform] === true;\n  if (shouldSkip) {\n    results.push({ json: { ...profile, _skip: true, _skip_reason: `Platform ${platform} disabled`, _sociavault_url: '', _extracted_handle: '' } });\n    continue;\n  }\n\n  let handle = '';\n  try {\n    if (platform === 'instagram') {\n      const match = url.match(/instagram\\.com\\/([a-zA-Z0-9._]+)/i);\n      if (match) handle = match[1];\n    } else if (platform === 'facebook') {\n      const profileIdMatch = url.match(/profile\\.php\\?id=(\\d+)/);\n      if (profileIdMatch) {\n        handle = profileIdMatch[1];\n      } else {\n        const match = url.match(/facebook\\.com\\/([a-zA-Z0-9._-]+)/i);\n        if (match) handle = match[1];\n      }\n    } else if (platform === 'tiktok') {\n      const match = url.match(/tiktok\\.com\\/@([a-zA-Z0-9._-]+)/i);\n      if (match) handle = match[1];\n    } else if (platform === 'x' || platform === 'twitter') {\n      const match = url.match(/(?:twitter|x)\\.com\\/([a-zA-Z0-9_]+)/i);\n      if (match) handle = match[1];\n    } else if (platform === 'linkedin') {\n      const companyMatch = url.match(/linkedin\\.com\\/company\\/([a-zA-Z0-9._-]+)/i);\n      const personMatch = url.match(/linkedin\\.com\\/in\\/([a-zA-Z0-9._-]+)/i);\n      handle = companyMatch ? companyMatch[1] : (personMatch ? personMatch[1] : '');\n    } else if (platform === 'youtube') {\n      const handleMatch = url.match(/youtube\\.com\\/@([a-zA-Z0-9._-]+)/i);\n      const channelMatch = url.match(/youtube\\.com\\/channel\\/([a-zA-Z0-9_-]+)/i);\n      const cMatch = url.match(/youtube\\.com\\/c\\/([a-zA-Z0-9._-]+)/i);\n      handle = handleMatch ? handleMatch[1] : (channelMatch ? channelMatch[1] : (cMatch ? cMatch[1] : ''));\n    }\n  } catch (e) {}\n\n  if (invalidHandles.includes(handle.toLowerCase())) handle = '';\n\n  if (!handle) {\n    results.push({ json: { ...profile, _skip: true, _skip_reason: `Could not extract handle from URL: ${url}`, _sociavault_url: '', _extracted_handle: '' } });\n    continue;\n  }\n\n  let sociavaultUrl = '';\n  if (platform === 'instagram') {\n    sociavaultUrl = `${baseUrl}/instagram/profile?handle=${encodeURIComponent(handle)}`;\n  } else if (platform === 'facebook') {\n    // Facebook endpoint requires the full profile URL with https://\n    let fbUrl = url;\n    if (!fbUrl.startsWith('http')) {\n      fbUrl = 'https://' + fbUrl;\n    }\n    // Ensure https (not http)\n    fbUrl = fbUrl.replace(/^http:\\/\\//, 'https://');\n    sociavaultUrl = `${baseUrl}/facebook/profile?url=${encodeURIComponent(fbUrl)}`;\n  } else if (platform === 'tiktok') {\n    sociavaultUrl = `${baseUrl}/tiktok/profile?handle=${encodeURIComponent(handle)}`;\n  } else if (platform === 'x' || platform === 'twitter') {\n    sociavaultUrl = `${baseUrl}/twitter/profile?handle=${encodeURIComponent(handle)}`;\n  } else if (platform === 'linkedin') {\n    const isCompany = url.includes('/company/');\n    sociavaultUrl = isCompany\n      ? `${baseUrl}/linkedin/company?username=${encodeURIComponent(handle)}`\n      : `${baseUrl}/linkedin/profile?username=${encodeURIComponent(handle)}`;\n  } else if (platform === 'youtube') {\n    const isChannelId = handle.startsWith('UC');\n    sociavaultUrl = isChannelId\n      ? `${baseUrl}/youtube/channel?channel_id=${encodeURIComponent(handle)}`\n      : `${baseUrl}/youtube/channel?handle=${encodeURIComponent(handle)}`;\n  }\n\n  if (!sociavaultUrl) {\n    results.push({ json: { ...profile, _skip: true, _skip_reason: `Unsupported platform: ${platform}`, _sociavault_url: '', _extracted_handle: handle } });\n    continue;\n  }\n\n  results.push({ json: { ...profile, _skip: false, _skip_reason: null, _sociavault_url: sociavaultUrl, _extracted_handle: handle, _platform: platform } });\n}\n\nreturn results;"
        },
        "id": "cf4e0257-cfc4-44e6-8364-d7c36d5aa120",
        "name": "Build SociaVault Request",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          1344,
          528
        ],
        "notes": "Extracts username/handle from profile_url, builds SociaVault API URL per platform. Skips unparseable profiles."
      },
      {
        "parameters": {
          "conditions": {
            "options": {
              "caseSensitive": true,
              "leftValue": "",
              "typeValidation": "loose"
            },
            "conditions": [
              {
                "id": "should-skip",
                "leftValue": "={{ $json._skip }}",
                "rightValue": true,
                "operator": {
                  "type": "boolean",
                  "operation": "notEquals"
                }
              }
            ],
            "combinator": "and"
          },
          "options": {}
        },
        "id": "ea99682f-2982-4a5f-9a54-9edd80bcbe6e",
        "name": "Should Enrich?",
        "type": "n8n-nodes-base.if",
        "typeVersion": 2,
        "position": [
          1568,
          528
        ]
      },
      {
        "parameters": {
          "url": "={{ $json._sociavault_url }}",
          "sendHeaders": true,
          "headerParameters": {
            "parameters": [
              {
                "name": "X-API-Key",
                "value": "={{ $env.SOCIAVAULT_API_KEY }}"
              }
            ]
          },
          "options": {
            "batching": {
              "batch": {
                "batchSize": 5,
                "batchInterval": 2000
              }
            },
            "timeout": 30000
          }
        },
        "id": "ab74e793-f3e6-4b75-a1ec-4123a3e069d4",
        "name": "Call SociaVault API",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.2,
        "position": [
          1792,
          464
        ],
        "onError": "continueRegularOutput",
        "notes": "Calls SociaVault profile endpoint. Batched 5 at a time with 2s delay. On error, continues."
      },
      {
        "parameters": {
          "jsCode": "// runOnceForAllItems \u2014 index-paired with Should Enrich?\nconst upstreamAll = $('Should Enrich?').all();\nconst inputAll = $input.all();\nconst results = [];\n\nfor (let i = 0; i < inputAll.length; i++) {\n  const response = inputAll[i].json;\n  const profileData = upstreamAll[i].json;\n  const platform = profileData._platform;\n  const profileId = profileData.id;\n  const companyId = profileData.company_id;\n  let follower_count = null;\n  let post_count = null;\n  let last_post_date = null;\n  let fetchStatus = 'success';\n  let errorMsg = null;\n  try {\n    if (response.error || response.status === 'error' || response.success === false) {\n      fetchStatus = 'error';\n      errorMsg = response.error || response.message || 'API returned error';\n    } else if (platform === 'instagram') {\n      const user = response.data?.data?.user || response.data?.user || response.user || response.data || {};\n      follower_count = user.edge_followed_by?.count ?? user.follower_count ?? user.followers_count ?? null;\n      post_count = user.edge_owner_to_timeline_media?.count ?? user.media_count ?? null;\n      const edges = user.edge_owner_to_timeline_media?.edges || [];\n      const edgeArray = Array.isArray(edges) ? edges : Object.values(edges);\n      if (edgeArray.length > 0) {\n        const firstPost = edgeArray[0]?.node || edgeArray[0] || {};\n        if (firstPost.taken_at) {\n          last_post_date = new Date(firstPost.taken_at * 1000).toISOString().split('T')[0];\n        }\n      }\n    } else if (platform === 'facebook') {\n      const data = response.data || response;\n      follower_count = data.followerCount ?? data.follower_count ?? data.followers_count ?? data.likes ?? data.likeCount ?? data.fan_count ?? null;\n      post_count = data.posts_count ?? data.postCount ?? null;\n    } else if (platform === 'tiktok') {\n      const stats = response.data?.userInfo?.stats || response.data?.stats || {};\n      const user = response.data?.userInfo?.user || response.data?.user || response.data || response;\n      follower_count = stats.followerCount ?? user.followerCount ?? user.followers_count ?? null;\n      post_count = stats.videoCount ?? user.videoCount ?? null;\n    } else if (platform === 'x' || platform === 'twitter') {\n      const data = response.data || {};\n      const legacy = data.legacy || {};\n      const user = data.user || data;\n      follower_count = legacy.followers_count ?? legacy.normal_followers_count ?? user.followers_count ?? user.followerCount ?? user.public_metrics?.followers_count ?? null;\n      post_count = legacy.statuses_count ?? user.statuses_count ?? user.tweet_count ?? user.public_metrics?.tweet_count ?? null;\n      if (data.message === \"Account doesn't exist\" || data.userId === null && data.handle) {\n        fetchStatus = 'not_found';\n        errorMsg = `Account @${data.handle} does not exist`;\n        follower_count = null;\n        post_count = null;\n      }\n      if (user.status?.created_at) {\n        try { last_post_date = new Date(user.status.created_at).toISOString().split('T')[0]; } catch(e) {}\n      }\n    } else if (platform === 'linkedin') {\n      const data = response.data || response;\n      follower_count = data.followerCount ?? data.followers_count ?? data.followersCount ?? null;\n    } else if (platform === 'youtube') {\n      const data = response.data || response;\n      follower_count = data.subscriberCount ?? data.subscriber_count ?? data.statistics?.subscriberCount ?? null;\n      post_count = data.videoCount ?? data.video_count ?? data.statistics?.videoCount ?? null;\n      if (typeof follower_count === 'string') follower_count = parseInt(follower_count, 10);\n      if (typeof post_count === 'string') post_count = parseInt(post_count, 10);\n    }\n    if (follower_count !== null) follower_count = Number(follower_count) || null;\n    if (post_count !== null) post_count = Number(post_count) || null;\n  } catch (e) {\n    fetchStatus = 'error';\n    errorMsg = 'Parse error: ' + e.message;\n  }\n  results.push({ json: { _profile_id: profileId, _company_id: companyId, _platform: platform, _extracted_handle: profileData._extracted_handle, _fetch_status: fetchStatus, _error: errorMsg, _update_payload: { follower_count, post_count, last_post_date, scraped_at: new Date().toISOString() } } });\n}\n\nreturn results;"
        },
        "id": "272a14b7-7dde-4a86-8f25-f93ab3f05a59",
        "name": "Parse SociaVault Response",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          2016,
          464
        ],
        "notes": "Extracts follower_count, post_count, last_post_date from SociaVault response per platform."
      },
      {
        "parameters": {
          "method": "PATCH",
          "url": "={{ $env.SUPABASE_URL }}/rest/v1/social_profiles?id=eq.{{ $json._profile_id }}",
          "sendHeaders": true,
          "headerParameters": {
            "parameters": [
              {
                "name": "apikey",
                "value": "={{ $env.SUPABASE_SERVICE_KEY }}"
              },
              {
                "name": "Authorization",
                "value": "=Bearer {{ $env.SUPABASE_SERVICE_KEY }}"
              },
              {
                "name": "Content-Type",
                "value": "application/json"
              },
              {
                "name": "Prefer",
                "value": "return=minimal"
              }
            ]
          },
          "sendBody": true,
          "specifyBody": "json",
          "jsonBody": "={{ JSON.stringify($json._update_payload) }}",
          "options": {
            "batching": {
              "batch": {
                "batchSize": 10,
                "batchInterval": 500
              }
            }
          }
        },
        "id": "351b351e-22fe-4756-bd35-c2816fb2bb41",
        "name": "Update Social Profile in Supabase",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.2,
        "position": [
          2240,
          464
        ],
        "onError": "continueRegularOutput",
        "notes": "PATCH updates social_profiles row. Batched 10 at a time with 500ms delay."
      },
      {
        "parameters": {
          "jsCode": "const allInputs = $input.all();\nlet profiles = [];\n\nif (allInputs.length === 1 && Array.isArray(allInputs[0].json)) {\n  profiles = allInputs[0].json;\n} else {\n  profiles = allInputs.map(i => i.json);\n}\n\nif (!profiles || profiles.length === 0 || (profiles.length === 1 && !profiles[0].id)) {\n  return [{ json: { _empty: true, _count: 0, _message: 'No unenriched social profiles found' } }];\n}\n\nconsole.log('Batch loaded: ' + profiles.length + ' social profiles to enrich');\nreturn profiles.map(p => ({ json: p }));"
        },
        "id": "b839fab2-2974-4430-96a9-bacc19c88368",
        "name": "Parse Batch1",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          896,
          432
        ]
      },
      {
        "parameters": {
          "conditions": {
            "options": {
              "caseSensitive": true,
              "leftValue": "",
              "typeValidation": "loose"
            },
            "conditions": [
              {
                "id": "empty-check",
                "leftValue": "={{ $json._empty }}",
                "rightValue": true,
                "operator": {
                  "type": "boolean",
                  "operation": "equals",
                  "singleValue": true
                }
              }
            ],
            "combinator": "and"
          },
          "options": {}
        },
        "id": "ed584da2-06d7-42e6-a032-b508e58c7074",
        "name": "Batch Empty?1",
        "type": "n8n-nodes-base.if",
        "typeVersion": 2,
        "position": [
          1120,
          432
        ]
      },
      {
        "parameters": {
          "jsCode": "return [{ json: { message: 'No unenriched social profiles found. Step 3b complete.', completed_at: new Date().toISOString() } }];"
        },
        "id": "f670d029-36b1-4113-94ae-b424d050ced6",
        "name": "No Records - Done1",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          1344,
          336
        ]
      },
      {
        "parameters": {
          "jsCode": "const config = $('Step 3b Config').first().json;\nlet totalProcessed = 0, enriched = 0, errors = 0, skipped = 0;\nconst platformCounts = {};\nconst errorDetails = [];\n\ntry {\n  const allItems = $('Build SociaVault Request').all();\n  totalProcessed = allItems.length;\n  skipped = allItems.filter(i => i.json._skip === true).length;\n} catch(e) {}\n\ntry {\n  const results = $('Parse SociaVault Response').all();\n  for (const item of results) {\n    const data = item.json;\n    const platform = data._platform || 'unknown';\n    if (!platformCounts[platform]) platformCounts[platform] = { success: 0, error: 0 };\n    if (data._fetch_status === 'error') {\n      errors++;\n      platformCounts[platform].error++;\n      errorDetails.push({ handle: data._extracted_handle, platform: data._platform, error: data._error });\n    } else {\n      enriched++;\n      platformCounts[platform].success++;\n    }\n  }\n} catch(e) {}\n\nconst summary = {\n  run_completed_at: new Date().toISOString(),\n  batch_size: config.batch_size,\n  batch_offset: config.batch_offset,\n  total_profiles_in_batch: totalProcessed,\n  skipped, enriched, errors,\n  platform_breakdown: platformCounts,\n  error_details: errorDetails.slice(0, 10),\n  next_offset: Number(config.batch_offset) + Number(config.batch_size),\n  message: `Enriched ${enriched} social profiles (${errors} errors, ${skipped} skipped).`\n};\n\nconsole.log('=== STEP 3b: SOCIAL ENRICHMENT SUMMARY ===');\nconsole.log(JSON.stringify(summary, null, 2));\nreturn [{ json: summary }];"
        },
        "id": "b6823dfa-63a0-4c3a-827b-824ce9870eac",
        "name": "Run Summary2",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          2464,
          544
        ],
        "notes": "Final summary with per-platform breakdown."
      },
      {
        "parameters": {
          "conditions": {
            "options": {
              "version": 3,
              "leftValue": "",
              "caseSensitive": true,
              "typeValidation": "loose"
            },
            "conditions": [
              {
                "id": "b807db58-4ea5-4a80-893d-18a9609d454a",
                "leftValue": "={{ $json.domain }}",
                "rightValue": "",
                "operator": {
                  "type": "string",
                  "operation": "empty"
                }
              },
              {
                "id": "1650bd01-dca9-4d41-932b-501666c3ff50",
                "leftValue": "={{ $json.has_website }}",
                "rightValue": "true",
                "operator": {
                  "type": "boolean",
                  "operation": "true",
                  "singleValue": true
                }
              }
            ],
            "combinator": "and"
          },
          "options": {}
        },
        "type": "n8n-nodes-base.if",
        "typeVersion": 2.3,
        "position": [
          -6480,
          288
        ],
        "id": "4960eeab-3e4d-4120-b6c1-7901d35c7228",
        "name": "Needs Backfill?"
      },
      {
        "parameters": {
          "method": "POST",
          "url": "https://places.googleapis.com/v1/places:searchText",
          "sendHeaders": true,
          "headerParameters": {
            "parameters": [
              {
                "name": "X-Goog-FieldMask",
                "value": "places.id,places.displayName,places.nationalPhoneNumber,places.internationalPhoneNumber,places.websiteUri,places.rating,places.userRatingCount"
              },
              {
                "name": "X-Goog-Api-Key",
                "value": "={{ $env.GOOGLE_PLACES_API_KEY }}"
              }
            ]
          },
          "sendBody": true,
          "specifyBody": "json",
          "jsonBody": "={\n  \"textQuery\": \"{{ $json.name }} {{ $json.city }} {{ $json.state }}\",\n  \"maxResultCount\": 3\n}",
          "options": {
            "batching": {
              "batch": {
                "batchSize": 5
              }
            }
          }
        },
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.3,
        "position": [
          -6256,
          208
        ],
        "id": "7152cbc1-bc54-4ffc-86a2-5444784f029e",
        "name": "Google Places Lookup",
        "onError": "continueRegularOutput"
      },
      {
        "parameters": {
          "jsCode": "// runOnceForAllItems \u2014 index-paired with Needs Backfill?\nconst upstreamAll = $('Needs Backfill?').all();\nconst inputAll = $input.all();\nconst results = [];\n\n// Hoisted constant\nconst BLOCKED_DOMAINS = ['wixsite.com','wix.com','setmore.com','schedulista.com','glossgenius.com','square.site','genbook.com','jane.app','acuityscheduling.com','mindbodyonline.com','mindbody.io','vagaro.com','fresha.com','schedulicity.com','booksy.com','massagebook.com','noterro.com','clinicsense.com','calendly.com','squarespace.com'];\n\nfor (let i = 0; i < inputAll.length; i++) {\n  const company = upstreamAll[i].json;\n  const response = inputAll[i].json;\n  const places = response.places || [];\n\n  if (places.length === 0) {\n    results.push({ json: { ...company } });\n    continue;\n  }\n\n  const companyName = (company.name || '').toLowerCase().replace(/[^a-z0-9\\s]/g, '');\n  const companyPhone = (company.phone || '').replace(/[^\\d]/g, '');\n\n  let bestMatch = null;\n  let bestScore = 0;\n\n  for (const place of places) {\n    const placeName = ((place.displayName && place.displayName.text) || '').toLowerCase().replace(/[^a-z0-9\\s]/g, '');\n    let score = 0;\n\n    const companyWords = companyName.split(/\\s+/).filter(w => w.length > 2);\n    const placeWords = placeName.split(/\\s+/).filter(w => w.length > 2);\n    const matchingWords = companyWords.filter(w => placeWords.some(pw => pw.includes(w) || w.includes(pw)));\n    score = companyWords.length > 0 ? matchingWords.length / companyWords.length : 0;\n\n    const placePhone = (place.internationalPhoneNumber || place.nationalPhoneNumber || '').replace(/[^\\d]/g, '');\n    if (companyPhone && placePhone && (placePhone.includes(companyPhone.slice(-10)) || companyPhone.includes(placePhone.slice(-10)))) {\n      score += 0.5;\n    }\n\n    if (score > bestScore && score >= 0.4) {\n      bestScore = score;\n      bestMatch = place;\n    }\n  }\n\n  if (!bestMatch) {\n    results.push({ json: { ...company } });\n    continue;\n  }\n\n  const website = bestMatch.websiteUri || '';\n  let domain = null;\n  if (website) {\n    const match = website.match(/^https?:\\/\\/(?:www\\.)?([^\\/]+)/i);\n    if (match) domain = match[1];\n  }\n\n  // Check domain against blocklist\n  let _domain_blocked = false;\n  let _domain_blocked_platform = '';\n  if (domain) {\n    const lowerDomain = domain.toLowerCase();\n    for (const blocked of BLOCKED_DOMAINS) {\n      if (lowerDomain === blocked || lowerDomain.endsWith('.' + blocked)) {\n        _domain_blocked = true;\n        _domain_blocked_platform = blocked;\n        domain = null;\n        break;\n      }\n    }\n  }\n\n  // Merge found data into the company item so downstream nodes see it\n  const updated = { ...company };\n  if (bestMatch.id && !company.google_place_id) updated.google_place_id = bestMatch.id;\n  if (domain) {\n    updated.domain = domain;\n    updated.has_website = true;\n  }\n  if (_domain_blocked) {\n    updated._domain_blocked = true;\n    updated._domain_blocked_platform = _domain_blocked_platform;\n  }\n  if (bestMatch.rating && !company.google_rating) updated.google_rating = bestMatch.rating;\n  if (bestMatch.userRatingCount && !company.google_review_count) updated.google_review_count = bestMatch.userRatingCount;\n\n  // Build Supabase patch payload - only include domain if not blocked\n  const patch = {};\n  if (updated.google_place_id !== company.google_place_id) patch.google_place_id = updated.google_place_id;\n  if (domain) {\n    patch.domain = domain;\n    if (updated.has_website !== company.has_website) patch.has_website = updated.has_website;\n  }\n  if (updated.google_rating !== company.google_rating) patch.google_rating = updated.google_rating;\n  if (updated.google_review_count !== company.google_review_count) patch.google_review_count = updated.google_review_count;\n\n  updated._backfill_patch = Object.keys(patch).length > 0 ? patch : null;\n  updated._backfill_matched = bestMatch.displayName?.text || '';\n  updated._backfill_score = bestScore;\n\n  results.push({ json: updated });\n}\n\nreturn results;"
        },
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          -6032,
          224
        ],
        "id": "6331ba97-df66-4a50-a69b-ec74a0b95843",
        "name": "Extract & Patch Domain"
      },
      {
        "parameters": {},
        "type": "n8n-nodes-base.merge",
        "typeVersion": 3.2,
        "position": [
          -5808,
          288
        ],
        "id": "e225430f-6efa-4b41-a7ea-6b456dce326f",
        "name": "Merge Backfill"
      },
      {
        "parameters": {
          "assignments": {
            "assignments": [
              {
                "id": "batch-size",
                "name": "batch_size",
                "value": "1000",
                "type": "string"
              },
              {
                "id": "batch-offset",
                "name": "batch_offset",
                "value": "0",
                "type": "string"
              },
              {
                "id": "skip-apollo",
                "name": "skip_apollo",
                "value": "false",
                "type": "string"
              },
              {
                "id": "skip-website-scrape",
                "name": "skip_website_scrape",
                "value": "false",
                "type": "string"
              },
              {
                "id": "apollo-enrich-enabled",
                "name": "apollo_enrich_enabled",
                "value": "true",
                "type": "string"
              }
            ]
          },
          "options": {}
        },
        "id": "d6400060-d28a-4b98-8ab9-b5af12f79118",
        "name": "Step 3a Config",
        "type": "n8n-nodes-base.set",
        "typeVersion": 3.4,
        "position": [
          2992,
          528
        ],
        "notes": "CONFIGURE: batch_size = companies per run. skip_apollo/skip_website_scrape to bypass sub-steps. apollo_enrich_enabled = set false to save credits (search only, no enrich)."
      },
      {
        "parameters": {
          "url": "={{ $env.SUPABASE_URL }}/rest/v1/companies?enrichment_status=in.(partially_enriched,fully_enriched)&discovery_metro=eq.{{ $('Metro Config').first().json.metro_name }}&order=lead_score.desc,discovered_at.asc&limit={{ $json.batch_size }}&offset={{ $json.batch_offset }}&select=id,name,phone,domain,address,city,state,country,google_place_id,category,estimated_size,has_website,google_review_count,google_rating",
          "sendHeaders": true,
          "headerParameters": {
            "parameters": [
              {
                "name": "apikey",
                "value": "={{ $env.SUPABASE_SERVICE_KEY }}"
              },
              {
                "name": "Authorization",
                "value": "=Bearer {{ $env.SUPABASE_SERVICE_KEY }}"
              }
            ]
          },
          "options": {
            "timeout": 30000
          }
        },
        "id": "fba4044a-fb9b-49aa-9cec-9fc4f093935d",
        "name": "Fetch Companies",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.2,
        "position": [
          3216,
          528
        ],
        "alwaysOutputData": true
      },
      {
        "parameters": {
          "url": "={{ $env.SUPABASE_URL }}/rest/v1/contacts?select=company_id",
          "sendHeaders": true,
          "headerParameters": {
            "parameters": [
              {
                "name": "apikey",
                "value": "={{ $env.SUPABASE_SERVICE_KEY }}"
              },
              {
                "name": "Authorization",
                "value": "=Bearer {{ $env.SUPABASE_SERVICE_KEY }}"
              }
            ]
          },
          "options": {
            "timeout": 30000
          }
        },
        "id": "5424ae75-5839-4493-8439-c126a74c8321",
        "name": "Fetch Existing Contacts",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.2,
        "position": [
          3440,
          528
        ],
        "alwaysOutputData": true,
        "onError": "continueRegularOutput"
      },
      {
        "parameters": {
          "jsCode": "// Get companies from upstream Fetch Companies node\nconst companyItems = $('Fetch Companies').all();\nlet companies = [];\nif (companyItems.length === 1 && Array.isArray(companyItems[0].json)) {\n  companies = companyItems[0].json;\n} else {\n  companies = companyItems.map(i => i.json);\n}\n\n// Get existing contact company_ids\nconst contactItems = $input.all();\nlet existingIds = new Set();\nfor (const item of contactItems) {\n  if (item.json && item.json.company_id) {\n    existingIds.add(item.json.company_id);\n  }\n  // Handle array response\n  if (Array.isArray(item.json)) {\n    for (const row of item.json) {\n      if (row.company_id) existingIds.add(row.company_id);\n    }\n  }\n}\n\n// Filter out companies that already have contacts\nconst filtered = companies.filter(c => c.id && !existingIds.has(c.id));\n\nconsole.log(`Companies: ${companies.length} total, ${existingIds.size} already have contacts, ${filtered.length} need people discovery`);\n\nif (filtered.length === 0) {\n  return [{ json: { _empty: true, _count: 0, _message: 'All companies already have contacts or no companies to process' } }];\n}\n\nreturn filtered.map(c => ({ json: c }));"
        },
        "id": "07d62a02-17a6-4bab-910b-0f26be520010",
        "name": "Filter & Parse Batch",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          3664,
          528
        ]
      },
      {
        "parameters": {
          "jsCode": "// runOnceForAllItems \u2014 hoist name list + helper outside loop\nconst items = $input.all();\nconst results = [];\n\nconst commonFirstNames = new Set([\n  'aaron','abby','abigail','adam','adrian','adriana','aiden','aimee','alana','albert',\n  'alec','alexa','alexander','alexandra','alexis','alice','alicia','alina','alison','allison',\n  'alyssa','amanda','amber','amelia','amy','ana','andrea','andrew','angela','angelica',\n  'angie','anita','ann','anna','anne','annie','anthony','april','aria','ariana',\n  'ashley','audrey','austin','autumn','ava','avery','bailey','barbara','beatrice','becky',\n  'bella','ben','benjamin','beth','bethany','betty','beverly','bianca','blake','bonnie',\n  'brad','bradley','brandi','brandon','brandy','breanna','brenda','brent','brett','brian',\n  'briana','brianna','bridget','brittany','brittney','brooke','bruce','bryan','caitlin','caleb',\n  'cameron','camila','candace','cara','carina','carl','carla','carlos','carly','carmen',\n  'carol','carolina','caroline','carolyn','carrie','casey','cassandra','cassidy','catherine','cathy',\n  'cecilia','celeste','celia','chad','charlene','charles','charlie','charlotte','chase','chelsea',\n  'cheryl','chloe','chris','christa','christian','christina','christine','christopher','cindy','claire',\n  'clara','claudia','cody','colleen','connor','constance','corey','corinne','courtney','craig',\n  'crystal','cynthia','daisy','dale','dana','daniel','daniela','danielle','daphne','darlene',\n  'darren','dave','david','dawn','dean','deanna','debbie','deborah','debra','denise',\n  'derek','desiree','destiny','diana','diane','dianne','dolores','dominic','donna','doris',\n  'dorothy','douglas','drew','dustin','dylan','eddie','edith','edward','eileen','elaine',\n  'elena','elisa','elizabeth','ella','ellen','ellie','emily','emma','eric','erica',\n  'erika','erin','ernest','esther','ethan','eugene','eva','evan','evelyn','faith',\n  'faye','felicia','fiona','florence','frances','frank','gabriel','gabriela','gabriella','gabrielle',\n  'gail','gary','gavin','genevieve','george','georgia','gerald','gina','giselle','gladys',\n  'glen','glenn','gloria','grace','grant','greg','gregory','gretchen','hailey','haley',\n  'hannah','harold','harriet','harry','hayden','hazel','heather','heidi','helen','henry',\n  'hillary','holly','hope','howard','hunter','ian','irene','iris','isaac','isabel',\n  'isabella','ivy','jack','jackie','jackson','jacob','jacqueline','jade','jaime','jake',\n  'james','jamie','jan','jane','janet','janice','jared','jasmine','jason','jay',\n  'jean','jeanette','jeanne','jeff','jeffrey','jenna','jennifer','jenny','jeremy','jerry',\n  'jesse','jessica','jill','jillian','jim','jimmy','jo','joan','joann','joanna',\n  'joanne','jocelyn','jodi','jody','joe','joel','johanna','john','johnny','jolene',\n  'jon','jonathan','jordan','jorge','jose','joseph','josephine','josh','joshua','joy',\n  'joyce','juan','judith','judy','julia','julian','juliana','julie','june','justin',\n  'kaitlyn','kara','karen','karina','karl','kate','katelyn','katherine','kathleen','kathryn',\n  'kathy','katie','katrina','kay','kayla','keith','kelley','kelli','kelly','kelsey',\n  'ken','kendra','kenneth','kenny','kerry','kevin','kim','kimberly','kirsten','krista',\n  'kristen','kristin','kristina','kristy','kyle','kylie','lacey','lana','lance','larry',\n  'laura','lauren','laurie','leah','lee','leigh','lena','leo','leon','leslie',\n  'lexy','liam','lillian','lily','linda','lindsay','lindsey','lisa','logan','lois',\n  'lora','lorena','lori','lorraine','louis','louise','lucia','luis','luke','lydia',\n  'lynn','mackenzie','madeline','madison','maggie','malik','mallory','mandy','marc','marcia',\n  'marco','marcus','margaret','maria','mariah','marie','marilyn','marina','mario','marisa',\n  'marissa','mark','marlene','marsha','martha','martin','mary','mason','matt','matthew',\n  'maureen','max','maya','megan','meghan','melanie','melinda','melissa','melody','meredith',\n  'mia','michael','michele','michelle','miguel','mike','mildred','mindy','miranda','misty',\n  'mitchell','molly','monica','monique','morgan','mya','nadia','nancy','naomi','natalia',\n  'natalie','natasha','nathan','nathaniel','neil','nelson','nicholas','nicole','nina','noah',\n  'noel','nora','norma','olivia','owen','paige','pam','pamela','patricia','patrick',\n  'patty','paul','paula','pauline','peggy','penny','peter','philip','phyllis','priscilla',\n  'rachel','ralph','ramona','randall','randy','ray','raymond','rebecca','regina','renee',\n  'rhonda','ricardo','richard','rick','ricky','riley','rita','rob','robert','roberta',\n  'robin','rochelle','rodney','roger','ronald','rosa','rosalie','rose','rosemary','roxanne',\n  'ruby','russell','ruth','ryan','sabrina','sally','samantha','samuel','sandra','sandy',\n  'sara','sarah','savannah','scott','sean','selena','serena','seth','shana','shane',\n  'shannon','sharon','shawn','sheila','shelby','shelley','shelly','sheri','sherri','sherry',\n  'shirley','sierra','silvia','simone','sofia','sonia','sonya','sophia','stacey','stacy',\n  'stella','stephanie','stephen','steve','steven','sue','summer','susan','suzanne','sydney',\n  'sylvia','tabitha','tamara','tammy','tanya','tara','tatiana','taylor','teresa','terri',\n  'terry','tess','tessa','theresa','thomas','tiffany','tim','timothy','tina','tito',\n  'todd','tom','tommy','toni','tony','tonya','tracey','traci','tracy','travis',\n  'tricia','trisha','troy','tyler','valerie','vanessa','vera','veronica','vicki','vicky',\n  'victoria','vincent','violet','virginia','vivian','wade','walter','wanda','warren','wayne',\n  'wendy','wesley','whitney','william','willie','wilma','xavier','yolanda','yvette','yvonne',\n  'zachary','zoe'\n]);\n\nfunction isLikelyFirstName(word) {\n  return commonFirstNames.has(word.toLowerCase());\n}\n\nfor (const entry of items) {\n  const item = entry.json;\n  const name = (item.name || '').trim();\n  const estimatedSize = item.estimated_size;\n\n  let isSolo = false;\n  let firstName = null;\n  let lastName = null;\n\n  // Pattern 1: \"by Name\" pattern - \"Bodywork by Benna\", \"Massage by Celeste\"\n  const byPattern = name.match(/\\bby\\s+([A-Z][a-z]+)(?:\\s+([A-Z][a-z]+))?/i);\n  if (byPattern) {\n    const candidate = byPattern[1];\n    if (isLikelyFirstName(candidate) || estimatedSize === 'solo') {\n      isSolo = true;\n      firstName = candidate;\n      lastName = byPattern[2] || null;\n    }\n  }\n\n  // Pattern 2: \"with Name\" pattern\n  if (!firstName) {\n    const withPattern = name.match(/\\bwith\\s+([A-Z][a-z]+)(?:\\s+([A-Z][a-z]+))?/i);\n    if (withPattern) {\n      const candidate = withPattern[1];\n      if (isLikelyFirstName(candidate) || estimatedSize === 'solo') {\n        isSolo = true;\n        firstName = candidate;\n        lastName = withPattern[2] || null;\n      }\n    }\n  }\n\n  // Pattern 3: Possessive - \"Lexy's Massage\"\n  if (!firstName) {\n    const possessiveMatch = name.match(/^([A-Z][a-z]+)'s\\s+/i);\n    if (possessiveMatch && isLikelyFirstName(possessiveMatch[1])) {\n      isSolo = true;\n      firstName = possessiveMatch[1];\n    }\n  }\n\n  // Pattern 4: \"FirstName LastName, LMT/CMT/RMT\"\n  if (!firstName) {\n    const nameFirst = name.match(/^([A-Z][a-z]+)\\s+([A-Z][a-z]+)(?:\\s*[,|]\\s*|\\s+)(?:LMT|CMT|RMT|Licensed|Massage|Bodywork|Therapeutic|Wellness)/i);\n    if (nameFirst) {\n      const fn = nameFirst[1];\n      const ln = nameFirst[2];\n      if (isLikelyFirstName(fn) && !commonFirstNames.has(ln.toLowerCase())) {\n        isSolo = true;\n        firstName = fn;\n        lastName = ln;\n      }\n    }\n  }\n\n  // Pattern 5: \"FirstName LastName's Massage/Spa\"\n  if (!firstName) {\n    const possessiveFullName = name.match(/^([A-Z][a-z]+)\\s+([A-Z][a-z]+)'s\\s+(?:Massage|Bodywork|Wellness|Spa|Healing)/i);\n    if (possessiveFullName && isLikelyFirstName(possessiveFullName[1])) {\n      isSolo = true;\n      firstName = possessiveFullName[1];\n      lastName = possessiveFullName[2];\n    }\n  }\n\n  // Pattern 6: Three-part name with title\n  if (!firstName) {\n    const threePartName = name.match(/^([A-Z][a-z]+)\\s+([A-Z][a-z]+)\\s+([A-Z][a-z]+),?\\s+(?:LMT|CMT|RMT|Licensed)/i);\n    if (threePartName && isLikelyFirstName(threePartName[1])) {\n      isSolo = true;\n      firstName = threePartName[1];\n      lastName = threePartName[3];\n    }\n  }\n\n  // Pattern 7: Name embedded after comma\n  if (!firstName) {\n    const commaNameMatch = name.match(/,\\s*([A-Z][a-z]+)\\s+([A-Z][a-z]+)(?:\\s*,?\\s*(?:LMT|CMT|RMT|Licensed))?/i);\n    if (commaNameMatch && isLikelyFirstName(commaNameMatch[1])) {\n      isSolo = true;\n      firstName = commaNameMatch[1];\n      lastName = commaNameMatch[2];\n    }\n  }\n\n  // If estimated_size is solo but no name extracted, still flag as solo\n  if (estimatedSize === 'solo' && !isSolo) {\n    isSolo = true;\n  }\n\n  // Reject if extracted first name matches the company's city\n  if (firstName && item.city && firstName.toLowerCase() === item.city.toLowerCase()) {\n    firstName = null;\n    lastName = null;\n  }\n\n  results.push({\n    json: {\n      ...item,\n      _is_solo: isSolo,\n      _solo_first_name: firstName,\n      _solo_last_name: lastName\n    }\n  });\n}\n\nreturn results;"
        },
        "id": "56176ae4-01b1-4fbb-9ec9-894c5dd24eff",
        "name": "Solo Practitioner Check",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          4112,
          624
        ],
        "notes": "Detects solo practitioners from estimated_size='solo' or business name patterns. Extracts first/last name from business name to avoid wasting API credits."
      },
      {
        "parameters": {
          "conditions": {
            "options": {
              "caseSensitive": true,
              "leftValue": "",
              "typeValidation": "loose"
            },
            "conditions": [
              {
                "id": "is-solo",
                "leftValue": "={{ $json._is_solo }}",
                "rightValue": true,
                "operator": {
                  "type": "boolean",
                  "operation": "equals",
                  "singleValue": true
                }
              }
            ],
            "combinator": "and"
          },
          "options": {}
        },
        "id": "90cfe293-7c3e-457d-867e-63f5315914b1",
        "name": "Is Solo?",
        "type": "n8n-nodes-base.if",
        "typeVersion": 2,
        "position": [
          4416,
          512
        ]
      },
      {
        "parameters": {
          "jsCode": "const items = $input.all();\nconst results = [];\n\nfor (const entry of items) {\n  const item = entry.json;\n  results.push({\n    json: {\n      _contact: {\n        company_id: item.id,\n        first_name: item._solo_first_name || null,\n        last_name: item._solo_last_name || null,\n        role: 'owner',\n        is_owner: true,\n        email_business: null,\n        email_personal: null,\n        phone_direct: null,\n        linkedin_url: null,\n        location: [item.city, item.state].filter(Boolean).join(', ') || null,\n        cultural_affinity: null,\n        source: 'solo_detection'\n      },\n      _company_name: item.name,\n      _company_id: item.id,\n      _source_method: 'solo_detection',\n      _has_contact: !!(item._solo_first_name)\n    }\n  });\n}\n\nreturn results;"
        },
        "id": "52a5a162-ed46-4a80-93c6-aec6bc23fd66",
        "name": "Prepare Solo Contact",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          5584,
          48
        ]
      },
      {
        "parameters": {
          "conditions": {
            "options": {
              "caseSensitive": true,
              "leftValue": "",
              "typeValidation": "loose"
            },
            "conditions": [
              {
                "id": "has-domain",
                "leftValue": "={{ $json.domain }}",
                "rightValue": "",
                "operator": {
                  "type": "string",
                  "operation": "notEquals"
                }
              },
              {
                "id": "not-skip-apollo",
                "leftValue": "={{ $('Step 3a Config').first().json.skip_apollo }}",
                "rightValue": "true",
                "operator": {
                  "type": "string",
                  "operation": "notEquals"
                }
              }
            ],
            "combinator": "and"
          },
          "options": {}
        },
        "id": "801a7433-0b2e-46f8-bc18-057ec867313b",
        "name": "Has Domain & Apollo?",
        "type": "n8n-nodes-base.if",
        "typeVersion": 2,
        "position": [
          4640,
          608
        ],
        "notes": "Routes to Apollo search if company has a domain AND apollo is not skipped. Otherwise goes to website scrape fallback."
      },
      {
        "parameters": {
          "method": "POST",
          "url": "https://api.apollo.io/api/v1/mixed_people/api_search",
          "sendHeaders": true,
          "headerParameters": {
            "parameters": [
              {
                "name": "Content-Type",
                "value": "application/json"
              },
              {
                "name": "Cache-Control",
                "value": "no-cache"
              },
              {
                "name": "X-Api-Key",
                "value": "={{ $env.APOLLO_API_KEY }}"
              }
            ]
          },
          "sendBody": true,
          "specifyBody": "json",
          "jsonBody": "={\n  \"q_organization_domains\": \"{{ $json.domain }}\",\n  \"person_titles\": [\"owner\", \"founder\", \"ceo\", \"proprietor\", \"director\", \"manager\", \"massage therapist\", \"licensed massage therapist\"],\n  \"per_page\": 5\n}",
          "options": {
            "timeout": 15000,
            "batching": {
              "batch": {
                "batchSize": 3,
                "batchInterval": 2000
              }
            }
          }
        },
        "id": "f07c5c38-08ff-4038-87b0-54d90e26424b",
        "name": "Apollo People Search",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.2,
        "position": [
          4848,
          496
        ],
        "onError": "continueRegularOutput",
        "notes": "FREE - does not consume credits. Searches for people at the company's domain. Returns person IDs with obfuscated last names."
      },
      {
        "parameters": {
          "jsCode": "// runOnceForAllItems \u2014 index-paired with Solo Practitioner Check\nconst upstreamAll = $('Solo Practitioner Check').all();\nconst inputAll = $input.all();\nconst results = [];\n\n// Hoisted keyword arrays\nconst ownerKeywords = ['owner', 'founder', 'ceo', 'proprietor', 'principal', 'co-founder'];\nconst managerKeywords = ['manager', 'director', 'general manager', 'gm', 'head'];\nconst practitionerKeywords = ['massage', 'therapist', 'lmt', 'cmt', 'rmt', 'bodywork', 'esthetician'];\n\nfor (let i = 0; i < inputAll.length; i++) {\n  const company = upstreamAll[i].json;\n  const response = inputAll[i].json;\n  const people = response.people || [];\n\n  if (!people || people.length === 0) {\n    results.push({\n      json: {\n        ...company,\n        _apollo_found: false,\n        _apollo_person_id: null,\n        _apollo_person_count: 0\n      }\n    });\n    continue;\n  }\n\n  // Score people by role relevance - prefer owners/founders\n  let bestPerson = null;\n  let bestScore = -1;\n\n  for (const person of people) {\n    const title = (person.title || '').toLowerCase();\n    let score = 0;\n\n    if (ownerKeywords.some(k => title.includes(k))) score = 10;\n    else if (managerKeywords.some(k => title.includes(k))) score = 5;\n    else if (practitionerKeywords.some(k => title.includes(k))) score = 3;\n    else score = 1;\n\n    // Bonus for having email available\n    if (person.has_email === true || person.has_email === 'true') score += 1;\n\n    if (score > bestScore) {\n      bestScore = score;\n      bestPerson = person;\n    }\n  }\n\n  console.log(`Apollo search for ${company.domain}: ${people.length} people found. Best: ${bestPerson.first_name} (${bestPerson.title || 'no title'}, score ${bestScore})`);\n\n  results.push({\n    json: {\n      ...company,\n      _apollo_found: true,\n      _apollo_person_id: bestPerson.id,\n      _apollo_first_name: bestPerson.first_name,\n      _apollo_last_name_obfuscated: bestPerson.last_name_obfuscated || null,\n      _apollo_title: bestPerson.title || null,\n      _apollo_person_count: people.length\n    }\n  });\n}\n\nreturn results;"
        },
        "id": "4392c9f8-39dc-4ac1-a39b-9f16be3926c7",
        "name": "Parse Apollo Search",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          5040,
          448
        ]
      },
      {
        "parameters": {
          "conditions": {
            "options": {
              "caseSensitive": true,
              "leftValue": "",
              "typeValidation": "loose"
            },
            "conditions": [
              {
                "id": "apollo-found",
                "leftValue": "={{ $json._apollo_found }}",
                "rightValue": true,
                "operator": {
                  "type": "boolean",
                  "operation": "equals",
                  "singleValue": true
                }
              }
            ],
            "combinator": "and"
          },
          "options": {}
        },
        "id": "64fca517-5772-4d0e-bc72-9756e00edd4e",
        "name": "Apollo Found People?",
        "type": "n8n-nodes-base.if",
        "typeVersion": 2,
        "position": [
          5264,
          448
        ]
      },
      {
        "parameters": {
          "conditions": {
            "options": {
              "caseSensitive": true,
              "leftValue": "",
              "typeValidation": "loose"
            },
            "conditions": [
              {
                "id": "enrich-enabled",
                "leftValue": "={{ $('Step 3a Config').first().json.apollo_enrich_enabled }}",
                "rightValue": "true",
                "operator": {
                  "type": "string",
                  "operation": "equals"
                }
              }
            ],
            "combinator": "and"
          },
          "options": {}
        },
        "id": "dd64a3e6-eb3a-46c6-b894-83f0297d65ef",
        "name": "Enrich Enabled?",
        "type": "n8n-nodes-base.if",
        "typeVersion": 2,
        "position": [
          5440,
          336
        ],
        "notes": "Guards Apollo enrichment credits. Set apollo_enrich_enabled=false in config to skip enrichment and just use search results."
      },
      {
        "parameters": {
          "method": "POST",
          "url": "https://api.apollo.io/api/v1/people/match",
          "sendHeaders": true,
          "headerParameters": {
            "parameters": [
              {
                "name": "Content-Type",
                "value": "application/json"
              },
              {
                "name": "Cache-Control",
                "value": "no-cache"
              },
              {
                "name": "X-Api-Key",
                "value": "={{ $env.APOLLO_API_KEY }}"
              }
            ]
          },
          "sendBody": true,
          "specifyBody": "json",
          "jsonBody": "={\n  \"id\": \"{{ $json._apollo_person_id }}\",\n  \"reveal_personal_emails\": true,\n  \"reveal_phone_number\": false\n}",
          "options": {
            "batching": {
              "batch": {
                "batchSize": 5
              }
            },
            "timeout": 15000
          }
        },
        "id": "205649d6-149f-4706-8d75-b6a0f0a68525",
        "name": "Apollo People Enrich",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.2,
        "position": [
          5632,
          240
        ],
        "onError": "continueRegularOutput",
        "notes": "COSTS 1 CREDIT per call. Enriches the selected person with full name, email, phone, LinkedIn. Batched 5/sec."
      },
      {
        "parameters": {
          "jsCode": "// runOnceForAllItems \u2014 index-paired with Parse Apollo Search\nconst upstreamAll = $('Parse Apollo Search').all();\nconst inputAll = $input.all();\nconst results = [];\n\nfor (let i = 0; i < inputAll.length; i++) {\n  const company = upstreamAll[i].json;\n  const response = inputAll[i].json;\n  const person = response.person || response.match || response;\n\n  if (!person || !person.first_name) {\n    // Enrichment failed but we still have search data\n    results.push({\n      json: {\n        _contact: {\n          company_id: company.id,\n          first_name: company._apollo_first_name || null,\n          last_name: null,\n          role: (company._apollo_title || '').toLowerCase().includes('owner') ? 'owner' : 'unknown',\n          is_owner: (company._apollo_title || '').toLowerCase().includes('owner'),\n          email_business: null,\n          email_personal: null,\n          phone_direct: null,\n          linkedin_url: null,\n          location: [company.city, company.state].filter(Boolean).join(', ') || null,\n          cultural_affinity: null,\n          source: 'apollo'\n        },\n        _company_name: company.name,\n        _company_id: company.id,\n        _source_method: 'apollo_search_only',\n        _has_contact: !!(company._apollo_first_name)\n      }\n    });\n    continue;\n  }\n\n  // Extract phone number\n  let phoneNumber = null;\n  if (person.phone_numbers && person.phone_numbers.length > 0) {\n    phoneNumber = person.phone_numbers[0].sanitized_number || person.phone_numbers[0].raw_number || null;\n  }\n\n  // Determine role\n  const title = (person.title || '').toLowerCase();\n  let role = 'unknown';\n  let isOwner = false;\n  if (['owner', 'founder', 'ceo', 'proprietor', 'principal', 'co-founder'].some(k => title.includes(k))) {\n    role = 'owner';\n    isOwner = true;\n  } else if (['manager', 'director', 'gm', 'general manager'].some(k => title.includes(k))) {\n    role = 'manager';\n  } else if (['massage', 'therapist', 'lmt', 'cmt', 'rmt', 'esthetician'].some(k => title.includes(k))) {\n    role = 'practitioner';\n  }\n\n  results.push({\n    json: {\n      _contact: {\n        company_id: company.id,\n        first_name: person.first_name || null,\n        last_name: person.last_name || null,\n        role: role,\n        is_owner: isOwner,\n        email_business: person.email || null,\n        email_personal: (person.personal_emails && person.personal_emails[0]) || null,\n        phone_direct: phoneNumber,\n        linkedin_url: person.linkedin_url || null,\n        location: [person.city, person.state].filter(Boolean).join(', ') || [company.city, company.state].filter(Boolean).join(', ') || null,\n        cultural_affinity: null,\n        source: 'apollo'\n      },\n      _company_name: company.name,\n      _company_id: company.id,\n      _source_method: 'apollo_enriched',\n      _has_contact: true\n    }\n  });\n}\n\nreturn results;"
        },
        "id": "b8845975-4f17-416e-861e-94cc5cc39146",
        "name": "Parse Apollo Enrich",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          5808,
          240
        ]
      },
      {
        "parameters": {
          "jsCode": "// Apollo search found someone but enrichment is disabled - use search-only data\nconst items = $input.all();\nconst results = [];\n\nfor (const entry of items) {\n  const item = entry.json;\n  results.push({\n    json: {\n      _contact: {\n        company_id: item.id,\n        first_name: item._apollo_first_name || null,\n        last_name: null,\n        role: (item._apollo_title || '').toLowerCase().includes('owner') ? 'owner' : 'unknown',\n        is_owner: (item._apollo_title || '').toLowerCase().includes('owner'),\n        email_business: null,\n        email_personal: null,\n        phone_direct: null,\n        linkedin_url: null,\n        location: [item.city, item.state].filter(Boolean).join(', ') || null,\n        cultural_affinity: null,\n        source: 'apollo'\n      },\n      _company_name: item.name,\n      _company_id: item.id,\n      _source_method: 'apollo_search_only',\n      _has_contact: !!(item._apollo_first_name)\n    }\n  });\n}\n\nreturn results;"
        },
        "id": "84b82e8e-33cb-4264-8c45-96b1081845f1",
        "name": "Apollo Search Only Contact",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          5680,
          448
        ],
        "notes": "Fallback: uses Apollo search data (first name + obfuscated last name) when enrichment credits are disabled."
      },
      {
        "parameters": {
          "url": "=https://{{ $json.domain }}/about",
          "sendHeaders": true,
          "headerParameters": {
            "parameters": [
              {
                "name": "User-Agent",
                "value": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36"
              },
              {
                "name": "Accept",
                "value": "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8"
              }
            ]
          },
          "options": {
            "redirect": {
              "redirect": {
                "maxRedirects": 5
              }
            },
            "response": {
              "response": {
                "fullResponse": true,
                "responseFormat": "text"
              }
            },
            "timeout": 15000
          }
        },
        "id": "56a047ca-1e8c-4228-90d2-906e3f4672bc",
        "name": "Fetch About Page",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.2,
        "position": [
          5424,
          704
        ],
        "onError": "continueRegularOutput",
        "notes": "Fetches /about page as fallback when Apollo found no results. Tries to extract owner name from HTML."
      },
      {
        "parameters": {
          "jsCode": "// runOnceForAllItems \u2014 index-paired with Solo Practitioner Check\n// Has async this.helpers.httpRequest() inside loop (required per-item)\nconst upstreamAll = $('Solo Practitioner Check').all();\nconst inputAll = $input.all();\nconst results = [];\n\nconst additionalPaths = ['/about-us', '/about-me', '/our-team', '/team', '/our-story'];\n\nconst commonFirstNames = new Set([\n  'aaron','abby','abigail','adam','adrian','adriana','aiden','aimee','alana','albert',\n  'alexa','alexander','alexandra','alexis','alice','alicia','alison','allison','amanda','amber',\n  'amelia','amy','ana','andrea','andrew','angela','angelica','angie','anita','ann',\n  'anna','anne','annie','anthony','april','aria','ariana','ashley','audrey','ava',\n  'avery','bailey','barbara','becky','bella','ben','benjamin','beth','bethany','betty',\n  'beverly','bianca','blake','bonnie','brad','bradley','brandi','brandon','brandy','brenda',\n  'brent','brian','brianna','bridget','brittany','brooke','bruce','bryan','caitlin','caleb',\n  'cameron','candace','cara','carl','carla','carlos','carly','carmen','carol','caroline',\n  'carolyn','carrie','casey','cassandra','catherine','cathy','celeste','chad','charlene','charles',\n  'charlotte','chelsea','cheryl','chloe','chris','christina','christine','christopher','cindy','claire',\n  'clara','claudia','colleen','connor','courtney','craig','crystal','cynthia','daisy','dale',\n  'dana','daniel','daniela','danielle','darlene','dave','david','dawn','dean','deanna',\n  'debbie','deborah','debra','denise','derek','desiree','diana','diane','dolores','donna',\n  'doris','dorothy','douglas','drew','dustin','dylan','eddie','edward','eileen','elaine',\n  'elena','elizabeth','ella','ellen','emily','emma','eric','erica','erika','erin',\n  'esther','ethan','eva','evelyn','faith','felicia','fiona','florence','frances','frank',\n  'gabriel','gabriela','gabrielle','gail','gary','george','georgia','gerald','gina','glen',\n  'glenn','gloria','grace','greg','gregory','hailey','haley','hannah','harold','harry',\n  'hazel','heather','heidi','helen','henry','holly','hope','howard','hunter','ian',\n  'irene','iris','isaac','isabel','isabella','ivy','jack','jackie','jacob','jacqueline',\n  'jade','jaime','jake','james','jamie','jane','janet','janice','jared','jasmine',\n  'jason','jay','jean','jeff','jeffrey','jenna','jennifer','jenny','jeremy','jerry',\n  'jesse','jessica','jill','jim','jimmy','joan','joanna','joanne','jocelyn','jodi',\n  'joe','joel','john','johnny','jon','jonathan','jordan','jose','joseph','josh',\n  'joshua','joy','joyce','judith','judy','julia','julie','june','justin','kaitlyn',\n  'kara','karen','karina','kate','katelyn','katherine','kathleen','kathryn','kathy','katie',\n  'katrina','kay','kayla','keith','kelly','kelsey','ken','kendra','kenneth','kevin',\n  'kim','kimberly','kirsten','krista','kristen','kristin','kristina','kristy','kyle','kylie',\n  'lacey','lana','lance','larry','laura','lauren','laurie','leah','lee','leigh',\n  'lena','leon','leslie','lexy','liam','lillian','lily','linda','lindsay','lindsey',\n  'lisa','logan','lois','lori','lorraine','louis','louise','lucia','luis','luke',\n  'lydia','lynn','mackenzie','madeline','madison','maggie','mallory','mandy','marc','marcia',\n  'marcus','margaret','maria','marie','marilyn','marina','mario','marisa','mark','marlene',\n  'martha','martin','mary','matt','matthew','maureen','max','maya','megan','meghan',\n  'melanie','melinda','melissa','melody','meredith','mia','michael','michele','michelle','miguel',\n  'mike','mildred','mindy','miranda','misty','molly','monica','monique','morgan','nadia',\n  'nancy','naomi','natalia','natalie','natasha','nathan','nicholas','nicole','nina','noah',\n  'nora','norma','olivia','owen','paige','pamela','patricia','patrick','paul','paula',\n  'peggy','penny','peter','philip','phyllis','priscilla','rachel','ralph','randy','ray',\n  'raymond','rebecca','regina','renee','rhonda','richard','rick','riley','rita','robert',\n  'roberta','robin','rodney','roger','ronald','rosa','rose','rosemary','ruby','russell',\n  'ruth','ryan','sabrina','sally','samantha','samuel','sandra','sandy','sara','sarah',\n  'savannah','scott','sean','selena','serena','seth','shannon','sharon','shawn','sheila',\n  'shelby','shelly','sheri','sherry','shirley','sierra','simone','sofia','sonia','sophia',\n  'stacey','stacy','stella','stephanie','stephen','steve','steven','sue','summer','susan',\n  'suzanne','sydney','sylvia','tamara','tammy','tanya','tara','tatiana','taylor','teresa',\n  'terri','terry','tessa','theresa','thomas','tiffany','timothy','tina','tito','todd',\n  'tom','toni','tony','tonya','tracey','tracy','travis','tricia','troy','tyler',\n  'valerie','vanessa','vera','veronica','vicki','victoria','vincent','violet','virginia','vivian',\n  'walter','wanda','wayne','wendy','wesley','whitney','william','willie','wilma','xavier',\n  'yolanda','yvette','yvonne','zachary','zoe'\n]);\n\nfunction isLikelyFirstName(word) {\n  return commonFirstNames.has((word || '').toLowerCase());\n}\n\nfunction extractName(html) {\n  if (!html || html.length < 100) return null;\n  const textOnly = html.replace(/<[^>]+>/g, ' ').replace(/\\s+/g, ' ');\n\n  const patterns = [\n    /(?:owner|owned\\s+by|founded\\s+by|proprietor)[:\\s]+([A-Z][a-z]+)\\s+([A-Z][a-z]+)/i,\n    /(?:hi,?\\s+i'?m|hello,?\\s+i'?m|my\\s+name\\s+is|i\\s+am)\\s+([A-Z][a-z]+)\\s+([A-Z][a-z]+)/i,\n    /(?:^|\\s)about\\s+([A-Z][a-z]+)\\s+([A-Z][a-z]+)(?:\\s*[,|]|\\s+(?:LMT|CMT|RMT|Licensed))/i,\n    /(?:^|\\s)meet\\s+([A-Z][a-z]+)\\s+([A-Z][a-z]+)(?:\\s*[,|]|\\s+(?:LMT|CMT|RMT|Licensed|is\\s+a|has\\s+been))/i,\n    /([A-Z][a-z]+)\\s+([A-Z][a-z]+),?\\s+(?:LMT|CMT|RMT|Licensed\\s+Massage)/i\n  ];\n\n  for (const pattern of patterns) {\n    for (const source of [textOnly, html]) {\n      const match = source.match(pattern);\n      if (match) {\n        const fn = match[1];\n        const ln = match[2];\n        if (isLikelyFirstName(fn) &&\n            fn.length >= 2 && fn.length <= 20 &&\n            ln.length >= 2 && ln.length <= 20) {\n          return { firstName: fn, lastName: ln };\n        }\n      }\n    }\n  }\n  return null;\n}\n\nfor (let i = 0; i < inputAll.length; i++) {\n  const company = upstreamAll[i].json;\n  const response = inputAll[i].json;\n\n  // Step 1: Check the upstream /about response\n  let bestHtml = '';\n  let usedPath = '/about';\n  const rawHtml = response.body || response.data || '';\n  if (typeof rawHtml === 'string' && rawHtml.length > 500) {\n    bestHtml = rawHtml;\n  }\n\n  // Step 2: Try to extract name from /about\n  let nameResult = bestHtml ? extractName(bestHtml) : null;\n\n  // Step 3: If /about didn't yield a name, try additional paths\n  if (!nameResult && company.domain) {\n    for (const path of additionalPaths) {\n      try {\n        const resp = await this.helpers.httpRequest({\n          method: 'GET',\n          url: `https://${company.domain}${path}`,\n          headers: { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36' },\n          returnFullResponse: true,\n          timeout: 10000,\n          json: false,\n        });\n        const html = resp.body || '';\n        if (typeof html === 'string' && html.length > 500) {\n          const found = extractName(html);\n          if (found) {\n            nameResult = found;\n            usedPath = path;\n            console.log(`Found name on ${path}: ${found.firstName} ${found.lastName}`);\n            break;\n          }\n        }\n      } catch(e) {\n        // Path doesn't exist or timed out \u2014 try next\n      }\n    }\n  }\n\n  const hasContact = !!(nameResult);\n\n  results.push({\n    json: {\n      _contact: hasContact ? {\n        company_id: company.id,\n        first_name: nameResult.firstName,\n        last_name: nameResult.lastName,\n        role: 'owner',\n        is_owner: true,\n        email_business: null,\n        email_personal: null,\n        phone_direct: null,\n        linkedin_url: null,\n        location: [company.city, company.state].filter(Boolean).join(', ') || null,\n        cultural_affinity: null,\n        source: 'website'\n      } : null,\n      _company_name: company.name,\n      _company_id: company.id,\n      _source_method: hasContact ? `website_scrape_${usedPath.replace('/', '')}` : 'website_scrape',\n      _has_contact: hasContact\n    }\n  });\n}\n\nreturn results;"
        },
        "id": "eed207a8-0d1d-4e22-899a-cbdbc7039086",
        "name": "Parse About Page",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          5584,
          704
        ]
      },
      {
        "parameters": {
          "conditions": {
            "options": {
              "caseSensitive": true,
              "leftValue": "",
              "typeValidation": "loose"
            },
            "conditions": [
              {
                "id": "found-name",
                "leftValue": "={{ $json._has_contact }}",
                "rightValue": true,
                "operator": {
                  "type": "boolean",
                  "operation": "equals",
                  "singleValue": true
                }
              }
            ],
            "combinator": "and"
          },
          "options": {}
        },
        "id": "c3c2d97c-9326-4b42-a0ad-7462fa6d6829",
        "name": "About Found Name?",
        "type": "n8n-nodes-base.if",
        "typeVersion": 2,
        "position": [
          5744,
          704
        ]
      },
      {
        "parameters": {
          "jsCode": "// runOnceForAllItems \u2014 hoist name list + helper outside loop\nconst items = $input.all();\nconst results = [];\n\nconst commonFirstNames = new Set([\n  'aaron','abby','abigail','adam','adrian','adriana','aiden','aimee','alana','albert',\n  'alexa','alexander','alexandra','alexis','alice','alicia','alison','allison','amanda','amber',\n  'amelia','amy','ana','andrea','andrew','angela','angelica','angie','anita','ann',\n  'anna','anne','annie','anthony','april','aria','ariana','ashley','audrey','ava',\n  'avery','bailey','barbara','becky','bella','ben','benjamin','beth','bethany','betty',\n  'beverly','bianca','blake','bonnie','brad','bradley','brandi','brandon','brandy','brenda',\n  'brent','brian','brianna','bridget','brittany','brooke','bruce','bryan','caitlin','caleb',\n  'cameron','candace','cara','carl','carla','carlos','carly','carmen','carol','caroline',\n  'carolyn','carrie','casey','cassandra','catherine','cathy','celeste','chad','charlene','charles',\n  'charlotte','chelsea','cheryl','chloe','chris','christina','christine','christopher','cindy','claire',\n  'clara','claudia','colleen','connor','courtney','craig','crystal','cynthia','daisy','dale',\n  'dana','daniel','daniela','danielle','darlene','dave','david','dawn','dean','deanna',\n  'debbie','deborah','debra','denise','derek','desiree','diana','diane','dolores','donna',\n  'doris','dorothy','douglas','drew','dustin','dylan','eddie','edward','eileen','elaine',\n  'elena','elizabeth','ella','ellen','emily','emma','eric','erica','erika','erin',\n  'esther','ethan','eva','evelyn','faith','felicia','fiona','florence','frances','frank',\n  'gabriel','gabriela','gabrielle','gail','gary','george','georgia','gerald','gina','glen',\n  'glenn','gloria','grace','greg','gregory','hailey','haley','hannah','harold','harry',\n  'hazel','heather','heidi','helen','henry','holly','hope','howard','hunter','ian',\n  'irene','iris','isaac','isabel','isabella','ivy','jack','jackie','jacob','jacqueline',\n  'jade','jaime','jake','james','jamie','jane','janet','janice','jared','jasmine',\n  'jason','jay','jean','jeff','jeffrey','jenna','jennifer','jenny','jeremy','jerry',\n  'jesse','jessica','jill','jim','jimmy','joan','joanna','joanne','jocelyn','jodi',\n  'joe','joel','john','johnny','jon','jonathan','jordan','jose','joseph','josh',\n  'joshua','joy','joyce','judith','judy','julia','julie','june','justin','kaitlyn',\n  'kara','karen','karina','kate','katelyn','katherine','kathleen','kathryn','kathy','katie',\n  'katrina','kay','kayla','keith','kelly','kelsey','ken','kendra','kenneth','kevin',\n  'kim','kimberly','kirsten','krista','kristen','kristin','kristina','kristy','kyle','kylie',\n  'lacey','lana','lance','larry','laura','lauren','laurie','leah','lee','leigh',\n  'lena','leon','leslie','lexy','liam','lillian','lily','linda','lindsay','lindsey',\n  'lisa','logan','lois','lori','lorraine','louis','louise','lucia','luis','luke',\n  'lydia','lynn','mackenzie','madeline','madison','maggie','mallory','mandy','marc','marcia',\n  'marcus','margaret','maria','marie','marilyn','marina','mario','marisa','mark','marlene',\n  'martha','martin','mary','matt','matthew','maureen','max','maya','megan','meghan',\n  'melanie','melinda','melissa','melody','meredith','mia','michael','michele','michelle','miguel',\n  'mike','mildred','mindy','miranda','misty','molly','monica','monique','morgan','nadia',\n  'nancy','naomi','natalia','natalie','natasha','nathan','nicholas','nicole','nina','noah',\n  'nora','norma','olivia','owen','paige','pamela','patricia','patrick','paul','paula',\n  'peggy','penny','peter','philip','phyllis','priscilla','rachel','ralph','randy','ray',\n  'raymond','rebecca','regina','renee','rhonda','richard','rick','riley','rita','robert',\n  'roberta','robin','rodney','roger','ronald','rosa','rose','rosemary','ruby','russell',\n  'ruth','ryan','sabrina','sally','samantha','samuel','sandra','sandy','sara','sarah',\n  'savannah','scott','sean','selena','serena','seth','shannon','sharon','shawn','sheila',\n  'shelby','shelly','sheri','sherry','shirley','sierra','simone','sofia','sonia','sophia',\n  'stacey','stacy','stella','stephanie','stephen','steve','steven','sue','summer','susan',\n  'suzanne','sydney','sylvia','tamara','tammy','tanya','tara','tatiana','taylor','teresa',\n  'terri','terry','tessa','theresa','thomas','tiffany','timothy','tina','tito','todd',\n  'tom','toni','tony','tonya','tracey','tracy','travis','tricia','troy','tyler',\n  'valerie','vanessa','vera','veronica','vicki','victoria','vincent','violet','virginia','vivian',\n  'walter','wanda','wayne','wendy','wesley','whitney','william','willie','wilma','xavier',\n  'yolanda','yvette','yvonne','zachary','zoe'\n]);\n\nfunction isLikelyFirstName(word) {\n  return commonFirstNames.has(word.toLowerCase());\n}\n\nfor (const entry of items) {\n  const item = entry.json;\n  const name = (item.name || '').trim();\n\n  let firstName = null;\n  let lastName = null;\n\n  // Pattern 1: \"by Name\"\n  const byPattern = name.match(/\\bby\\s+([A-Z][a-z]+)(?:\\s+([A-Z][a-z]+))?/i);\n  if (byPattern && isLikelyFirstName(byPattern[1])) {\n    firstName = byPattern[1];\n    lastName = byPattern[2] || null;\n  }\n\n  // Pattern 2: \"with Name\"\n  if (!firstName) {\n    const withPattern = name.match(/\\bwith\\s+([A-Z][a-z]+)(?:\\s+([A-Z][a-z]+))?/i);\n    if (withPattern && isLikelyFirstName(withPattern[1])) {\n      firstName = withPattern[1];\n      lastName = withPattern[2] || null;\n    }\n  }\n\n  // Pattern 3: Possessive\n  if (!firstName) {\n    const possessive = name.match(/^([A-Z][a-z]+)'s\\s+/i);\n    if (possessive && isLikelyFirstName(possessive[1])) {\n      firstName = possessive[1];\n    }\n  }\n\n  // Pattern 4: \"FirstName LastName, LMT\"\n  if (!firstName) {\n    const credMatch = name.match(/^([A-Z][a-z]+)\\s+([A-Z][a-z]+)(?:\\s*,?\\s*(?:LMT|CMT|RMT|Licensed))/i);\n    if (credMatch && isLikelyFirstName(credMatch[1])) {\n      firstName = credMatch[1];\n      lastName = credMatch[2];\n    }\n  }\n\n  // Pattern 5: Name after comma\n  if (!firstName) {\n    const commaMatch = name.match(/,\\s*([A-Z][a-z]+)\\s+([A-Z][a-z]+)/i);\n    if (commaMatch && isLikelyFirstName(commaMatch[1])) {\n      firstName = commaMatch[1];\n      lastName = commaMatch[2];\n    }\n  }\n\n  // Pattern 6: Validated first+last before business keyword\n  if (!firstName) {\n    const nameKeyword = name.match(/^([A-Z][a-z]+)\\s+([A-Z][a-z]+)\\s+(?:Massage|Bodywork|Therapeutic|Wellness|Healing|Spa)/i);\n    if (nameKeyword && isLikelyFirstName(nameKeyword[1]) && !isLikelyFirstName(nameKeyword[2])) {\n      firstName = nameKeyword[1];\n      lastName = nameKeyword[2];\n    }\n  }\n\n  const hasContact = !!(firstName);\n\n  results.push({\n    json: {\n      _contact: hasContact ? {\n        company_id: item.id,\n        first_name: firstName,\n        last_name: lastName,\n        role: 'owner',\n        is_owner: true,\n        email_business: null,\n        email_personal: null,\n        phone_direct: null,\n        linkedin_url: null,\n        location: [item.city, item.state].filter(Boolean).join(', ') || null,\n        cultural_affinity: null,\n        source: 'manual'\n      } : null,\n      _company_name: item.name,\n      _company_id: item.id,\n      _source_method: 'no_domain_name_extraction',\n      _has_contact: hasContact\n    }\n  });\n}\n\nreturn results;"
        },
        "id": "2900cb38-81d2-48b9-a3d5-8797662f8fcf",
        "name": "No Domain Fallback",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          5552,
          896
        ],
        "notes": "Last resort: tries to extract a person name from the business name when there's no domain to search or scrape."
      },
      {
        "parameters": {
          "conditions": {
            "options": {
              "caseSensitive": true,
              "leftValue": "",
              "typeValidation": "loose"
            },
            "conditions": [
              {
                "id": "has-contact",
                "leftValue": "={{ $json._has_contact }}",
                "rightValue": true,
                "operator": {
                  "type": "boolean",
                  "operation": "equals",
                  "singleValue": true
                }
              }
            ],
            "combinator": "and"
          },
          "options": {}
        },
        "id": "0a130892-5648-4382-90b3-c5f7e7c1d42b",
        "name": "No Domain Found Name?",
        "type": "n8n-nodes-base.if",
        "typeVersion": 2,
        "position": [
          5776,
          944
        ]
      },
      {
        "parameters": {
          "method": "POST",
          "url": "={{ $env.SUPABASE_URL }}/rest/v1/contacts?on_conflict=company_id,first_name,last_name,source",
          "sendHeaders": true,
          "headerParameters": {
            "parameters": [
              {
                "name": "apikey",
                "value": "={{ $env.SUPABASE_SERVICE_KEY }}"
              },
              {
                "name": "Authorization",
                "value": "=Bearer {{ $env.SUPABASE_SERVICE_KEY }}"
              },
              {
                "name": "Content-Type",
                "value": "application/json"
              },
              {
                "name": "Prefer",
                "value": "resolution=ignore-duplicates,return=minimal"
              }
            ]
          },
          "sendBody": true,
          "specifyBody": "json",
          "jsonBody": "={{ JSON.stringify($json._contact) }}",
          "options": {
            "batching": {
              "batch": {
                "batchSize": 10,
                "batchInterval": 500
              }
            }
          }
        },
        "id": "066f3ba9-f8a3-4ffe-ae46-76f135525e99",
        "name": "Insert Contact to Supabase",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.2,
        "position": [
          6240,
          512
        ],
        "onError": "continueRegularOutput",
        "notes": "Inserts contact into Supabase contacts table. All paths (solo, apollo, website) converge here with the same _contact shape."
      },
      {
        "parameters": {
          "conditions": {
            "options": {
              "caseSensitive": true,
              "leftValue": "",
              "typeValidation": "loose"
            },
            "conditions": [
              {
                "id": "empty-check",
                "leftValue": "={{ $json._empty }}",
                "rightValue": true,
                "operator": {
                  "type": "boolean",
                  "operation": "equals",
                  "singleValue": true
                }
              }
            ],
            "combinator": "and"
          },
          "options": {}
        },
        "id": "afa86014-5ac8-4fad-a9b3-e4513f149926",
        "name": "Batch Empty?2",
        "type": "n8n-nodes-base.if",
        "typeVersion": 2,
        "position": [
          3888,
          528
        ]
      },
      {
        "parameters": {
          "jsCode": "return [{ json: { message: 'No companies need people discovery. All already have contacts or no partially/fully enriched companies found.', completed_at: new Date().toISOString() } }];"
        },
        "id": "5e50a41e-d9b9-4d52-b249-8bb73d5360fb",
        "name": "No Records - Done2",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          4112,
          432
        ]
      },
      {
        "parameters": {
          "jsCode": "// Collapse all input items into a single trigger item for the next step\nreturn [{ json: { _trigger: 'continue', _timestamp: new Date().toISOString() } }];"
        },
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          224,
          432
        ],
        "id": "7bc117c3-7316-4388-9630-869eb2b9868c",
        "name": "Bridge to 3b"
      },
      {
        "parameters": {
          "jsCode": "// Collapse all input items into a single trigger item for the next step\nreturn [{ json: { _trigger: 'continue', _timestamp: new Date().toISOString() } }];"
        },
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          2672,
          544
        ],
        "id": "9023af2e-fd90-425e-b42d-331959709141",
        "name": "Bridge to 3a"
      },
      {
        "parameters": {
          "jsCode": "// Validate & Clean Contact \u2014 runOnceForAllItems\n// Cleans emails, phones, names, LinkedIn URLs before Supabase insert.\n// Nulls out invalid data rather than blocking the insert.\n// Adds _validation_flags array for audit trail.\n\nconst items = $input.all();\nconst results = [];\n\n// Helper functions accept flags array as parameter (not closure)\nfunction validateEmail(email, fieldName, flags) {\n  if (!email) return null;\n  let cleaned = email.trim().toLowerCase();\n  const emailRegex = /^[a-zA-Z0-9._%+\\-]+@[a-zA-Z0-9.\\-]+\\.[a-zA-Z]{2,}$/;\n  if (!emailRegex.test(cleaned)) {\n    flags.push(`${fieldName}_invalid_format: \"${email}\"`);\n    return null;\n  }\n  const junkPatterns = [\n    /^noreply@/, /^no-reply@/, /^donotreply@/, /^do-not-reply@/,\n    /^test@/, /^admin@example\\./, /^info@example\\./, /^user@example\\./,\n    /^sample@/, /^fake@/, /^placeholder@/, /^null@/, /^none@/, /^na@/,\n    /^n\\/a@/, /^unknown@/, /^abuse@/, /^postmaster@/, /^mailer-daemon@/\n  ];\n  if (junkPatterns.some(p => p.test(cleaned))) {\n    flags.push(`${fieldName}_junk_pattern: \"${cleaned}\"`);\n    return null;\n  }\n  const rolePatterns = [\n    /^info@/, /^contact@/, /^hello@/, /^support@/, /^sales@/, /^office@/,\n    /^billing@/, /^reception@/, /^frontdesk@/, /^front\\.desk@/,\n    /^appointments@/, /^booking@/, /^bookings@/, /^schedule@/,\n    /^scheduling@/, /^inquiries@/, /^inquiry@/, /^general@/, /^team@/, /^staff@/\n  ];\n  if (rolePatterns.some(p => p.test(cleaned))) {\n    flags.push(`${fieldName}_role_based_kept: \"${cleaned}\"`);\n  }\n  const junkDomains = [\n    'example.com', 'example.org', 'example.net', 'test.com', 'test.org',\n    'placeholder.com', 'fake.com', 'noemail.com', 'nomail.com', 'none.com',\n    'localhost', 'mailinator.com', 'guerrillamail.com', 'tempmail.com',\n    'throwaway.email', 'yopmail.com'\n  ];\n  const domain = cleaned.split('@')[1];\n  if (junkDomains.includes(domain)) {\n    flags.push(`${fieldName}_junk_domain: \"${domain}\"`);\n    return null;\n  }\n  const localPart = cleaned.split('@')[0];\n  if (/^\\d+$/.test(localPart)) {\n    flags.push(`${fieldName}_numeric_local: \"${cleaned}\"`);\n    return null;\n  }\n  if (localPart.startsWith('.') || localPart.endsWith('.') || localPart.includes('..')) {\n    flags.push(`${fieldName}_malformed_local: \"${cleaned}\"`);\n    return null;\n  }\n  return cleaned;\n}\n\nfunction validatePhone(phone, fieldName, flags) {\n  if (!phone) return null;\n  if (typeof phone === 'object' && phone !== null) {\n    phone = phone.sanitized_number || phone.raw_number || phone.number || '';\n  }\n  let cleaned = phone.toString().trim();\n  cleaned = cleaned.replace(/[^\\d]/g, '');\n  if (!cleaned || cleaned.length === 0) {\n    flags.push(`${fieldName}_empty_after_strip`);\n    return null;\n  }\n  if (cleaned.length === 11 && cleaned.startsWith('1')) {\n    // already has country code\n  } else if (cleaned.length === 10) {\n    cleaned = '1' + cleaned;\n  } else if (cleaned.length < 10) {\n    flags.push(`${fieldName}_too_short: \"${phone}\" (${cleaned.length} digits)`);\n    return null;\n  } else if (cleaned.length > 11) {\n    flags.push(`${fieldName}_possibly_international: \"${phone}\" (${cleaned.length} digits)`);\n    return '+' + cleaned;\n  }\n  const areaCode = cleaned.substring(1, 4);\n  if (areaCode.startsWith('0') || areaCode.startsWith('1')) {\n    flags.push(`${fieldName}_invalid_area_code: \"${areaCode}\"`);\n    return null;\n  }\n  return '+' + cleaned;\n}\n\nfunction cleanName(name, fieldName, flags) {\n  if (!name) return null;\n  let cleaned = name.trim();\n  cleaned = cleaned.replace(/\\*+$/, '').trim();\n  if (cleaned.length <= 1) {\n    flags.push(`${fieldName}_too_short: \"${name}\"`);\n    return null;\n  }\n  if (/^\\d+$/.test(cleaned)) {\n    flags.push(`${fieldName}_numeric: \"${name}\"`);\n    return null;\n  }\n  if (/\\d/.test(cleaned)) {\n    flags.push(`${fieldName}_contains_digits: \"${name}\"`);\n    return null;\n  }\n  const junkNames = [\n    'unknown', 'n/a', 'na', 'none', 'null', 'test',\n    'owner', 'manager', 'admin', 'info', 'contact'\n  ];\n  if (junkNames.includes(cleaned.toLowerCase())) {\n    flags.push(`${fieldName}_junk_name: \"${name}\"`);\n    return null;\n  }\n  const credentials = [\n    'lmt', 'cmt', 'rmt', 'lmbt', 'lmp', 'bctmb', 'nctmb', 'nctm',\n    'cpt', 'cst', 'mld', 'nmt', 'amt', 'abmp'\n  ];\n  if (credentials.includes(cleaned.toLowerCase())) {\n    flags.push(`${fieldName}_credential_not_name: \"${name}\"`);\n    return null;\n  }\n  if (cleaned === cleaned.toUpperCase() || cleaned === cleaned.toLowerCase()) {\n    cleaned = cleaned.charAt(0).toUpperCase() + cleaned.slice(1).toLowerCase();\n  }\n  return cleaned;\n}\n\nfunction validateLinkedIn(url, flags) {\n  if (!url) return null;\n  let cleaned = url.trim();\n  if (!/linkedin\\.com\\/in\\//i.test(cleaned)) {\n    if (/linkedin\\.com/i.test(cleaned)) {\n      flags.push(`linkedin_not_personal_profile: \"${cleaned}\"`);\n    } else {\n      flags.push(`linkedin_invalid_url: \"${cleaned}\"`);\n    }\n    return null;\n  }\n  if (!cleaned.startsWith('http')) {\n    cleaned = 'https://' + cleaned;\n  }\n  cleaned = cleaned.replace(/^http:\\/\\//, 'https://');\n  return cleaned;\n}\n\nfor (const entry of items) {\n  const item = entry.json;\n  const contact = item._contact;\n  const flags = [];\n\n  if (!contact) {\n    results.push({ json: { ...item, _validation_flags: ['no_contact_object'] } });\n    continue;\n  }\n\n  contact.email_business = validateEmail(contact.email_business, 'email_business', flags);\n  contact.email_personal = validateEmail(contact.email_personal, 'email_personal', flags);\n  contact.phone_direct = validatePhone(contact.phone_direct, 'phone_direct', flags);\n  contact.first_name = cleanName(contact.first_name, 'first_name', flags);\n  contact.last_name = cleanName(contact.last_name, 'last_name', flags);\n\n  if (!contact.first_name) {\n    flags.push('contact_has_no_valid_first_name');\n  }\n\n  contact.linkedin_url = validateLinkedIn(contact.linkedin_url, flags);\n\n  if (contact.location) {\n    contact.location = contact.location.trim();\n    if (!contact.location || contact.location === ',' || contact.location.length < 2) {\n      contact.location = null;\n      flags.push('location_empty_after_clean');\n    }\n  }\n\n  const hasValidContact = !!(contact.first_name);\n\n  if (flags.length > 0) {\n    console.log(`Validation [${item._company_name}] (${item._source_method}): ${flags.join(', ')}`);\n  }\n\n  results.push({\n    json: {\n      _contact: contact,\n      _company_name: item._company_name,\n      _company_id: item._company_id,\n      _source_method: item._source_method,\n      _has_contact: hasValidContact,\n      _validation_flags: flags\n    }\n  });\n}\n\nreturn results;"
        },
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          6016,
          48
        ],
        "id": "3f98c182-0d4e-4978-a9c9-3beec8691ba1",
        "name": "Validate & Clean Contact"
      },
      {
        "parameters": {
          "jsCode": "// Validate & Clean Contact1 \u2014 runOnceForAllItems\nconst items = $input.all();\nconst results = [];\n\nfunction validateEmail(email, fieldName, flags) {\n  if (!email) return null;\n  let cleaned = email.trim().toLowerCase();\n  const emailRegex = /^[a-zA-Z0-9._%+\\-]+@[a-zA-Z0-9.\\-]+\\.[a-zA-Z]{2,}$/;\n  if (!emailRegex.test(cleaned)) { flags.push(`${fieldName}_invalid_format: \"${email}\"`); return null; }\n  const junkPatterns = [/^noreply@/, /^no-reply@/, /^donotreply@/, /^do-not-reply@/, /^test@/, /^admin@example\\./, /^info@example\\./, /^user@example\\./, /^sample@/, /^fake@/, /^placeholder@/, /^null@/, /^none@/, /^na@/, /^n\\/a@/, /^unknown@/, /^abuse@/, /^postmaster@/, /^mailer-daemon@/];\n  if (junkPatterns.some(p => p.test(cleaned))) { flags.push(`${fieldName}_junk_pattern: \"${cleaned}\"`); return null; }\n  const rolePatterns = [/^info@/, /^contact@/, /^hello@/, /^support@/, /^sales@/, /^office@/, /^billing@/, /^reception@/, /^frontdesk@/, /^front\\.desk@/, /^appointments@/, /^booking@/, /^bookings@/, /^schedule@/, /^scheduling@/, /^inquiries@/, /^inquiry@/, /^general@/, /^team@/, /^staff@/];\n  if (rolePatterns.some(p => p.test(cleaned))) { flags.push(`${fieldName}_role_based_kept: \"${cleaned}\"`); }\n  const junkDomains = ['example.com','example.org','example.net','test.com','test.org','placeholder.com','fake.com','noemail.com','nomail.com','none.com','localhost','mailinator.com','guerrillamail.com','tempmail.com','throwaway.email','yopmail.com'];\n  const domain = cleaned.split('@')[1];\n  if (junkDomains.includes(domain)) { flags.push(`${fieldName}_junk_domain: \"${domain}\"`); return null; }\n  const localPart = cleaned.split('@')[0];\n  if (/^\\d+$/.test(localPart)) { flags.push(`${fieldName}_numeric_local: \"${cleaned}\"`); return null; }\n  if (localPart.startsWith('.') || localPart.endsWith('.') || localPart.includes('..')) { flags.push(`${fieldName}_malformed_local: \"${cleaned}\"`); return null; }\n  return cleaned;\n}\n\nfunction validatePhone(phone, fieldName, flags) {\n  if (!phone) return null;\n  if (typeof phone === 'object' && phone !== null) { phone = phone.sanitized_number || phone.raw_number || phone.number || ''; }\n  let cleaned = phone.toString().trim().replace(/[^\\d]/g, '');\n  if (!cleaned || cleaned.length === 0) { flags.push(`${fieldName}_empty_after_strip`); return null; }\n  if (cleaned.length === 11 && cleaned.startsWith('1')) { /* ok */ }\n  else if (cleaned.length === 10) { cleaned = '1' + cleaned; }\n  else if (cleaned.length < 10) { flags.push(`${fieldName}_too_short: \"${phone}\" (${cleaned.length} digits)`); return null; }\n  else if (cleaned.length > 11) { flags.push(`${fieldName}_possibly_international: \"${phone}\" (${cleaned.length} digits)`); return '+' + cleaned; }\n  const areaCode = cleaned.substring(1, 4);\n  if (areaCode.startsWith('0') || areaCode.startsWith('1')) { flags.push(`${fieldName}_invalid_area_code: \"${areaCode}\"`); return null; }\n  return '+' + cleaned;\n}\n\nfunction cleanName(name, fieldName, flags) {\n  if (!name) return null;\n  let cleaned = name.trim().replace(/\\*+$/, '').trim();\n  if (cleaned.length <= 1) { flags.push(`${fieldName}_too_short: \"${name}\"`); return null; }\n  if (/^\\d+$/.test(cleaned)) { flags.push(`${fieldName}_numeric: \"${name}\"`); return null; }\n  if (/\\d/.test(cleaned)) { flags.push(`${fieldName}_contains_digits: \"${name}\"`); return null; }\n  const junkNames = ['unknown','n/a','na','none','null','test','owner','manager','admin','info','contact'];\n  if (junkNames.includes(cleaned.toLowerCase())) { flags.push(`${fieldName}_junk_name: \"${name}\"`); return null; }\n  const credentials = ['lmt','cmt','rmt','lmbt','lmp','bctmb','nctmb','nctm','cpt','cst','mld','nmt','amt','abmp'];\n  if (credentials.includes(cleaned.toLowerCase())) { flags.push(`${fieldName}_credential_not_name: \"${name}\"`); return null; }\n  if (cleaned === cleaned.toUpperCase() || cleaned === cleaned.toLowerCase()) { cleaned = cleaned.charAt(0).toUpperCase() + cleaned.slice(1).toLowerCase(); }\n  return cleaned;\n}\n\nfunction validateLinkedIn(url, flags) {\n  if (!url) return null;\n  let cleaned = url.trim();\n  if (!/linkedin\\.com\\/in\\//i.test(cleaned)) {\n    if (/linkedin\\.com/i.test(cleaned)) { flags.push(`linkedin_not_personal_profile: \"${cleaned}\"`); }\n    else { flags.push(`linkedin_invalid_url: \"${cleaned}\"`); }\n    return null;\n  }\n  if (!cleaned.startsWith('http')) { cleaned = 'https://' + cleaned; }\n  cleaned = cleaned.replace(/^http:\\/\\//, 'https://');\n  return cleaned;\n}\n\nfor (const entry of items) {\n  const item = entry.json;\n  const contact = item._contact;\n  const flags = [];\n  if (!contact) { results.push({ json: { ...item, _validation_flags: ['no_contact_object'] } }); continue; }\n  contact.email_business = validateEmail(contact.email_business, 'email_business', flags);\n  contact.email_personal = validateEmail(contact.email_personal, 'email_personal', flags);\n  contact.phone_direct = validatePhone(contact.phone_direct, 'phone_direct', flags);\n  contact.first_name = cleanName(contact.first_name, 'first_name', flags);\n  contact.last_name = cleanName(contact.last_name, 'last_name', flags);\n  if (!contact.first_name) { flags.push('contact_has_no_valid_first_name'); }\n  contact.linkedin_url = validateLinkedIn(contact.linkedin_url, flags);\n  if (contact.location) {\n    contact.location = contact.location.trim();\n    if (!contact.location || contact.location === ',' || contact.location.length < 2) { contact.location = null; flags.push('location_empty_after_clean'); }\n  }\n  const hasValidContact = !!(contact.first_name);\n  if (flags.length > 0) { console.log(`Validation [${item._company_name}] (${item._source_method}): ${flags.join(', ')}`); }\n  results.push({ json: { _contact: contact, _company_name: item._company_name, _company_id: item._company_id, _source_method: item._source_method, _has_contact: hasValidContact, _validation_flags: flags } });\n}\n\nreturn results;"
        },
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          6000,
          240
        ],
        "id": "7f799e2a-0c91-4e66-bc25-41a624f57f4f",
        "name": "Validate & Clean Contact1"
      },
      {
        "parameters": {
          "jsCode": "// Validate & Clean Contact2 \u2014 runOnceForAllItems\nconst items = $input.all();\nconst results = [];\n\nfunction validateEmail(email, fieldName, flags) {\n  if (!email) return null;\n  let cleaned = email.trim().toLowerCase();\n  const emailRegex = /^[a-zA-Z0-9._%+\\-]+@[a-zA-Z0-9.\\-]+\\.[a-zA-Z]{2,}$/;\n  if (!emailRegex.test(cleaned)) { flags.push(`${fieldName}_invalid_format: \"${email}\"`); return null; }\n  const junkPatterns = [/^noreply@/, /^no-reply@/, /^donotreply@/, /^do-not-reply@/, /^test@/, /^admin@example\\./, /^info@example\\./, /^user@example\\./, /^sample@/, /^fake@/, /^placeholder@/, /^null@/, /^none@/, /^na@/, /^n\\/a@/, /^unknown@/, /^abuse@/, /^postmaster@/, /^mailer-daemon@/];\n  if (junkPatterns.some(p => p.test(cleaned))) { flags.push(`${fieldName}_junk_pattern: \"${cleaned}\"`); return null; }\n  const rolePatterns = [/^info@/, /^contact@/, /^hello@/, /^support@/, /^sales@/, /^office@/, /^billing@/, /^reception@/, /^frontdesk@/, /^front\\.desk@/, /^appointments@/, /^booking@/, /^bookings@/, /^schedule@/, /^scheduling@/, /^inquiries@/, /^inquiry@/, /^general@/, /^team@/, /^staff@/];\n  if (rolePatterns.some(p => p.test(cleaned))) { flags.push(`${fieldName}_role_based_kept: \"${cleaned}\"`); }\n  const junkDomains = ['example.com','example.org','example.net','test.com','test.org','placeholder.com','fake.com','noemail.com','nomail.com','none.com','localhost','mailinator.com','guerrillamail.com','tempmail.com','throwaway.email','yopmail.com'];\n  const domain = cleaned.split('@')[1];\n  if (junkDomains.includes(domain)) { flags.push(`${fieldName}_junk_domain: \"${domain}\"`); return null; }\n  const localPart = cleaned.split('@')[0];\n  if (/^\\d+$/.test(localPart)) { flags.push(`${fieldName}_numeric_local: \"${cleaned}\"`); return null; }\n  if (localPart.startsWith('.') || localPart.endsWith('.') || localPart.includes('..')) { flags.push(`${fieldName}_malformed_local: \"${cleaned}\"`); return null; }\n  return cleaned;\n}\n\nfunction validatePhone(phone, fieldName, flags) {\n  if (!phone) return null;\n  if (typeof phone === 'object' && phone !== null) { phone = phone.sanitized_number || phone.raw_number || phone.number || ''; }\n  let cleaned = phone.toString().trim().replace(/[^\\d]/g, '');\n  if (!cleaned || cleaned.length === 0) { flags.push(`${fieldName}_empty_after_strip`); return null; }\n  if (cleaned.length === 11 && cleaned.startsWith('1')) { /* ok */ }\n  else if (cleaned.length === 10) { cleaned = '1' + cleaned; }\n  else if (cleaned.length < 10) { flags.push(`${fieldName}_too_short: \"${phone}\" (${cleaned.length} digits)`); return null; }\n  else if (cleaned.length > 11) { flags.push(`${fieldName}_possibly_international: \"${phone}\" (${cleaned.length} digits)`); return '+' + cleaned; }\n  const areaCode = cleaned.substring(1, 4);\n  if (areaCode.startsWith('0') || areaCode.startsWith('1')) { flags.push(`${fieldName}_invalid_area_code: \"${areaCode}\"`); return null; }\n  return '+' + cleaned;\n}\n\nfunction cleanName(name, fieldName, flags) {\n  if (!name) return null;\n  let cleaned = name.trim().replace(/\\*+$/, '').trim();\n  if (cleaned.length <= 1) { flags.push(`${fieldName}_too_short: \"${name}\"`); return null; }\n  if (/^\\d+$/.test(cleaned)) { flags.push(`${fieldName}_numeric: \"${name}\"`); return null; }\n  if (/\\d/.test(cleaned)) { flags.push(`${fieldName}_contains_digits: \"${name}\"`); return null; }\n  const junkNames = ['unknown','n/a','na','none','null','test','owner','manager','admin','info','contact'];\n  if (junkNames.includes(cleaned.toLowerCase())) { flags.push(`${fieldName}_junk_name: \"${name}\"`); return null; }\n  const credentials = ['lmt','cmt','rmt','lmbt','lmp','bctmb','nctmb','nctm','cpt','cst','mld','nmt','amt','abmp'];\n  if (credentials.includes(cleaned.toLowerCase())) { flags.push(`${fieldName}_credential_not_name: \"${name}\"`); return null; }\n  if (cleaned === cleaned.toUpperCase() || cleaned === cleaned.toLowerCase()) { cleaned = cleaned.charAt(0).toUpperCase() + cleaned.slice(1).toLowerCase(); }\n  return cleaned;\n}\n\nfunction validateLinkedIn(url, flags) {\n  if (!url) return null;\n  let cleaned = url.trim();\n  if (!/linkedin\\.com\\/in\\//i.test(cleaned)) {\n    if (/linkedin\\.com/i.test(cleaned)) { flags.push(`linkedin_not_personal_profile: \"${cleaned}\"`); }\n    else { flags.push(`linkedin_invalid_url: \"${cleaned}\"`); }\n    return null;\n  }\n  if (!cleaned.startsWith('http')) { cleaned = 'https://' + cleaned; }\n  cleaned = cleaned.replace(/^http:\\/\\//, 'https://');\n  return cleaned;\n}\n\nfor (const entry of items) {\n  const item = entry.json;\n  const contact = item._contact;\n  const flags = [];\n  if (!contact) { results.push({ json: { ...item, _validation_flags: ['no_contact_object'] } }); continue; }\n  contact.email_business = validateEmail(contact.email_business, 'email_business', flags);\n  contact.email_personal = validateEmail(contact.email_personal, 'email_personal', flags);\n  contact.phone_direct = validatePhone(contact.phone_direct, 'phone_direct', flags);\n  contact.first_name = cleanName(contact.first_name, 'first_name', flags);\n  contact.last_name = cleanName(contact.last_name, 'last_name', flags);\n  if (!contact.first_name) { flags.push('contact_has_no_valid_first_name'); }\n  contact.linkedin_url = validateLinkedIn(contact.linkedin_url, flags);\n  if (contact.location) {\n    contact.location = contact.location.trim();\n    if (!contact.location || contact.location === ',' || contact.location.length < 2) { contact.location = null; flags.push('location_empty_after_clean'); }\n  }\n  const hasValidContact = !!(contact.first_name);\n  if (flags.length > 0) { console.log(`Validation [${item._company_name}] (${item._source_method}): ${flags.join(', ')}`); }\n  results.push({ json: { _contact: contact, _company_name: item._company_name, _company_id: item._company_id, _source_method: item._source_method, _has_contact: hasValidContact, _validation_flags: flags } });\n}\n\nreturn results;"
        },
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          5968,
          832
        ],
        "id": "ef9c827d-5398-4066-8a8a-a97dacd4cdd2",
        "name": "Validate & Clean Contact2"
      },
      {
        "parameters": {
          "jsCode": "// Validate & Clean Contact3 \u2014 runOnceForAllItems\nconst items = $input.all();\nconst results = [];\n\nfunction validateEmail(email, fieldName, flags) {\n  if (!email) return null;\n  let cleaned = email.trim().toLowerCase();\n  const emailRegex = /^[a-zA-Z0-9._%+\\-]+@[a-zA-Z0-9.\\-]+\\.[a-zA-Z]{2,}$/;\n  if (!emailRegex.test(cleaned)) { flags.push(`${fieldName}_invalid_format: \"${email}\"`); return null; }\n  const junkPatterns = [/^noreply@/, /^no-reply@/, /^donotreply@/, /^do-not-reply@/, /^test@/, /^admin@example\\./, /^info@example\\./, /^user@example\\./, /^sample@/, /^fake@/, /^placeholder@/, /^null@/, /^none@/, /^na@/, /^n\\/a@/, /^unknown@/, /^abuse@/, /^postmaster@/, /^mailer-daemon@/];\n  if (junkPatterns.some(p => p.test(cleaned))) { flags.push(`${fieldName}_junk_pattern: \"${cleaned}\"`); return null; }\n  const rolePatterns = [/^info@/, /^contact@/, /^hello@/, /^support@/, /^sales@/, /^office@/, /^billing@/, /^reception@/, /^frontdesk@/, /^front\\.desk@/, /^appointments@/, /^booking@/, /^bookings@/, /^schedule@/, /^scheduling@/, /^inquiries@/, /^inquiry@/, /^general@/, /^team@/, /^staff@/];\n  if (rolePatterns.some(p => p.test(cleaned))) { flags.push(`${fieldName}_role_based_kept: \"${cleaned}\"`); }\n  const junkDomains = ['example.com','example.org','example.net','test.com','test.org','placeholder.com','fake.com','noemail.com','nomail.com','none.com','localhost','mailinator.com','guerrillamail.com','tempmail.com','throwaway.email','yopmail.com'];\n  const domain = cleaned.split('@')[1];\n  if (junkDomains.includes(domain)) { flags.push(`${fieldName}_junk_domain: \"${domain}\"`); return null; }\n  const localPart = cleaned.split('@')[0];\n  if (/^\\d+$/.test(localPart)) { flags.push(`${fieldName}_numeric_local: \"${cleaned}\"`); return null; }\n  if (localPart.startsWith('.') || localPart.endsWith('.') || localPart.includes('..')) { flags.push(`${fieldName}_malformed_local: \"${cleaned}\"`); return null; }\n  return cleaned;\n}\n\nfunction validatePhone(phone, fieldName, flags) {\n  if (!phone) return null;\n  if (typeof phone === 'object' && phone !== null) { phone = phone.sanitized_number || phone.raw_number || phone.number || ''; }\n  let cleaned = phone.toString().trim().replace(/[^\\d]/g, '');\n  if (!cleaned || cleaned.length === 0) { flags.push(`${fieldName}_empty_after_strip`); return null; }\n  if (cleaned.length === 11 && cleaned.startsWith('1')) { /* ok */ }\n  else if (cleaned.length === 10) { cleaned = '1' + cleaned; }\n  else if (cleaned.length < 10) { flags.push(`${fieldName}_too_short: \"${phone}\" (${cleaned.length} digits)`); return null; }\n  else if (cleaned.length > 11) { flags.push(`${fieldName}_possibly_international: \"${phone}\" (${cleaned.length} digits)`); return '+' + cleaned; }\n  const areaCode = cleaned.substring(1, 4);\n  if (areaCode.startsWith('0') || areaCode.startsWith('1')) { flags.push(`${fieldName}_invalid_area_code: \"${areaCode}\"`); return null; }\n  return '+' + cleaned;\n}\n\nfunction cleanName(name, fieldName, flags) {\n  if (!name) return null;\n  let cleaned = name.trim().replace(/\\*+$/, '').trim();\n  if (cleaned.length <= 1) { flags.push(`${fieldName}_too_short: \"${name}\"`); return null; }\n  if (/^\\d+$/.test(cleaned)) { flags.push(`${fieldName}_numeric: \"${name}\"`); return null; }\n  if (/\\d/.test(cleaned)) { flags.push(`${fieldName}_contains_digits: \"${name}\"`); return null; }\n  const junkNames = ['unknown','n/a','na','none','null','test','owner','manager','admin','info','contact'];\n  if (junkNames.includes(cleaned.toLowerCase())) { flags.push(`${fieldName}_junk_name: \"${name}\"`); return null; }\n  const credentials = ['lmt','cmt','rmt','lmbt','lmp','bctmb','nctmb','nctm','cpt','cst','mld','nmt','amt','abmp'];\n  if (credentials.includes(cleaned.toLowerCase())) { flags.push(`${fieldName}_credential_not_name: \"${name}\"`); return null; }\n  if (cleaned === cleaned.toUpperCase() || cleaned === cleaned.toLowerCase()) { cleaned = cleaned.charAt(0).toUpperCase() + cleaned.slice(1).toLowerCase(); }\n  return cleaned;\n}\n\nfunction validateLinkedIn(url, flags) {\n  if (!url) return null;\n  let cleaned = url.trim();\n  if (!/linkedin\\.com\\/in\\//i.test(cleaned)) {\n    if (/linkedin\\.com/i.test(cleaned)) { flags.push(`linkedin_not_personal_profile: \"${cleaned}\"`); }\n    else { flags.push(`linkedin_invalid_url: \"${cleaned}\"`); }\n    return null;\n  }\n  if (!cleaned.startsWith('http')) { cleaned = 'https://' + cleaned; }\n  cleaned = cleaned.replace(/^http:\\/\\//, 'https://');\n  return cleaned;\n}\n\nfor (const entry of items) {\n  const item = entry.json;\n  const contact = item._contact;\n  const flags = [];\n  if (!contact) { results.push({ json: { ...item, _validation_flags: ['no_contact_object'] } }); continue; }\n  contact.email_business = validateEmail(contact.email_business, 'email_business', flags);\n  contact.email_personal = validateEmail(contact.email_personal, 'email_personal', flags);\n  contact.phone_direct = validatePhone(contact.phone_direct, 'phone_direct', flags);\n  contact.first_name = cleanName(contact.first_name, 'first_name', flags);\n  contact.last_name = cleanName(contact.last_name, 'last_name', flags);\n  if (!contact.first_name) { flags.push('contact_has_no_valid_first_name'); }\n  contact.linkedin_url = validateLinkedIn(contact.linkedin_url, flags);\n  if (contact.location) {\n    contact.location = contact.location.trim();\n    if (!contact.location || contact.location === ',' || contact.location.length < 2) { contact.location = null; flags.push('location_empty_after_clean'); }\n  }\n  const hasValidContact = !!(contact.first_name);\n  if (flags.length > 0) { console.log(`Validation [${item._company_name}] (${item._source_method}): ${flags.join(', ')}`); }\n  results.push({ json: { _contact: contact, _company_name: item._company_name, _company_id: item._company_id, _source_method: item._source_method, _has_contact: hasValidContact, _validation_flags: flags } });\n}\n\nreturn results;"
        },
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          5888,
          448
        ],
        "id": "23432a36-a9b1-4fd6-a586-1467184c9ffc",
        "name": "Validate & Clean Contact3"
      },
      {
        "parameters": {
          "jsCode": "// Validate & Clean Contact4 \u2014 runOnceForAllItems\nconst items = $input.all();\nconst results = [];\n\nfunction validateEmail(email, fieldName, flags) {\n  if (!email) return null;\n  let cleaned = email.trim().toLowerCase();\n  const emailRegex = /^[a-zA-Z0-9._%+\\-]+@[a-zA-Z0-9.\\-]+\\.[a-zA-Z]{2,}$/;\n  if (!emailRegex.test(cleaned)) { flags.push(`${fieldName}_invalid_format: \"${email}\"`); return null; }\n  const junkPatterns = [/^noreply@/, /^no-reply@/, /^donotreply@/, /^do-not-reply@/, /^test@/, /^admin@example\\./, /^info@example\\./, /^user@example\\./, /^sample@/, /^fake@/, /^placeholder@/, /^null@/, /^none@/, /^na@/, /^n\\/a@/, /^unknown@/, /^abuse@/, /^postmaster@/, /^mailer-daemon@/];\n  if (junkPatterns.some(p => p.test(cleaned))) { flags.push(`${fieldName}_junk_pattern: \"${cleaned}\"`); return null; }\n  const rolePatterns = [/^info@/, /^contact@/, /^hello@/, /^support@/, /^sales@/, /^office@/, /^billing@/, /^reception@/, /^frontdesk@/, /^front\\.desk@/, /^appointments@/, /^booking@/, /^bookings@/, /^schedule@/, /^scheduling@/, /^inquiries@/, /^inquiry@/, /^general@/, /^team@/, /^staff@/];\n  if (rolePatterns.some(p => p.test(cleaned))) { flags.push(`${fieldName}_role_based_kept: \"${cleaned}\"`); }\n  const junkDomains = ['example.com','example.org','example.net','test.com','test.org','placeholder.com','fake.com','noemail.com','nomail.com','none.com','localhost','mailinator.com','guerrillamail.com','tempmail.com','throwaway.email','yopmail.com'];\n  const domain = cleaned.split('@')[1];\n  if (junkDomains.includes(domain)) { flags.push(`${fieldName}_junk_domain: \"${domain}\"`); return null; }\n  const localPart = cleaned.split('@')[0];\n  if (/^\\d+$/.test(localPart)) { flags.push(`${fieldName}_numeric_local: \"${cleaned}\"`); return null; }\n  if (localPart.startsWith('.') || localPart.endsWith('.') || localPart.includes('..')) { flags.push(`${fieldName}_malformed_local: \"${cleaned}\"`); return null; }\n  return cleaned;\n}\n\nfunction validatePhone(phone, fieldName, flags) {\n  if (!phone) return null;\n  if (typeof phone === 'object' && phone !== null) { phone = phone.sanitized_number || phone.raw_number || phone.number || ''; }\n  let cleaned = phone.toString().trim().replace(/[^\\d]/g, '');\n  if (!cleaned || cleaned.length === 0) { flags.push(`${fieldName}_empty_after_strip`); return null; }\n  if (cleaned.length === 11 && cleaned.startsWith('1')) { /* ok */ }\n  else if (cleaned.length === 10) { cleaned = '1' + cleaned; }\n  else if (cleaned.length < 10) { flags.push(`${fieldName}_too_short: \"${phone}\" (${cleaned.length} digits)`); return null; }\n  else if (cleaned.length > 11) { flags.push(`${fieldName}_possibly_international: \"${phone}\" (${cleaned.length} digits)`); return '+' + cleaned; }\n  const areaCode = cleaned.substring(1, 4);\n  if (areaCode.startsWith('0') || areaCode.startsWith('1')) { flags.push(`${fieldName}_invalid_area_code: \"${areaCode}\"`); return null; }\n  return '+' + cleaned;\n}\n\nfunction cleanName(name, fieldName, flags) {\n  if (!name) return null;\n  let cleaned = name.trim().replace(/\\*+$/, '').trim();\n  if (cleaned.length <= 1) { flags.push(`${fieldName}_too_short: \"${name}\"`); return null; }\n  if (/^\\d+$/.test(cleaned)) { flags.push(`${fieldName}_numeric: \"${name}\"`); return null; }\n  if (/\\d/.test(cleaned)) { flags.push(`${fieldName}_contains_digits: \"${name}\"`); return null; }\n  const junkNames = ['unknown','n/a','na','none','null','test','owner','manager','admin','info','contact'];\n  if (junkNames.includes(cleaned.toLowerCase())) { flags.push(`${fieldName}_junk_name: \"${name}\"`); return null; }\n  const credentials = ['lmt','cmt','rmt','lmbt','lmp','bctmb','nctmb','nctm','cpt','cst','mld','nmt','amt','abmp'];\n  if (credentials.includes(cleaned.toLowerCase())) { flags.push(`${fieldName}_credential_not_name: \"${name}\"`); return null; }\n  if (cleaned === cleaned.toUpperCase() || cleaned === cleaned.toLowerCase()) { cleaned = cleaned.charAt(0).toUpperCase() + cleaned.slice(1).toLowerCase(); }\n  return cleaned;\n}\n\nfunction validateLinkedIn(url, flags) {\n  if (!url) return null;\n  let cleaned = url.trim();\n  if (!/linkedin\\.com\\/in\\//i.test(cleaned)) {\n    if (/linkedin\\.com/i.test(cleaned)) { flags.push(`linkedin_not_personal_profile: \"${cleaned}\"`); }\n    else { flags.push(`linkedin_invalid_url: \"${cleaned}\"`); }\n    return null;\n  }\n  if (!cleaned.startsWith('http')) { cleaned = 'https://' + cleaned; }\n  cleaned = cleaned.replace(/^http:\\/\\//, 'https://');\n  return cleaned;\n}\n\nfor (const entry of items) {\n  const item = entry.json;\n  const contact = item._contact;\n  const flags = [];\n  if (!contact) { results.push({ json: { ...item, _validation_flags: ['no_contact_object'] } }); continue; }\n  contact.email_business = validateEmail(contact.email_business, 'email_business', flags);\n  contact.email_personal = validateEmail(contact.email_personal, 'email_personal', flags);\n  contact.phone_direct = validatePhone(contact.phone_direct, 'phone_direct', flags);\n  contact.first_name = cleanName(contact.first_name, 'first_name', flags);\n  contact.last_name = cleanName(contact.last_name, 'last_name', flags);\n  if (!contact.first_name) { flags.push('contact_has_no_valid_first_name'); }\n  contact.linkedin_url = validateLinkedIn(contact.linkedin_url, flags);\n  if (contact.location) {\n    contact.location = contact.location.trim();\n    if (!contact.location || contact.location === ',' || contact.location.length < 2) { contact.location = null; flags.push('location_empty_after_clean'); }\n  }\n  const hasValidContact = !!(contact.first_name);\n  if (flags.length > 0) { console.log(`Validation [${item._company_name}] (${item._source_method}): ${flags.join(', ')}`); }\n  results.push({ json: { _contact: contact, _company_name: item._company_name, _company_id: item._company_id, _source_method: item._source_method, _has_contact: hasValidContact, _validation_flags: flags } });\n}\n\nreturn results;"
        },
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          5936,
          608
        ],
        "id": "f8e4ca4c-af65-407f-ad5c-255c26983df3",
        "name": "Validate & Clean Contact4"
      },
      {
        "parameters": {
          "jsCode": "// Collect stats from all paths\nconst config = $('Step 3a Config').first().json;\nlet companiesProcessed = 0;\nlet soloDetected = 0;\nlet soloWithName = 0;\nlet apolloSearched = 0;\nlet apolloFound = 0;\nlet apolloEnriched = 0;\nlet websiteScraped = 0;\nlet websiteFoundName = 0;\nlet noDomainFallback = 0;\nlet noDomainFoundName = 0;\nlet totalContactsInserted = 0;\n\n// Validation stats\nlet validationTotal = 0;\nlet emailsNulled = 0;\nlet phonesNulled = 0;\nlet namesNulled = 0;\nlet linkedinNulled = 0;\nlet roleBasedEmails = 0;\nlet contactsWithFlags = 0;\nlet allFlags = [];\n\ntry {\n  const batchItems = $('Filter & Parse Batch').all();\n  companiesProcessed = batchItems.filter(i => !i.json._empty).length;\n} catch(e) {}\n\ntry {\n  const soloItems = $('Prepare Solo Contact').all();\n  soloDetected = soloItems.length;\n  soloWithName = soloItems.filter(i => i.json._has_contact).length;\n} catch(e) {}\n\ntry {\n  const apolloItems = $('Parse Apollo Search').all();\n  apolloSearched = apolloItems.length;\n  apolloFound = apolloItems.filter(i => i.json._apollo_found).length;\n} catch(e) {}\n\ntry {\n  const enrichItems = $('Parse Apollo Enrich').all();\n  apolloEnriched = enrichItems.filter(i => i.json._has_contact).length;\n} catch(e) {}\n\ntry {\n  const searchOnlyItems = $('Apollo Search Only Contact').all();\n  apolloEnriched += searchOnlyItems.filter(i => i.json._has_contact).length;\n} catch(e) {}\n\ntry {\n  const aboutItems = $('Parse About Page').all();\n  websiteScraped = aboutItems.length;\n  websiteFoundName = aboutItems.filter(i => i.json._has_contact).length;\n} catch(e) {}\n\ntry {\n  const noDomainItems = $('No Domain Fallback').all();\n  noDomainFallback = noDomainItems.length;\n  noDomainFoundName = noDomainItems.filter(i => i.json._has_contact).length;\n} catch(e) {}\n\n// Collect validation stats from all 5 Validate & Clean nodes\nconst validateNodeNames = [\n  'Validate & Clean Contact',\n  'Validate & Clean Contact1',\n  'Validate & Clean Contact2',\n  'Validate & Clean Contact3',\n  'Validate & Clean Contact4'\n];\n\nfor (const nodeName of validateNodeNames) {\n  try {\n    const validatedItems = $(nodeName).all();\n    validationTotal += validatedItems.length;\n    for (const item of validatedItems) {\n      const flags = item.json._validation_flags || [];\n      if (flags.length > 0) {\n        contactsWithFlags++;\n        allFlags.push(...flags);\n      }\n    }\n  } catch(e) {\n    // Node didn't execute in this run (normal - not all paths fire every time)\n  }\n}\n\nemailsNulled = allFlags.filter(f => f.startsWith('email_business_') || f.startsWith('email_personal_')).length;\nphonesNulled = allFlags.filter(f => f.startsWith('phone_direct_')).length;\nnamesNulled = allFlags.filter(f => f.startsWith('first_name_') || f.startsWith('last_name_') || f === 'contact_has_no_valid_first_name').length;\nlinkedinNulled = allFlags.filter(f => f.startsWith('linkedin_')).length;\nroleBasedEmails = allFlags.filter(f => f.includes('_role_based')).length;\n\ntotalContactsInserted = soloWithName + apolloEnriched + websiteFoundName + noDomainFoundName;\n\nconst summary = {\n  run_completed_at: new Date().toISOString(),\n  batch_size: config.batch_size,\n  companies_processed: companiesProcessed,\n  solo_detected: soloDetected,\n  solo_with_name_extracted: soloWithName,\n  apollo_searched: apolloSearched,\n  apollo_found_people: apolloFound,\n  apollo_contacts_created: apolloEnriched,\n  website_scraped: websiteScraped,\n  website_names_found: websiteFoundName,\n  no_domain_fallback: noDomainFallback,\n  no_domain_names_found: noDomainFoundName,\n  total_contacts_inserted: totalContactsInserted,\n  companies_without_contacts: companiesProcessed - totalContactsInserted,\n  validation: {\n    contacts_validated: validationTotal,\n    contacts_with_issues: contactsWithFlags,\n    emails_nulled: emailsNulled,\n    role_based_emails_rejected: roleBasedEmails,\n    phones_nulled: phonesNulled,\n    names_nulled: namesNulled,\n    linkedin_nulled: linkedinNulled,\n    all_flags: allFlags\n  },\n  message: `Created ${totalContactsInserted} contacts from ${companiesProcessed} companies. Sources: ${soloWithName} solo, ${apolloEnriched} Apollo, ${websiteFoundName} website, ${noDomainFoundName} name extraction. Validation cleaned ${contactsWithFlags}/${validationTotal} contacts (${emailsNulled} emails, ${phonesNulled} phones, ${namesNulled} names nulled).`\n};\n\nconsole.log('=== STEP 3a: FIND PEOPLE SUMMARY ===');\nconsole.log(JSON.stringify(summary, null, 2));\n\nreturn [{ json: summary }];"
        },
        "id": "81ffb1a3-dddc-4389-986a-d0b69d280c2b",
        "name": "Run Summary3",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          6528,
          352
        ],
        "notes": "Final summary: contacts created from each source (solo detection, Apollo, website scrape, name extraction)."
      },
      {
        "parameters": {
          "assignments": {
            "assignments": [
              {
                "name": "skip_hunter",
                "value": "false",
                "type": "string"
              },
              {
                "name": "skip_snovio",
                "value": "true",
                "type": "string"
              },
              {
                "name": "skip_hunter_verifier",
                "value": "false",
                "type": "string"
              },
              {
                "name": "skip_namsor",
                "value": "false",
                "type": "string"
              },
              {
                "name": "skip_phone_verifier",
                "value": "false",
                "type": "string"
              },
              {
                "name": "batch_size",
                "value": "1000",
                "type": "string"
              },
              {
                "name": "batch_offset",
                "value": "0",
                "type": "string"
              }
            ]
          },
          "options": {}
        },
        "id": "28d78eda-3435-4c71-8976-ff2199966651",
        "name": "Step 4 Config",
        "type": "n8n-nodes-base.set",
        "typeVersion": 3.4,
        "position": [
          6976,
          352
        ],
        "notes": "Config for Step 4: Enrich People.\n- skip_hunter/skip_snovio: set to 'true' to disable. Set to 'false' when ready.\n- skip_hunter_verifier: 'true' = skip email verification, 'false' = verify emails via Hunter\n- skip_namsor: 'false' = enabled (NamSor API key required as NAMSOR_API_KEY env var)\n- batch_size: how many contacts to process"
      },
      {
        "parameters": {
          "url": "={{ $env.SUPABASE_URL }}/rest/v1/contacts?select=id,company_id,first_name,last_name,role,is_owner,email_business,email_personal,phone_direct,linkedin_url,cultural_affinity,source,email_status,phone_status,phone_line_type,phone_carrier&or=(email_status.is.null,email_status.eq.unverified,and(phone_direct.not.is.null,phone_status.is.null))&order=created_at.asc&limit={{ $json.batch_size }}&offset={{ $json.batch_offset }}",
          "sendHeaders": true,
          "headerParameters": {
            "parameters": [
              {
                "name": "apikey",
                "value": "={{ $env.SUPABASE_SERVICE_KEY }}"
              },
              {
                "name": "Authorization",
                "value": "=Bearer {{ $env.SUPABASE_SERVICE_KEY }}"
              }
            ]
          },
          "options": {
            "timeout": 30000
          }
        },
        "id": "f722b2cc-4a9e-4e35-9f4d-392f03f00973",
        "name": "Fetch Contacts",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.2,
        "position": [
          7200,
          352
        ],
        "onError": "continueRegularOutput",
        "notes": "Fetches all contacts from Supabase for enrichment",
        "alwaysOutputData": true
      },
      {
        "parameters": {
          "jsCode": "// Merge contacts with their company data and filter to those needing enrichment\n// Metro-scoped: only process contacts whose company is in the current metro\nconst contactItems = $('Fetch Contacts').all();\nconst companyItems = $('Fetch Companies1').all();\n\n// Parse contacts - deduplicate by id\nlet rawContacts = [];\nfor (const item of contactItems) {\n  if (item.json && Array.isArray(item.json)) {\n    rawContacts.push(...item.json);\n  } else if (item.json && item.json.id) {\n    rawContacts.push(item.json);\n  }\n}\n\n// Deduplicate by contact id\nconst seenIds = new Set();\nlet contacts = [];\nfor (const c of rawContacts) {\n  if (c.id && !seenIds.has(c.id)) {\n    seenIds.add(c.id);\n    contacts.push(c);\n  }\n}\n\n// Parse companies into a lookup map (map deduplicates naturally)\n// NOTE: Fetch Companies1 is now metro-scoped, so this map only contains current metro companies\nlet companyMap = {};\nfor (const item of companyItems) {\n  if (Array.isArray(item.json)) {\n    for (const co of item.json) {\n      if (co.id) companyMap[co.id] = co;\n    }\n  } else if (item.json && item.json.id) {\n    companyMap[item.json.id] = item.json;\n  }\n}\n\n// Filter contacts that need enrichment:\n// any contact where there's still something to enrich\nconst needsEnrichment = contacts.filter(c => {\n  const missingEmail = !c.email_business;\n  const missingCulturalAffinity = !c.cultural_affinity;\n  const missingPhone = !c.phone_direct;\n  const missingLinkedin = !c.linkedin_url;\n  const verifiedStatuses = ['verified', 'invalid', 'risky', 'accept_all'];\n  const emailNeedsVerification = c.email_business && !verifiedStatuses.includes(c.email_status);\n  const phoneNeedsVerification = c.phone_direct && !c.phone_status;\n  return missingEmail || missingCulturalAffinity || missingPhone || missingLinkedin || emailNeedsVerification || phoneNeedsVerification;\n});\n\n// Metro filter: only keep contacts whose company is in the metro-scoped companyMap\nconst metroFiltered = needsEnrichment.filter(c => companyMap[c.company_id]);\nconst crossMetroSkipped = needsEnrichment.length - metroFiltered.length;\n\nconsole.log(`Contacts: ${rawContacts.length} raw, ${contacts.length} unique, ${needsEnrichment.length} need enrichment, ${crossMetroSkipped} skipped (other metro), ${metroFiltered.length} in current metro`);\n\nif (metroFiltered.length === 0) {\n  return [{ json: { _empty: true, _count: 0, _message: 'All contacts are already enriched or belong to other metros' } }];\n}\n\n// Merge company data into each contact\nconst merged = metroFiltered.map(c => {\n  const company = companyMap[c.company_id];\n  return {\n    json: {\n      ...c,\n      _company_name: company.name || null,\n      _company_domain: company.domain || null,\n      _company_phone: company.phone || null,\n      _company_email: company.email || null,\n      _company_email_status: company.email_status || null,\n      _company_phone_status: company.phone_status || null,\n      _company_phone_line_type: company.phone_line_type || null,\n      _company_city: company.city || null,\n      _company_state: company.state || null\n    }\n  };\n});\n\nreturn merged;"
        },
        "id": "424ffbc6-0f1d-45d5-84e5-d5ec97a212bf",
        "name": "Filter & Merge Contacts",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          7872,
          352
        ],
        "notes": "Merges contact data with company data. Filters to contacts that still need enrichment (missing email, cultural_affinity, phone, linkedin, OR email_status is unverified)."
      },
      {
        "parameters": {
          "url": "={{ $env.SUPABASE_URL }}/rest/v1/companies?select=id,name,phone,domain,email,email_status,phone_status,phone_line_type,city,state&enrichment_status=in.(partially_enriched,fully_enriched)&discovery_metro=eq.{{ $('Metro Config').first().json.metro_name }}",
          "sendHeaders": true,
          "headerParameters": {
            "parameters": [
              {
                "name": "apikey",
                "value": "={{ $env.SUPABASE_SERVICE_KEY }}"
              },
              {
                "name": "Authorization",
                "value": "=Bearer {{ $env.SUPABASE_SERVICE_KEY }}"
              }
            ]
          },
          "options": {
            "timeout": 30000
          }
        },
        "id": "12495704-e95c-4ee8-854d-39cb85a6cf1c",
        "name": "Fetch Companies1",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.2,
        "position": [
          7648,
          352
        ],
        "onError": "continueRegularOutput",
        "notes": "Fetches company data (domain, phone, city) to support enrichment lookups"
      },
      {
        "parameters": {
          "conditions": {
            "options": {
              "caseSensitive": true,
              "leftValue": "",
              "typeValidation": "loose"
            },
            "conditions": [
              {
                "id": "is-empty",
                "leftValue": "={{ $json._empty }}",
                "rightValue": true,
                "operator": {
                  "type": "boolean",
                  "operation": "equals",
                  "singleValue": true
                }
              }
            ],
            "combinator": "and"
          },
          "options": {}
        },
        "id": "f0e8ee2e-ba25-4ddc-8fc9-f25bf468e1bb",
        "name": "Batch Empty?3",
        "type": "n8n-nodes-base.if",
        "typeVersion": 2,
        "position": [
          8096,
          352
        ]
      },
      {
        "parameters": {
          "jsCode": "return [{ json: { message: 'No contacts need enrichment. All done!', completed_at: new Date().toISOString() } }];"
        },
        "id": "0ae0b2d6-d1ac-4d25-bf41-a7817ebd95b2",
        "name": "No Records - Done3",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          8320,
          256
        ]
      },
      {
        "parameters": {
          "jsCode": "// Collapse all input items into a single trigger item for the next step\nreturn [{ json: { _trigger: 'continue', _timestamp: new Date().toISOString() } }];"
        },
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          6752,
          352
        ],
        "id": "29d1f7d6-d097-4eca-a42a-966f358a03fd",
        "name": "Bridge to 4"
      },
      {
        "parameters": {
          "jsCode": "// Collapse to single item - Fetch Contacts data is accessed by name in Filter & Merge\nreturn [{ json: { _trigger: 'fetch_companies' } }];"
        },
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          7424,
          352
        ],
        "id": "4a038b1f-ec8a-4141-b23a-181f1cfa1d08",
        "name": "Collapse to Single"
      },
      {
        "parameters": {
          "jsCode": "// Enrich Contacts \u2014 Single Code node replacing the entire Step 4 branching pipeline\n// Mode: runOnceForAllItems\n// Uses this.helpers.httpRequest() for inline HTTP calls (NOT $http which is unavailable)\n\nconst config = $('Step 4 Config').first().json;\nconst contacts = $input.all().filter(item => !item.json._empty);\n\nconst results = [];\n\n// Helper: delay between API calls for rate limiting\nconst delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));\n\n// Dedup guard: track companies that already had email set/verified this execution\nconst staticData = $getWorkflowStaticData('global');\nif (!staticData._companyEmailsSet) staticData._companyEmailsSet = {};\nconst companyEmailsSet = staticData._companyEmailsSet;\n\n// BUG-F019 FIX: Clear ALL stale keys from previous executions.\n// $getWorkflowStaticData('global') persists across executions, not just batches.\n// Without this, company phone/email dedup guards from previous runs permanently\n// block verification for companies that were already processed.\n// Within a single execution, keys are rebuilt as contacts are processed.\nfor (const key of Object.keys(companyEmailsSet)) {\n  delete companyEmailsSet[key];\n}\n\n// ADR-024: Per-contact dedup \u2014 track enriched contacts across convergence batches\nif (!staticData._enriched_contact_ids) {\n  staticData._enriched_contact_ids = {};\n}\n\n// Phone validation (from Prepare Contact Update)\nfunction validatePhone(phone) {\n  if (!phone) return null;\n  if (typeof phone === 'object' && phone !== null) {\n    phone = phone.sanitized_number || phone.raw_number || phone.number || '';\n  }\n  let cleaned = phone.toString().trim().replace(/[^\\d]/g, '');\n  if (!cleaned || cleaned.length === 0) return null;\n  if (cleaned.length === 11 && cleaned.startsWith('1')) { /* ok */ }\n  else if (cleaned.length === 10) { cleaned = '1' + cleaned; }\n  else if (cleaned.length < 10) { return null; }\n  else if (cleaned.length > 11 && cleaned.length <= 15) {\n    // International number - allow if not starting with 1 (NA)\n    if (cleaned.startsWith('1')) return null;  // NA number too long\n    return '+' + cleaned;\n  }\n  else if (cleaned.length > 15) { return null; }  // ITU max is 15 digits\n  const areaCode = cleaned.substring(1, 4);\n  if (areaCode.startsWith('0') || areaCode.startsWith('1')) return null;\n  return '+' + cleaned;\n}\n\n// Role-based email detection (same 19+1 patterns as Validate & Clean Contact)\nconst rolePatterns = [\n  /^info@/i, /^contact@/i, /^hello@/i, /^support@/i, /^sales@/i,\n  /^office@/i, /^billing@/i, /^reception@/i, /^frontdesk@/i, /^front\\.desk@/i,\n  /^appointments@/i, /^booking@/i, /^bookings@/i, /^schedule@/i, /^scheduling@/i,\n  /^inquiries@/i, /^inquiry@/i, /^general@/i, /^team@/i, /^staff@/i\n];\n\nfunction isRoleBased(email) {\n  if (!email) return false;\n  return rolePatterns.some(p => p.test(email));\n}\n\n// Free webmail domains (role-based check doesn't apply to these)\nconst freeWebmailDomains = [\n  'gmail.com', 'yahoo.com', 'outlook.com', 'hotmail.com', 'aol.com',\n  'icloud.com', 'me.com', 'mac.com', 'live.com', 'msn.com',\n  'protonmail.com', 'proton.me', 'zoho.com', 'yandex.com',\n  'mail.com', 'gmx.com', 'fastmail.com', 'tutanota.com'\n];\n\nfunction isFreeWebmail(email) {\n  if (!email) return false;\n  const domain = email.split('@')[1];\n  return freeWebmailDomains.includes(domain);\n}\n\n// Helper: verify an email via Hunter Verifier API\nasync function verifyEmail(email) {\n  try {\n    const verifyUrl = `https://api.hunter.io/v2/email-verifier?email=${encodeURIComponent(email)}&api_key=${$env.HUNTER_API_KEY}`;\n    const verifyResp = await this.helpers.httpRequest({ method: 'GET', url: verifyUrl, headers: { 'Accept': 'application/json' }, json: true });\n    const vBody = verifyResp.data || verifyResp;\n    if (vBody && vBody.status) {\n      let status;\n      switch (vBody.status) {\n        case 'valid': status = 'verified'; break;\n        case 'invalid': status = 'invalid'; break;\n        case 'accept_all': status = 'accept_all'; break;\n        case 'disposable': status = 'invalid'; break;\n        case 'webmail': status = 'verified'; break;\n        default: status = 'risky'; break;\n      }\n      return { status, score: vBody.score || null, verified_at: new Date().toISOString() };\n    }\n  } catch(e) {\n    console.log(`Verifier error for ${email}: ${e.message}`);\n  }\n  return null;\n}\n\n// Helper: verify a phone number via Telnyx Number Lookup API\nasync function verifyPhone(phoneNumber) {\n  try {\n    const resp = await this.helpers.httpRequest({\n      method: 'GET',\n      url: `https://api.telnyx.com/v2/number_lookup/${encodeURIComponent(phoneNumber)}?type=carrier`,\n      headers: {\n        'Authorization': `Bearer ${$env.TELNYX_API_KEY}`,\n        'Accept': 'application/json'\n      },\n      json: true\n    });\n    const data = resp.data || resp;\n    if (data && data.valid === false) {\n      return { phone_status: 'invalid', phone_line_type: null, phone_carrier: null };\n    }\n    // Map carrier type\n    let lineType = null;\n    const carrierType = (data.carrier && data.carrier.type) || null;\n    if (carrierType) {\n      const typeMap = { 'mobile': 'mobile', 'landline': 'landline', 'fixed line': 'landline', 'voip': 'voip', 'toll free': 'toll_free', 'toll_free': 'toll_free' };\n      lineType = typeMap[carrierType.toLowerCase()] || null;\n    }\n    const carrierName = (data.carrier && data.carrier.name) || null;\n    const phoneStatus = lineType === 'voip' ? 'voip' : 'valid';\n    return {\n      phone_status: phoneStatus,\n      phone_line_type: lineType,\n      phone_carrier: carrierName\n    };\n  } catch(e) {\n    // 404 or 422 = invalid number\n    if (e.statusCode === 404 || e.statusCode === 422) {\n      return { phone_status: 'invalid', phone_line_type: null, phone_carrier: null };\n    }\n    console.log(`Telnyx error for ${phoneNumber}: ${e.message} (status: ${e.statusCode || 'unknown'})`);\n    return { phone_status: null, phone_line_type: null, phone_carrier: null, _error: `${e.statusCode || 'unknown'}: ${e.message}` };\n  }\n}\n\nfor (const item of contacts) {\n  const contact = { ...item.json };\n\n  // ADR-024: Skip if already enriched in a previous convergence batch\n  const contactId = contact.id;\n  if (staticData._enriched_contact_ids[contactId]) {\n    results.push({\n      json: {\n        _contact_id: contactId,\n        _company_id: contact.company_id,\n        _first_name: contact.first_name,\n        _last_name: contact.last_name,\n        _company_name: contact._company_name,\n        _skip_reason: 'already_enriched_in_earlier_batch',\n        _has_updates: false\n      }\n    });\n    continue;\n  }\n  // Mark as enriched\n  staticData._enriched_contact_ids[contactId] = true;\n\n  // Initialize enrichment fields\n  contact._hunter_email = null;\n  contact._hunter_score = 0;\n  contact._hunter_linkedin = null;\n  contact._hunter_phone = null;\n  contact._snovio_email = null;\n  contact._email_source = null;\n  contact._best_email = contact.email_business || null;\n  contact._best_phone = contact.phone_direct || contact._company_phone || null;\n  contact._best_linkedin = contact.linkedin_url || null;\n  contact._email_status = null;\n  contact._email_verified_at = null;\n  contact._verifier_score = null;\n  contact._cultural_affinity = contact.cultural_affinity || null;\n  contact._namsor_country = null;\n  contact._namsor_region = null;\n  contact._namsor_probability = null;\n  contact._company_email_routed = false;\n  contact._company_email_verified = false;\n  contact._phone_status = null;\n  contact._phone_line_type = null;\n  contact._phone_carrier = null;\n  contact._company_phone_verified = false;\n  contact._phone_error = null;\n\n  const needsEmail = !contact.email_business;\n  const hasDomainAndName = contact._company_domain && contact.first_name;\n  const verifiedStatuses = ['verified', 'invalid', 'risky', 'accept_all'];\n  const emailNeedsVerification = contact.email_business && !verifiedStatuses.includes(contact.email_status);\n\n  // EMAIL WATERFALL\n\n  if (needsEmail && hasDomainAndName) {\n    // --- HUNTER EMAIL FINDER ---\n    if (config.skip_hunter !== 'true') {\n      try {\n        const hunterUrl = `https://api.hunter.io/v2/email-finder?domain=${encodeURIComponent(contact._company_domain)}&first_name=${encodeURIComponent(contact.first_name)}&last_name=${encodeURIComponent(contact.last_name || '')}&api_key=${$env.HUNTER_API_KEY}`;\n        const hunterResp = await this.helpers.httpRequest({ method: 'GET', url: hunterUrl, headers: { 'Accept': 'application/json' }, json: true });\n        const hData = hunterResp.data || hunterResp;\n        if (hData && hData.email && (hData.score === undefined || hData.score >= 50)) {\n          contact._hunter_email = hData.email;\n          contact._hunter_score = hData.score || 0;\n          contact._hunter_linkedin = hData.linkedin_url || null;\n          contact._hunter_phone = hData.phone_number || null;\n          contact._email_source = 'hunter';\n        }\n        await delay(200);\n      } catch(e) {\n        console.log(`Hunter error for ${contact.first_name}: ${e.message}`);\n      }\n    }\n\n    // --- SNOV.IO EMAIL FINDER (fallback) ---\n    if (!contact._hunter_email && config.skip_snovio !== 'true') {\n      try {\n        const snovResp = await this.helpers.httpRequest({\n          method: 'POST',\n          url: 'https://api.snov.io/v1/get-emails-from-names',\n          headers: { 'Content-Type': 'application/json' },\n          body: {\n            firstName: contact.first_name,\n            lastName: contact.last_name || '',\n            domain: contact._company_domain\n          },\n          json: true\n        });\n        const emails = snovResp.emails || snovResp.data?.emails || [];\n        if (Array.isArray(emails) && emails.length > 0) {\n          const valid = emails.find(e => e.emailStatus === 'valid' || e.status === 'valid') || emails[0];\n          contact._snovio_email = valid.email || valid.value || null;\n          if (contact._snovio_email) contact._email_source = 'snovio';\n        }\n        await delay(500);\n      } catch(e) {\n        console.log(`Snov.io error for ${contact.first_name}: ${e.message}`);\n      }\n    }\n\n    contact._best_email = contact._hunter_email || contact._snovio_email || null;\n    contact._best_phone = contact.phone_direct || contact._hunter_phone || contact._company_phone || null;\n    contact._best_linkedin = contact.linkedin_url || contact._hunter_linkedin || null;\n  } else if (contact.email_business) {\n    contact._best_email = contact.email_business;\n    contact._email_source = 'existing';\n  }\n\n  // COMPANY EMAIL ROUTING\n  // If contact's email is role-based, route it to the company\n\n  if (contact._best_email && isRoleBased(contact._best_email) && !isFreeWebmail(contact._best_email)) {\n    const companyId = contact.company_id;\n    const companyHasEmail = !!(contact._company_email);\n\n    if (!companyHasEmail && !companyEmailsSet[companyId]) {\n      contact._routed_company_email = contact._best_email;\n      contact._company_email_routed = true;\n      companyEmailsSet[companyId] = contact._best_email;\n      console.log(`Routed role-based email ${contact._best_email} to company ${contact._company_name || companyId}`);\n    }\n\n    if (contact.email_personal) {\n      contact._best_email = contact.email_personal;\n      contact._email_source = 'personal_promoted';\n      console.log(`Promoted personal email ${contact.email_personal} for ${contact.first_name} (role-based went to company)`);\n    }\n  }\n\n  // EMAIL VERIFICATION (contact email)\n\n  if (contact._best_email && config.skip_hunter_verifier !== 'true') {\n    const shouldVerify = !contact.email_business || emailNeedsVerification || contact._email_source === 'hunter' || contact._email_source === 'snovio' || contact._email_source === 'personal_promoted';\n    if (shouldVerify) {\n      const vResult = await verifyEmail.call(this, contact._best_email);\n      if (vResult) {\n        contact._email_status = vResult.status;\n        contact._email_verified_at = vResult.verified_at;\n        contact._verifier_score = vResult.score;\n      }\n      await delay(700);\n    }\n  } else if (contact._best_email) {\n    contact._email_status = 'unverified';\n  }\n\n  // COMPANY EMAIL VERIFICATION\n  // Verify company email if it hasn't been verified yet (from website scrape OR routing)\n\n  const companyEmailToVerify = contact._routed_company_email || contact._company_email;\n  const companyEmailNeedsVerification = companyEmailToVerify && !contact._company_email_status;\n  const companyId = contact.company_id;\n\n  if (companyEmailNeedsVerification && config.skip_hunter_verifier !== 'true' && !companyEmailsSet[companyId + '_verified']) {\n    const vResult = await verifyEmail.call(this, companyEmailToVerify);\n    let companyPatch = {};\n\n    if (contact._routed_company_email) {\n      companyPatch.email = contact._routed_company_email;\n    }\n\n    if (vResult) {\n      companyPatch.email_status = vResult.status;\n      contact._company_email_verified = true;\n      console.log(`Verified company email ${companyEmailToVerify}: ${vResult.status}`);\n    }\n\n    if (Object.keys(companyPatch).length > 0) {\n      try {\n        await this.helpers.httpRequest({\n          method: 'PATCH',\n          url: `${$env.SUPABASE_URL}/rest/v1/companies?id=eq.${companyId}`,\n          headers: {\n            'apikey': $env.SUPABASE_SERVICE_KEY,\n            'Authorization': `Bearer ${$env.SUPABASE_SERVICE_KEY}`,\n            'Content-Type': 'application/json',\n            'Prefer': 'return=minimal'\n          },\n          body: companyPatch,\n          json: true\n        });\n        console.log(`PATCHed company ${contact._company_name || companyId}: ${JSON.stringify(companyPatch)}`);\n      } catch(e) {\n        console.log(`Company PATCH error for ${companyId}: ${e.message}`);\n      }\n    }\n\n    companyEmailsSet[companyId + '_verified'] = true;\n    await delay(700);\n  } else if (contact._routed_company_email && !companyEmailsSet[companyId + '_verified']) {\n    try {\n      await this.helpers.httpRequest({\n        method: 'PATCH',\n        url: `${$env.SUPABASE_URL}/rest/v1/companies?id=eq.${companyId}`,\n        headers: {\n          'apikey': $env.SUPABASE_SERVICE_KEY,\n          'Authorization': `Bearer ${$env.SUPABASE_SERVICE_KEY}`,\n          'Content-Type': 'application/json',\n          'Prefer': 'return=minimal'\n        },\n        body: { email: contact._routed_company_email },\n        json: true\n      });\n      console.log(`PATCHed company email (unverified) ${contact._company_name || companyId}: ${contact._routed_company_email}`);\n    } catch(e) {\n      console.log(`Company PATCH error for ${companyId}: ${e.message}`);\n    }\n    companyEmailsSet[companyId + '_verified'] = true;\n    await delay(50);\n  }\n\n  // NAMSOR CULTURAL AFFINITY\n\n  if (!contact.cultural_affinity && contact.first_name && (contact.last_name || '').length > 0 && config.skip_namsor !== 'true') {\n    try {\n      const namsorUrl = `https://v2.namsor.com/NamSorAPIv2/api2/json/origin/${encodeURIComponent(contact.first_name)}/${encodeURIComponent(contact.last_name || 'Unknown')}`;\n      const namsorResp = await this.helpers.httpRequest({ method: 'GET', url: namsorUrl, headers: { 'X-API-KEY': $env.NAMSOR_API_KEY, 'Accept': 'application/json' }, json: true });\n      if (namsorResp && namsorResp.countryOrigin) {\n        const parts = [];\n        if (namsorResp.regionOrigin) parts.push(namsorResp.regionOrigin);\n        if (namsorResp.subRegionOrigin && namsorResp.subRegionOrigin !== namsorResp.regionOrigin) parts.push(namsorResp.subRegionOrigin);\n        if (namsorResp.countryOrigin) parts.push(namsorResp.countryOrigin);\n        contact._cultural_affinity = parts.join(' / ');\n        if (namsorResp.probabilityCalibrated && namsorResp.probabilityCalibrated < 0.3) {\n          contact._cultural_affinity += ' (low confidence)';\n        }\n        contact._namsor_country = namsorResp.countryOrigin;\n        contact._namsor_region = namsorResp.regionOrigin;\n        contact._namsor_probability = namsorResp.probabilityCalibrated;\n      }\n      await delay(100);\n    } catch(e) {\n      console.log(`NamSor error for ${contact.first_name}: ${e.message}`);\n    }\n  }\n\n  // PHONE VERIFICATION (Telnyx Number Lookup)\n\n  if (contact._best_phone && !contact.phone_status && config.skip_phone_verifier !== 'true') {\n    const phoneResult = await verifyPhone.call(this, contact._best_phone);\n    if (phoneResult) {\n      contact._phone_status = phoneResult.phone_status;\n      contact._phone_line_type = phoneResult.phone_line_type;\n      contact._phone_carrier = phoneResult.phone_carrier;\n      if (phoneResult._error) {\n        contact._phone_error = phoneResult._error;\n      } else {\n        console.log(`Phone verified ${contact._best_phone}: ${phoneResult.phone_status} (${phoneResult.phone_line_type || 'unknown type'}, ${phoneResult.phone_carrier || 'unknown carrier'})`);\n      }\n    }\n    await delay(100);\n  }\n\n  // COMPANY PHONE VERIFICATION (Telnyx)\n  if (contact._company_phone && !contact._company_phone_status && config.skip_phone_verifier !== 'true' && !companyEmailsSet[companyId + '_phone_verified']) {\n    const compPhoneResult = await verifyPhone.call(this, contact._company_phone);\n    if (compPhoneResult && !compPhoneResult._error) {\n      try {\n        await this.helpers.httpRequest({\n          method: 'PATCH',\n          url: `${$env.SUPABASE_URL}/rest/v1/companies?id=eq.${companyId}`,\n          headers: {\n            'apikey': $env.SUPABASE_SERVICE_KEY,\n            'Authorization': `Bearer ${$env.SUPABASE_SERVICE_KEY}`,\n            'Content-Type': 'application/json',\n            'Prefer': 'return=minimal'\n          },\n          body: {\n            phone_status: compPhoneResult.phone_status,\n            phone_line_type: compPhoneResult.phone_line_type\n          },\n          json: true\n        });\n        contact._company_phone_verified = true;\n        console.log(`Company phone verified ${contact._company_phone}: ${compPhoneResult.phone_status} (${compPhoneResult.phone_line_type || 'unknown'})`);\n      } catch(e) {\n        console.log(`Company phone PATCH error for ${companyId}: ${e.message}`);\n      }\n    } else if (compPhoneResult && compPhoneResult._error) {\n      contact._phone_error = contact._phone_error || compPhoneResult._error;\n    }\n    companyEmailsSet[companyId + '_phone_verified'] = true;\n    await delay(100);\n  }\n\n  // BUILD UPDATE PAYLOAD\n\n  const update = {};\n  if (contact._best_email && !contact.email_business) {\n    update.email_business = contact._best_email;\n  }\n  if (contact._email_status && contact._email_status !== 'unverified') {\n    update.email_status = contact._email_status;\n    update.email_verified_at = contact._email_verified_at;\n    if (contact._email_status === 'invalid') {\n      update.email_business = null;\n    }\n  } else if (contact._best_email || contact.email_business) {\n    update.email_status = 'unverified';\n  }\n\n  const newPhone = validatePhone(contact._best_phone);\n  if (newPhone && !contact.phone_direct) update.phone_direct = newPhone;\n  if (contact._best_linkedin && !contact.linkedin_url) update.linkedin_url = contact._best_linkedin;\n  if (contact._cultural_affinity && !contact.cultural_affinity) update.cultural_affinity = contact._cultural_affinity;\n\n  // Phone verification fields\n  if (contact._phone_status) {\n    update.phone_status = contact._phone_status;\n    update.phone_verified_at = new Date().toISOString();\n    update.phone_line_type = contact._phone_line_type;\n    update.phone_carrier = contact._phone_carrier;\n    if (contact._phone_status === 'invalid' || contact._phone_status === 'disconnected') {\n      update.phone_direct = null;  // Remove bad numbers, keep status for audit\n    }\n  }\n\n  contact._update_payload = Object.keys(update).length > 0 ? update : null;\n  contact._has_updates = Object.keys(update).length > 0;\n\n  // SUPABASE UPDATE (inline)\n\n  if (contact._has_updates) {\n    try {\n      await this.helpers.httpRequest({\n        method: 'PATCH',\n        url: `${$env.SUPABASE_URL}/rest/v1/contacts?id=eq.${contact.id}`,\n        headers: {\n          'apikey': $env.SUPABASE_SERVICE_KEY,\n          'Authorization': `Bearer ${$env.SUPABASE_SERVICE_KEY}`,\n          'Content-Type': 'application/json',\n          'Prefer': 'return=minimal'\n        },\n        body: update,\n        json: true\n      });\n      console.log(`Updated ${contact.first_name} ${contact.last_name || ''}: ${JSON.stringify(update)}`);\n    } catch(e) {\n      console.log(`Supabase update error for ${contact.id}: ${e.message}`);\n      contact._update_error = e.message;\n    }\n    await delay(50);\n  }\n\n  results.push({\n    json: {\n      _contact_id: contact.id,\n      _company_id: contact.company_id,\n      _first_name: contact.first_name,\n      _last_name: contact.last_name,\n      _company_name: contact._company_name,\n      _update_payload: contact._update_payload,\n      _has_updates: contact._has_updates,\n      _email_source: contact._email_source,\n      _email_status: contact._email_status,\n      _verifier_score: contact._verifier_score,\n      _namsor_country: contact._namsor_country,\n      _namsor_probability: contact._namsor_probability,\n      _company_email_routed: contact._company_email_routed,\n      _company_email_verified: contact._company_email_verified,\n      _routed_company_email: contact._routed_company_email || null,\n      _phone_status: contact._phone_status,\n      _phone_line_type: contact._phone_line_type,\n      _phone_carrier: contact._phone_carrier,\n      _company_phone_verified: contact._company_phone_verified,\n      _phone_error: contact._phone_error,\n      _update_error: contact._update_error || null\n    }\n  });\n}\n\nif (results.length === 0) {\n  return [{ json: { _empty: true, _count: 0 } }];\n}\n\nreturn results;"
        },
        "id": "aec203c3-be0e-40bb-9ada-7d85d644ab16",
        "name": "Enrich Contacts",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          8320,
          448
        ],
        "notes": "Replaces the entire Step 4 branching pipeline (31 nodes) with a single sequential loop.\nFor each contact: Hunter Email Finder \u2192 Snov.io fallback \u2192 Hunter Email Verifier \u2192 NamSor Origin \u2192 Supabase PATCH.\nAll API calls happen inline via $http.request(). No convergence = no batching bugs.\nConfig toggles (skip_hunter, skip_snovio, etc.) are checked inside the loop."
      },
      {
        "parameters": {
          "jsCode": "const config = $('Step 4 Config').first().json;\nconst items = $input.all();\n\nlet totalProcessed = 0;\nlet emailsFound = 0;\nlet emailsFromHunter = 0;\nlet emailsFromSnovio = 0;\nlet emailsExisting = 0;\nlet emailsPersonalPromoted = 0;\nlet phonesEnriched = 0;\nlet linkedinEnriched = 0;\nlet namsorProcessed = 0;\nlet namsorSuccess = 0;\nlet contactsUpdated = 0;\nlet contactsSkipped = 0;\n\nlet emailsVerified = 0;\nlet emailsInvalid = 0;\nlet emailsRisky = 0;\nlet emailsAcceptAll = 0;\nlet emailsUnverified = 0;\nlet verificationTotal = 0;\nlet updateErrors = 0;\n\n// Company email routing stats\nlet companyEmailsRouted = 0;\nlet companyEmailsVerified = 0;\n\n// Phone verification stats\nlet phonesVerifiedValid = 0;\nlet phonesInvalidRemoved = 0;\nlet phonesVoipFlagged = 0;\nlet phonesDisconnectedRemoved = 0;\nlet companyPhonesVerified = 0;\n\nfor (const item of items) {\n  const d = item.json;\n  if (d._empty) continue;\n  totalProcessed++;\n\n  if (d._has_updates) contactsUpdated++;\n  else contactsSkipped++;\n\n  if (d._email_source === 'hunter') emailsFromHunter++;\n  else if (d._email_source === 'snovio') emailsFromSnovio++;\n  else if (d._email_source === 'existing') emailsExisting++;\n  else if (d._email_source === 'personal_promoted') emailsPersonalPromoted++;\n\n  if (d._update_payload && d._update_payload.email_business) emailsFound++;\n  if (d._update_payload && d._update_payload.phone_direct) phonesEnriched++;\n  if (d._update_payload && d._update_payload.linkedin_url) linkedinEnriched++;\n  if (d._namsor_country) namsorProcessed++;\n  if (d._namsor_country && d._update_payload && d._update_payload.cultural_affinity) namsorSuccess++;\n\n  if (d._email_status) {\n    verificationTotal++;\n    switch (d._email_status) {\n      case 'verified': emailsVerified++; break;\n      case 'invalid': emailsInvalid++; break;\n      case 'risky': emailsRisky++; break;\n      case 'accept_all': emailsAcceptAll++; break;\n      case 'unverified': emailsUnverified++; break;\n    }\n  }\n\n  if (d._company_email_routed) companyEmailsRouted++;\n  if (d._company_email_verified) companyEmailsVerified++;\n  if (d._update_error) updateErrors++;\n\n  // Phone verification stats\n  if (d._phone_status) {\n    switch (d._phone_status) {\n      case 'valid': phonesVerifiedValid++; break;\n      case 'invalid': phonesInvalidRemoved++; break;\n      case 'voip': phonesVoipFlagged++; break;\n      case 'disconnected': phonesDisconnectedRemoved++; break;\n    }\n  }\n  if (d._company_phone_verified) companyPhonesVerified++;\n}\n\nconst summary = {\n  run_completed_at: new Date().toISOString(),\n  config: {\n    batch_size: config.batch_size,\n    hunter_finder_enabled: config.skip_hunter !== 'true',\n    hunter_verifier_enabled: config.skip_hunter_verifier !== 'true',\n    snovio_enabled: config.skip_snovio !== 'true',\n    namsor_enabled: config.skip_namsor !== 'true',\n    phone_verifier_enabled: config.skip_phone_verifier !== 'true'\n  },\n  contacts_processed: totalProcessed,\n  contacts_updated: contactsUpdated,\n  contacts_no_changes: contactsSkipped,\n  update_errors: updateErrors,\n  email_enrichment: {\n    new_emails_found: emailsFound,\n    from_hunter: emailsFromHunter,\n    from_snovio: emailsFromSnovio,\n    personal_promoted: emailsPersonalPromoted,\n    already_had_email: emailsExisting\n  },\n  email_verification: {\n    total_checked: verificationTotal,\n    verified: emailsVerified,\n    invalid_removed: emailsInvalid,\n    risky: emailsRisky,\n    accept_all: emailsAcceptAll,\n    not_verified: emailsUnverified\n  },\n  company_email_routing: {\n    role_based_routed_to_company: companyEmailsRouted,\n    company_emails_verified: companyEmailsVerified\n  },\n  phone_verification: {\n    verified_valid: phonesVerifiedValid,\n    invalid_removed: phonesInvalidRemoved,\n    voip_flagged: phonesVoipFlagged,\n    disconnected_removed: phonesDisconnectedRemoved,\n    company_phones_verified: companyPhonesVerified\n  },\n  phone_enrichment: { phones_added: phonesEnriched },\n  linkedin_enrichment: { linkedin_added: linkedinEnriched },\n  namsor_enrichment: { names_sent: namsorProcessed, cultural_affinity_set: namsorSuccess },\n  message: `Processed ${totalProcessed} contacts. Updated ${contactsUpdated} (${emailsFound} emails, ${phonesEnriched} phones, ${linkedinEnriched} LinkedIn, ${namsorSuccess} cultural affinity). Email verification: ${emailsVerified} valid, ${emailsInvalid} invalid, ${emailsRisky} risky, ${emailsAcceptAll} accept_all. Phone verification: ${phonesVerifiedValid} valid, ${phonesInvalidRemoved} invalid removed, ${phonesVoipFlagged} voip, ${phonesDisconnectedRemoved} disconnected removed, ${companyPhonesVerified} company phones. Company emails: ${companyEmailsRouted} routed, ${companyEmailsVerified} verified. ${contactsSkipped} no changes. ${updateErrors} errors.`\n};\n\nconsole.log('=== STEP 4: ENRICH PEOPLE SUMMARY ===');\nconsole.log(JSON.stringify(summary, null, 2));\n\nreturn [{ json: summary }];"
        },
        "id": "fca629db-4e74-42e6-9fc0-e652ba284137",
        "name": "Run Summary4",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          8768,
          448
        ],
        "notes": "Final summary: contacts enriched, emails found (Hunter/Snov.io), verification stats, NamSor stats, update counts."
      },
      {
        "parameters": {
          "path": "001b878c-b5af-4c3c-8b78-d41e526049f4",
          "options": {}
        },
        "type": "n8n-nodes-base.webhook",
        "typeVersion": 2.1,
        "position": [
          -11184,
          304
        ],
        "id": "1425be88-641d-4abd-a094-acab6b05acd7",
        "name": "Webhook",
        "webhookId": "001b878c-b5af-4c3c-8b78-d41e526049f4"
      },
      {
        "id": "a1b2c3d4-lead-score-http-0001",
        "name": "Calculate Lead Scores",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.2,
        "position": [
          9216,
          352
        ],
        "parameters": {
          "method": "POST",
          "url": "={{ $env.SUPABASE_URL }}/rest/v1/rpc/calculate_lead_scores",
          "authentication": "none",
          "sendHeaders": true,
          "headerParameters": {
            "parameters": [
              {
                "name": "apikey",
                "value": "={{ $env.SUPABASE_SERVICE_KEY }}"
              },
              {
                "name": "Authorization",
                "value": "=Bearer {{ $env.SUPABASE_SERVICE_KEY }}"
              },
              {
                "name": "Content-Type",
                "value": "application/json"
              }
            ]
          },
          "sendBody": true,
          "specifyBody": "json",
          "jsonBody": "{}",
          "options": {
            "response": {
              "response": {
                "neverError": true
              }
            }
          }
        },
        "notes": "Step 5: Call Supabase RPC to recalculate all lead scores based on scoring_rules table."
      },
      {
        "id": "a1b2c3d4-lead-score-summary-02",
        "name": "Run Summary5",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          9440,
          352
        ],
        "parameters": {
          "jsCode": "// Step 5: Lead Scoring Summary\nconst input = $input.first().json;\n\n// Check if the RPC call succeeded\n// Supabase RPC for void functions returns empty string or null on success\nconst rpcFailed = input.error || input.message || (typeof input === 'object' && input.code);\n\nconst summary = {\n  run_completed_at: new Date().toISOString(),\n  step: 'Step 5: Lead Scoring',\n  scoring_status: rpcFailed ? 'FAILED' : 'SUCCESS',\n  rpc_response: rpcFailed ? JSON.stringify(input) : 'calculate_lead_scores() executed successfully',\n  message: rpcFailed\n    ? `Lead scoring FAILED: ${JSON.stringify(input)}. Scores not updated \u2014 pipeline still completed.`\n    : 'Lead scoring complete. All company lead_score values recalculated from scoring_rules table.'\n};\n\nconsole.log('=== STEP 5: LEAD SCORING SUMMARY ===');\nconsole.log(JSON.stringify(summary, null, 2));\n\nreturn [{ json: summary }];"
        },
        "notes": "Logs whether the lead scoring RPC call succeeded or failed."
      },
      {
        "id": "66759275-0ca5-4b3c-ab6d-b3e52db64922",
        "name": "Metro Config",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          -10960,
          192
        ],
        "parameters": {
          "jsCode": "// Clear convergence-suppression flags from previous execution\nconst staticData = $getWorkflowStaticData('global');\ndelete staticData._collapse1_fired;\ndelete staticData._collapse2_fired;\ndelete staticData._enriched_contact_ids;\n\n// Dynamic Metro Config \u2014 reads metro_name from webhook query parameter\nconst METROS = {\n  'Austin, TX':     { latitude: '30.2672',  longitude: '-97.7431',  yelp_location: 'Austin, TX', radius_meters: '15000' },\n  'Denver, CO':     { latitude: '39.7392',  longitude: '-104.9903', yelp_location: 'Denver, CO', radius_meters: '15000' },\n  'Phoenix, AZ':    { latitude: '33.4484',  longitude: '-112.0740', yelp_location: 'Phoenix, AZ', radius_meters: '15000' },\n  'Toronto, ON':    { latitude: '43.6532',  longitude: '-79.3832',  yelp_location: 'Toronto, ON', radius_meters: '15000' },\n  'San Diego, CA':  { latitude: '32.7157',  longitude: '-117.1611', yelp_location: 'San Diego, CA', radius_meters: '15000' },\n  'Boise, ID':      { latitude: '43.6150',  longitude: '-116.2023', yelp_location: 'Boise, ID', radius_meters: '25000' },\n  'Portland, OR':   { latitude: '45.5152',  longitude: '-122.6784', yelp_location: 'Portland, OR', radius_meters: '15000' },\n};\n\nconst webhookData = $('Webhook').first().json;\nconst metroName = (webhookData.query && webhookData.query.metro_name) || '';\n\nif (!metroName) {\n  throw new Error('Missing required query parameter: metro_name. Use ?metro_name=City, ST');\n}\n\nconst metro = METROS[metroName];\nif (!metro) {\n  const available = Object.keys(METROS).join(', ');\n  throw new Error(`Unknown metro: \"${metroName}\". Available: ${available}`);\n}\n\nreturn [{\n  json: {\n    metro_name: metroName,\n    latitude: metro.latitude,\n    longitude: metro.longitude,\n    radius_meters: metro.radius_meters,\n    search_queries: 'massage therapy,massage clinic,massage therapist,spa massage,therapeutic massage,deep tissue massage,sports massage,bodywork,day spa,wellness spa,relaxation massage,licensed massage therapist',\n    yelp_location: metro.yelp_location\n  }\n}];"
        },
        "notes": "Dynamic metro lookup \u2014 reads metro_name from webhook ?metro_name=City, ST query parameter. Add new metros to the METROS object."
      },
      {
        "id": "a1b2c3d4-collapse-summary1-01",
        "name": "Collapse to Single1",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          -104,
          432
        ],
        "parameters": {
          "jsCode": "// Collapse 7 convergence paths into single item to prevent Task Runner crash loop\n// ADR-024: Suppress redundant convergence batches \u2014 only fire once per execution\nconst staticData = $getWorkflowStaticData('global');\nif (staticData._collapse1_fired) {\n  return [];\n}\nstaticData._collapse1_fired = true;\n\n// ADR-026: Stabilization polling \u2014 wait for Step 2 to finish enriching ALL companies\n// before triggering Step 3a. Without this, Step 3a fires after the first company\n// exits Step 2, missing ~95% of companies for new cities.\nconst metro = $('Metro Config').first().json.metro_name;\nconst headers = {\n  'apikey': $env.SUPABASE_SERVICE_KEY,\n  'Authorization': 'Bearer ' + $env.SUPABASE_SERVICE_KEY\n};\n\nlet prevCount = -1;\nlet stableRounds = 0;\n\nfor (let i = 0; i < 80; i++) {\n  await new Promise(r => setTimeout(r, 15000));\n\n  const rows = await this.helpers.httpRequest({\n    method: 'GET',\n    url: $env.SUPABASE_URL + '/rest/v1/companies?enrichment_status=eq.discovered&discovery_metro=eq.' + encodeURIComponent(metro) + '&select=id',\n    headers,\n    json: true\n  });\n  const count = Array.isArray(rows) ? rows.length : 0;\n\n  // Wait for discovered count to reach 0 (all companies processed by Step 2)\n  if (count === prevCount && count === 0) {\n    stableRounds++;\n    if (stableRounds >= 2) break;\n  } else {\n    stableRounds = 0;\n  }\n  prevCount = count;\n}\n\nreturn [{ json: { _trigger: 'social_processing_complete', _remaining_discovered: prevCount } }];"
        }
      },
      {
        "id": "a1b2c3d4-collapse-summary2-01",
        "name": "Collapse to Single2",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          -7712,
          192
        ],
        "parameters": {
          "jsCode": "// Collapse 2 convergence paths (Insert + Insert Flagged) into single item\n// ADR-024: Fire once per execution (suppress secondary batches)\n// ADR-025: Wait for all Step 1 inserts to complete before triggering Step 2\n// Google results arrive in ~5s, Yelp/Apify takes 60-120s.\n// Poll discovered count until stable, then fire.\n// BUG-028: Require count > 0 to prevent race condition where Insert to Supabase\n// hasn't committed yet. Max iterations raised from 10 to 30 (450s max).\nconst staticData = $getWorkflowStaticData('global');\nif (staticData._collapse2_fired) {\n  return [];\n}\nstaticData._collapse2_fired = true;\n\nconst metro = $('Metro Config').first().json.metro_name;\nconst headers = {\n  'apikey': $env.SUPABASE_SERVICE_KEY,\n  'Authorization': 'Bearer ' + $env.SUPABASE_SERVICE_KEY\n};\n\nlet prevCount = -1;\nlet stableRounds = 0;\n\nfor (let i = 0; i < 30; i++) {\n  // Wait 15 seconds between checks\n  await new Promise(r => setTimeout(r, 15000));\n\n  // Count discovered companies for this metro\n  const rows = await this.helpers.httpRequest({\n    method: 'GET',\n    url: $env.SUPABASE_URL + '/rest/v1/companies?enrichment_status=eq.discovered&discovery_metro=eq.' + encodeURIComponent(metro) + '&select=id',\n    headers,\n    json: true\n  });\n  const count = Array.isArray(rows) ? rows.length : 0;\n\n  if (count === prevCount && count > 0) {\n    stableRounds++;\n    if (stableRounds >= 2) break; // Stable for 30s \u2014 all inserts done\n  } else {\n    stableRounds = 0;\n  }\n  prevCount = count;\n}\n\nreturn [{ json: { _trigger: 'step1_insert_complete', _discovered_count: prevCount } }];"
        }
      },
      {
        "id": "a1b2c3d4-collapse-summary3-01",
        "name": "Collapse to Single3",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          6384,
          432
        ],
        "parameters": {
          "jsCode": "// Collapse 3+ convergence paths (Insert Contact + About no-name + No Domain no-name) into single item\n// Prevents 5-7x batch multiplication on Step 4 pre-collapse path\n// Run Summary3 uses $('NodeName').all() references which resolve globally by name\nreturn [{ json: { _trigger: 'step3a_contacts_complete' } }];"
        }
      }
    ],
    "connections": {
      "Split Search Queries": {
        "main": [
          [
            {
              "node": "Google Places - Text Search",
              "type": "main",
              "index": 0
            },
            {
              "node": "Start Apify Run",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Google Places - Text Search": {
        "main": [
          [
            {
              "node": "Normalize Google Results",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Normalize Google Results": {
        "main": [
          [
            {
              "node": "Merge All Sources",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Merge All Sources": {
        "main": [
          [
            {
              "node": "Deduplicate Records",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Deduplicate Records": {
        "main": [
          [
            {
              "node": "Prepare for Supabase",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Prepare for Supabase": {
        "main": [
          [
            {
              "node": "Fuzzy Match?",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Fuzzy Match?": {
        "main": [
          [
            {
              "node": "Insert Flagged (Needs Review)",
              "type": "main",
              "index": 0
            }
          ],
          [
            {
              "node": "Insert to Supabase",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Extract Run ID": {
        "main": [
          [
            {
              "node": "Wait 30s",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Wait 30s": {
        "main": [
          [
            {
              "node": "Check Run Status",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Check Run Status": {
        "main": [
          [
            {
              "node": "Parse Status",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Parse Status": {
        "main": [
          [
            {
              "node": "Run Succeeded?",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Run Succeeded?": {
        "main": [
          [
            {
              "node": "Fetch Apify Results",
              "type": "main",
              "index": 0
            }
          ],
          [
            {
              "node": "Wait 30s",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Start Apify Run": {
        "main": [
          [
            {
              "node": "Extract Run ID",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Normalize Yelp Results": {
        "main": [
          [
            {
              "node": "Merge All Sources",
              "type": "main",
              "index": 1
            }
          ]
        ]
      },
      "Fetch Apify Results": {
        "main": [
          [
            {
              "node": "Normalize Yelp Results",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Run Summary": {
        "main": [
          [
            {
              "node": "Enrichment Config",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Enrichment Config": {
        "main": [
          [
            {
              "node": "Fetch Batch from Supabase",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Fetch Batch from Supabase": {
        "main": [
          [
            {
              "node": "Parse Batch",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Parse Batch": {
        "main": [
          [
            {
              "node": "Batch Empty?",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Batch Empty?": {
        "main": [
          [
            {
              "node": "No Records - Done",
              "type": "main",
              "index": 0
            }
          ],
          [
            {
              "node": "Needs Backfill?",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Has Website?": {
        "main": [
          [
            {
              "node": "Fetch Website HTML",
              "type": "main",
              "index": 0
            }
          ],
          [
            {
              "node": "Skip - No Website",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Fetch Website HTML": {
        "main": [
          [
            {
              "node": "Analyze Website HTML",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Analyze Website HTML": {
        "main": [
          [
            {
              "node": "Merge Website Results",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Skip - No Website": {
        "main": [
          [
            {
              "node": "Merge Website Results",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Merge Website Results": {
        "main": [
          [
            {
              "node": "Has Google Place ID?",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Has Google Place ID?": {
        "main": [
          [
            {
              "node": "Google Places Details",
              "type": "main",
              "index": 0
            }
          ],
          [
            {
              "node": "Skip Google Details",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Google Places Details": {
        "main": [
          [
            {
              "node": "Parse Google Details",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Parse Google Details": {
        "main": [
          [
            {
              "node": "Prepare Company Update",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Skip Google Details": {
        "main": [
          [
            {
              "node": "Prepare Company Update",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Prepare Company Update": {
        "main": [
          [
            {
              "node": "Update Company in Supabase",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Update Company in Supabase": {
        "main": [
          [
            {
              "node": "Prepare Social Processing",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Prepare Social Processing": {
        "main": [
          [
            {
              "node": "Has Social Links?",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Has Social Links?": {
        "main": [
          [
            {
              "node": "Prepare Social Profiles Insert",
              "type": "main",
              "index": 0
            }
          ],
          [
            {
              "node": "Needs Social Discovery?",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Prepare Social Profiles Insert": {
        "main": [
          [
            {
              "node": "Insert Social Profiles",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Needs Social Discovery?": {
        "main": [
          [
            {
              "node": "Build Social Discovery Batch",
              "type": "main",
              "index": 0
            }
          ],
          [
            {
              "node": "Collapse to Single1",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Build Social Discovery Batch": {
        "main": [
          [
            {
              "node": "Discovery Queries Exist?",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Discovery Queries Exist?": {
        "main": [
          [
            {
              "node": "Prepare FB Search Input",
              "type": "main",
              "index": 0
            },
            {
              "node": "Prepare IG Search Input",
              "type": "main",
              "index": 0
            }
          ],
          [
            {
              "node": "Collapse to Single1",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Prepare FB Search Input": {
        "main": [
          [
            {
              "node": "Start FB Search Run",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Start FB Search Run": {
        "main": [
          [
            {
              "node": "Extract FB Run ID",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Extract FB Run ID": {
        "main": [
          [
            {
              "node": "Wait FB 30s",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Wait FB 30s": {
        "main": [
          [
            {
              "node": "Check FB Run Status",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Check FB Run Status": {
        "main": [
          [
            {
              "node": "Parse FB Status",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Parse FB Status": {
        "main": [
          [
            {
              "node": "FB Run Succeeded?",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "FB Run Succeeded?": {
        "main": [
          [
            {
              "node": "Fetch FB Search Results",
              "type": "main",
              "index": 0
            }
          ],
          [
            {
              "node": "Wait FB 30s",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Fetch FB Search Results": {
        "main": [
          [
            {
              "node": "Match FB Results to Companies",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Match FB Results to Companies": {
        "main": [
          [
            {
              "node": "FB Matches Found?",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "FB Matches Found?": {
        "main": [
          [
            {
              "node": "Insert FB Social Profiles",
              "type": "main",
              "index": 0
            }
          ],
          [
            {
              "node": "Collapse to Single1",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Prepare IG Search Input": {
        "main": [
          [
            {
              "node": "Start IG Search Run",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Start IG Search Run": {
        "main": [
          [
            {
              "node": "Extract IG Run ID",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Extract IG Run ID": {
        "main": [
          [
            {
              "node": "Wait IG 30s",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Wait IG 30s": {
        "main": [
          [
            {
              "node": "Check IG Run Status",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Check IG Run Status": {
        "main": [
          [
            {
              "node": "Parse IG Status",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Parse IG Status": {
        "main": [
          [
            {
              "node": "IG Run Succeeded?",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "IG Run Succeeded?": {
        "main": [
          [
            {
              "node": "Fetch IG Search Results",
              "type": "main",
              "index": 0
            }
          ],
          [
            {
              "node": "Wait IG 30s",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Fetch IG Search Results": {
        "main": [
          [
            {
              "node": "Match IG Results to Companies",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Match IG Results to Companies": {
        "main": [
          [
            {
              "node": "IG Matches Found?",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "IG Matches Found?": {
        "main": [
          [
            {
              "node": "Insert IG Social Profiles",
              "type": "main",
              "index": 0
            }
          ],
          [
            {
              "node": "Collapse to Single1",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Step 3b Config": {
        "main": [
          [
            {
              "node": "Fetch Unenriched Social Profiles",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Fetch Unenriched Social Profiles": {
        "main": [
          [
            {
              "node": "Parse Batch1",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Build SociaVault Request": {
        "main": [
          [
            {
              "node": "Should Enrich?",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Should Enrich?": {
        "main": [
          [
            {
              "node": "Call SociaVault API",
              "type": "main",
              "index": 0
            }
          ],
          [
            {
              "node": "Run Summary2",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Call SociaVault API": {
        "main": [
          [
            {
              "node": "Parse SociaVault Response",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Parse SociaVault Response": {
        "main": [
          [
            {
              "node": "Update Social Profile in Supabase",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Update Social Profile in Supabase": {
        "main": [
          [
            {
              "node": "Run Summary2",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Parse Batch1": {
        "main": [
          [
            {
              "node": "Batch Empty?1",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Batch Empty?1": {
        "main": [
          [
            {
              "node": "No Records - Done1",
              "type": "main",
              "index": 0
            }
          ],
          [
            {
              "node": "Build SociaVault Request",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Run Summary1": {
        "main": [
          [
            {
              "node": "Bridge to 3b",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Needs Backfill?": {
        "main": [
          [
            {
              "node": "Google Places Lookup",
              "type": "main",
              "index": 0
            }
          ],
          [
            {
              "node": "Merge Backfill",
              "type": "main",
              "index": 1
            }
          ]
        ]
      },
      "Google Places Lookup": {
        "main": [
          [
            {
              "node": "Extract & Patch Domain",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Extract & Patch Domain": {
        "main": [
          [
            {
              "node": "Merge Backfill",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Merge Backfill": {
        "main": [
          [
            {
              "node": "Has Website?",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Step 3a Config": {
        "main": [
          [
            {
              "node": "Fetch Companies",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Fetch Companies": {
        "main": [
          [
            {
              "node": "Fetch Existing Contacts",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Fetch Existing Contacts": {
        "main": [
          [
            {
              "node": "Filter & Parse Batch",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Filter & Parse Batch": {
        "main": [
          [
            {
              "node": "Batch Empty?2",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Solo Practitioner Check": {
        "main": [
          [
            {
              "node": "Is Solo?",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Is Solo?": {
        "main": [
          [
            {
              "node": "Prepare Solo Contact",
              "type": "main",
              "index": 0
            }
          ],
          [
            {
              "node": "Has Domain & Apollo?",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Prepare Solo Contact": {
        "main": [
          [
            {
              "node": "Validate & Clean Contact",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Has Domain & Apollo?": {
        "main": [
          [
            {
              "node": "Apollo People Search",
              "type": "main",
              "index": 0
            }
          ],
          [
            {
              "node": "No Domain Fallback",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Apollo People Search": {
        "main": [
          [
            {
              "node": "Parse Apollo Search",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Parse Apollo Search": {
        "main": [
          [
            {
              "node": "Apollo Found People?",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Apollo Found People?": {
        "main": [
          [
            {
              "node": "Enrich Enabled?",
              "type": "main",
              "index": 0
            }
          ],
          [
            {
              "node": "Fetch About Page",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Enrich Enabled?": {
        "main": [
          [
            {
              "node": "Apollo People Enrich",
              "type": "main",
              "index": 0
            }
          ],
          [
            {
              "node": "Apollo Search Only Contact",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Apollo People Enrich": {
        "main": [
          [
            {
              "node": "Parse Apollo Enrich",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Parse Apollo Enrich": {
        "main": [
          [
            {
              "node": "Validate & Clean Contact1",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Apollo Search Only Contact": {
        "main": [
          [
            {
              "node": "Validate & Clean Contact3",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Fetch About Page": {
        "main": [
          [
            {
              "node": "Parse About Page",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Parse About Page": {
        "main": [
          [
            {
              "node": "About Found Name?",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "About Found Name?": {
        "main": [
          [
            {
              "node": "Validate & Clean Contact4",
              "type": "main",
              "index": 0
            }
          ],
          [
            {
              "node": "Collapse to Single3",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "No Domain Fallback": {
        "main": [
          [
            {
              "node": "No Domain Found Name?",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "No Domain Found Name?": {
        "main": [
          [
            {
              "node": "Validate & Clean Contact2",
              "type": "main",
              "index": 0
            }
          ],
          [
            {
              "node": "Collapse to Single3",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Batch Empty?2": {
        "main": [
          [
            {
              "node": "No Records - Done2",
              "type": "main",
              "index": 0
            }
          ],
          [
            {
              "node": "Solo Practitioner Check",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Run Summary2": {
        "main": [
          [
            {
              "node": "Bridge to 3a",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Bridge to 3b": {
        "main": [
          [
            {
              "node": "Step 3b Config",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Bridge to 3a": {
        "main": [
          [
            {
              "node": "Step 3a Config",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Validate & Clean Contact": {
        "main": [
          [
            {
              "node": "Insert Contact to Supabase",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Validate & Clean Contact1": {
        "main": [
          [
            {
              "node": "Insert Contact to Supabase",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Validate & Clean Contact3": {
        "main": [
          [
            {
              "node": "Insert Contact to Supabase",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Validate & Clean Contact4": {
        "main": [
          [
            {
              "node": "Insert Contact to Supabase",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Validate & Clean Contact2": {
        "main": [
          [
            {
              "node": "Insert Contact to Supabase",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Run Summary3": {
        "main": [
          [
            {
              "node": "Bridge to 4",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Step 4 Config": {
        "main": [
          [
            {
              "node": "Fetch Contacts",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Fetch Contacts": {
        "main": [
          [
            {
              "node": "Collapse to Single",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Filter & Merge Contacts": {
        "main": [
          [
            {
              "node": "Batch Empty?3",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Fetch Companies1": {
        "main": [
          [
            {
              "node": "Filter & Merge Contacts",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Batch Empty?3": {
        "main": [
          [
            {
              "node": "No Records - Done3",
              "type": "main",
              "index": 0
            }
          ],
          [
            {
              "node": "Enrich Contacts",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Bridge to 4": {
        "main": [
          [
            {
              "node": "Step 4 Config",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Collapse to Single": {
        "main": [
          [
            {
              "node": "Fetch Companies1",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Enrich Contacts": {
        "main": [
          [
            {
              "node": "Run Summary4",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Run Summary4": {
        "main": [
          [
            {
              "node": "Calculate Lead Scores",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "No Records - Done3": {
        "main": [
          [
            {
              "node": "Calculate Lead Scores",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Calculate Lead Scores": {
        "main": [
          [
            {
              "node": "Run Summary5",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "No Records - Done": {
        "main": [
          [
            {
              "node": "Bridge to 3b",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "No Records - Done1": {
        "main": [
          [
            {
              "node": "Bridge to 3a",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "No Records - Done2": {
        "main": [
          [
            {
              "node": "Bridge to 4",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Webhook": {
        "main": [
          [
            {
              "node": "Metro Config",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Metro Config": {
        "main": [
          [
            {
              "node": "Split Search Queries",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Insert Social Profiles": {
        "main": [
          [
            {
              "node": "Collapse to Single1",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Insert FB Social Profiles": {
        "main": [
          [
            {
              "node": "Collapse to Single1",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Insert IG Social Profiles": {
        "main": [
          [
            {
              "node": "Collapse to Single1",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Collapse to Single1": {
        "main": [
          [
            {
              "node": "Run Summary1",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Insert to Supabase": {
        "main": [
          [
            {
              "node": "Collapse to Single2",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Insert Flagged (Needs Review)": {
        "main": [
          [
            {
              "node": "Collapse to Single2",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Collapse to Single2": {
        "main": [
          [
            {
              "node": "Run Summary",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Insert Contact to Supabase": {
        "main": [
          [
            {
              "node": "Collapse to Single3",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Collapse to Single3": {
        "main": [
          [
            {
              "node": "Run Summary3",
              "type": "main",
              "index": 0
            }
          ]
        ]
      }
    },
    "authors": "Phillip Schuman",
    "name": null,
    "description": null,
    "autosaved": false,
    "workflowPublishHistory": [
      {
        "createdAt": "2026-02-20T06:02:51.064Z",
        "id": 95,
        "workflowId": "yxvQst30sWlNIeZq",
        "versionId": "a7f4ec81-3742-4681-af9d-9f01382828f4",
        "event": "activated",
        "userId": "a0f6ea10-aac2-4dd7-a7bc-df1184531a06"
      }
    ]
  }
}