===== NODE: Analyze Website HTML =====
// runOnceForAllItems — index-paired with Has Website?
const upstreamAll = $('Has Website?').all();
const inputAll = $input.all();
const results = [];

// === HOISTED CONSTANTS ===
const bookingSignatures = {
  'jane_app': ['jane.app', 'janeapp.com'],
  'acuity': ['acuityscheduling.com', 'squareup.com/appointments', 'app.acuityscheduling.com'],
  'mindbody': ['mindbodyonline.com', 'clients.mindbodyonline.com', 'mindbody.io', 'healcode.com'],
  'square': ['square.site', 'squareup.com'],
  'vagaro': ['vagaro.com'],
  'fresha': ['fresha.com', 'shedul.com'],
  'schedulicity': ['schedulicity.com'],
  'schedulista': ['schedulista.com'],
  'booksy': ['booksy.com'],
  'massagebook': ['massagebook.com'],
  'genbook': ['genbook.com'],
  'noterro': ['noterro.com'],
  'clinicsense': ['clinicsense.com'],
  'wix_bookings': ['wix.com/booking', 'bookings.wixapps.net'],
  'calendly': ['calendly.com']
};

const junkEmailDomains = [
  'sentry.io', 'schema.org', 'w3.org', 'wordpress.com', 'wordpress.org',
  'squarespace.com', 'wix.com', 'gravatar.com', 'facebook.com', 'twitter.com',
  'instagram.com', 'youtube.com', 'linkedin.com', 'pinterest.com', 'tiktok.com',
  'cloudflare.com', 'googleapis.com', 'googletagmanager.com', 'google-analytics.com',
  'gstatic.com', 'jsdelivr.net', 'cdnjs.cloudflare.com', 'unpkg.com',
  'bootstrapcdn.com', 'fontawesome.com', 'typekit.net', 'fonts.googleapis.com',
  'example.com', 'example.org', 'test.com', 'localhost',
  'mailinator.com', 'guerrillamail.com', 'tempmail.com', 'yopmail.com'
];

const junkLocalPatterns = [
  /^noreply$/i, /^no-reply$/i, /^donotreply$/i, /^do-not-reply$/i,
  /^postmaster$/i, /^mailer-daemon$/i, /^webmaster$/i, /^root$/i,
  /^null$/i, /^test$/i, /^admin$/i, /^abuse$/i
];

const roleBasedPrefixes = ['info', 'contact', 'hello', 'office', 'reception',
  'frontdesk', 'front.desk', 'appointments', 'booking', 'bookings',
  'schedule', 'scheduling', 'inquiries', 'inquiry', 'general', 'team', 'staff',
  'support', 'sales', 'billing'];

const adSignatures = [
  'googleadservices.com', 'googlesyndication.com', 'googleads.g.doubleclick.net',
  'google_conversion', 'conversion_async', 'ads/ga-audiences',
  'fbevents.js', 'fbq(', 'snap.licdn.com', 'linkedin.com/insight',
  'analytics.tiktok.com', 'tiktok.com/i18n/pixel', 'ads-twitter.com', 'static.ads-twitter.com'
];

const socialPatterns = {
  facebook: /https?:\/\/(?:www\.)?facebook\.com\/[a-zA-Z0-9._-]+/gi,
  instagram: /https?:\/\/(?:www\.)?instagram\.com\/[a-zA-Z0-9._-]+/gi,
  tiktok: /https?:\/\/(?:www\.)?tiktok\.com\/@[a-zA-Z0-9._-]+/gi,
  linkedin: /https?:\/\/(?:www\.)?linkedin\.com\/(?:company|in)\/[a-zA-Z0-9._-]+/gi,
  x: /https?:\/\/(?:www\.)?(?:twitter\.com|x\.com)\/[a-zA-Z0-9._-]+/gi,
  youtube: /https?:\/\/(?:www\.)?youtube\.com\/(?:c\/|channel\/|@)[a-zA-Z0-9._-]+/gi
};

const teamPatterns = [
  /our\s+team/i, /meet\s+(?:the\s+)?team/i, /our\s+(?:therapists|practitioners|staff|massage\s+therapists)/i,
  /meet\s+(?:our|the)\s+(?:therapists|practitioners|staff)/i
];

const emailRegex = /[a-zA-Z0-9._%+\-]+@[a-zA-Z0-9.\-]+\.[a-zA-Z]{2,}/g;
const mailtoRegex = /mailto:([a-zA-Z0-9._%+\-]+@[a-zA-Z0-9.\-]+\.[a-zA-Z]{2,})/gi;

const bookingPatterns = ['book now', 'book online', 'book appointment', 'schedule now', 'schedule online', 'book a massage', 'online booking'];

const soloSignals = ['sole proprietor', 'solo practice', 'independent massage',
  'i am a licensed', "i'm a licensed", 'about me', 'my practice', 'my approach',
  'my services', 'i specialize', 'i provide'];

for (let i = 0; i < inputAll.length; i++) {
  const company = upstreamAll[i].json;
  const response = inputAll[i].json;
  const domain = (company.domain || '').toLowerCase();

  // === DOMAIN-BASED BOOKING DETECTION (runs even if fetch fails) ===
  let booking_platform = null;
  let has_online_booking = false;

  // Check domain first
  for (const [platform, signatures] of Object.entries(bookingSignatures)) {
    for (const sig of signatures) {
      if (domain.includes(sig)) {
        booking_platform = platform;
        has_online_booking = true;
        break;
      }
    }
    if (has_online_booking) break;
  }

  // Handle fetch errors
  if (response.error || (!response.body && !response.data)) {
    results.push({
      json: {
        ...company,
        _website_enrichment: {
          has_online_booking,
          booking_platform,
          has_paid_ads: false,
          estimated_size: null,
          social_links_found: [],
          emails_found: [],
          best_email: null,
          _website_fetch_status: 'error',
          _website_error: response.error || 'Empty response'
        }
      }
    });
    continue;
  }

  const rawHtml = response.body || response.data || '';
  const html = (typeof rawHtml === 'string' ? rawHtml : '').toLowerCase();
  const htmlOriginal = typeof rawHtml === 'string' ? rawHtml : '';

  // === EMAIL EXTRACTION ===
  const allEmailMatches = htmlOriginal.match(emailRegex) || [];

  // Also extract from mailto: links (higher confidence)
  // Reset regex lastIndex since we reuse it across loop iterations
  mailtoRegex.lastIndex = 0;
  const mailtoEmails = new Set();
  let mailtoMatch;
  while ((mailtoMatch = mailtoRegex.exec(htmlOriginal)) !== null) {
    mailtoEmails.add(mailtoMatch[1].toLowerCase());
  }

  // Deduplicate and filter
  const uniqueEmails = [...new Set(allEmailMatches.map(e => e.toLowerCase()))];
  const scoredEmails = [];

  for (const email of uniqueEmails) {
    const [localPart, emailDomain] = email.split('@');
    if (!emailDomain) continue;

    // Filter out junk domains
    if (junkEmailDomains.some(d => emailDomain.includes(d))) continue;

    // Filter out junk local parts
    if (junkLocalPatterns.some(p => p.test(localPart))) continue;

    // Filter out numeric-only local parts
    if (/^\d+$/.test(localPart)) continue;

    // Score the email
    let score = 0;
    if (domain && emailDomain.includes(domain.replace('www.', ''))) score += 20;
    if (mailtoEmails.has(email)) score += 10;
    if (roleBasedPrefixes.some(p => localPart === p || localPart.startsWith(p + '.'))) score += 5;

    scoredEmails.push({ email, score, from_mailto: mailtoEmails.has(email) });
  }

  // Sort by score descending
  scoredEmails.sort((a, b) => b.score - a.score);
  const best_email = scoredEmails.length > 0 ? scoredEmails[0].email : null;

  // === HTML-BASED BOOKING DETECTION ===
  if (!has_online_booking) {
    for (const [platform, signatures] of Object.entries(bookingSignatures)) {
      for (const sig of signatures) {
        if (html.includes(sig)) {
          booking_platform = platform;
          has_online_booking = true;
          break;
        }
      }
      if (has_online_booking) break;
    }
  }

  if (!has_online_booking) {
    for (const pattern of bookingPatterns) {
      if (html.includes(pattern)) {
        has_online_booking = true;
        booking_platform = 'unknown';
        break;
      }
    }
  }

  // === PAID ADS DETECTION ===
  let has_paid_ads = false;
  for (const sig of adSignatures) {
    if (html.includes(sig)) {
      has_paid_ads = true;
      break;
    }
  }

  // === SOCIAL LINKS EXTRACTION ===
  const social_links_found = [];
  const seenPlatforms = new Set();

  for (const [platform, regex] of Object.entries(socialPatterns)) {
    // Reset regex lastIndex since we reuse across loop iterations
    regex.lastIndex = 0;
    const matches = htmlOriginal.match(regex) || [];
    for (const url of matches) {
      const lowerUrl = url.toLowerCase();
      if (lowerUrl.includes('/sharer') || lowerUrl.includes('/share') ||
          lowerUrl.includes('/intent') || lowerUrl.includes('/login') ||
          lowerUrl.includes('/help') || lowerUrl.includes('/about') ||
          lowerUrl.includes('/policies') || lowerUrl.includes('/privacy')) {
        continue;
      }
      if (!seenPlatforms.has(platform)) {
        social_links_found.push({ platform, url: url.replace(/\/+$/, '') });
        seenPlatforms.add(platform);
      }
    }
  }

  // === TEAM SIZE ESTIMATION ===
  let estimated_size = null;

  let hasTeamPage = false;
  for (const p of teamPatterns) {
    if (p.test(htmlOriginal)) {
      hasTeamPage = true;
      break;
    }
  }

  if (hasTeamPage) {
    const namePatterns = htmlOriginal.match(/<h[2-4][^>]*>[^<]{2,40}<\/h[2-4]>/gi) || [];
    const staffLinks = htmlOriginal.match(/\/(?:team|staff|therapist|practitioner)s?\/[a-z-]+/gi) || [];
    const memberCount = Math.max(namePatterns.length, staffLinks.length);
    if (memberCount <= 1) estimated_size = 'solo';
    else if (memberCount <= 5) estimated_size = 'small';
    else estimated_size = 'medium';
  } else {
    const isSolo = soloSignals.some(s => html.includes(s));
    if (isSolo) estimated_size = 'solo';
  }

  results.push({
    json: {
      ...company,
      _website_enrichment: {
        has_online_booking,
        booking_platform,
        has_paid_ads,
        estimated_size,
        social_links_found,
        emails_found: scoredEmails.slice(0, 5),
        best_email,
        _website_fetch_status: 'success'
      }
    }
  });
}

return results;
===== END NODE =====

===== NODE: Extract & Patch Domain =====
// runOnceForAllItems — index-paired with Needs Backfill?
const upstreamAll = $('Needs Backfill?').all();
const inputAll = $input.all();
const results = [];

// Hoisted constant
const BLOCKED_DOMAINS = ['wixsite.com','wix.com','setmore.com','schedulista.com','glossgenius.com','square.site','genbook.com','jane.app','acuityscheduling.com','mindbodyonline.com','mindbody.io','vagaro.com','fresha.com','schedulicity.com','booksy.com','massagebook.com','noterro.com','clinicsense.com','calendly.com','squarespace.com'];

for (let i = 0; i < inputAll.length; i++) {
  const company = upstreamAll[i].json;
  const response = inputAll[i].json;
  const places = response.places || [];

  if (places.length === 0) {
    results.push({ json: { ...company } });
    continue;
  }

  const companyName = (company.name || '').toLowerCase().replace(/[^a-z0-9\s]/g, '');
  const companyPhone = (company.phone || '').replace(/[^\d]/g, '');

  let bestMatch = null;
  let bestScore = 0;

  for (const place of places) {
    const placeName = ((place.displayName && place.displayName.text) || '').toLowerCase().replace(/[^a-z0-9\s]/g, '');
    let score = 0;

    const companyWords = companyName.split(/\s+/).filter(w => w.length > 2);
    const placeWords = placeName.split(/\s+/).filter(w => w.length > 2);
    const matchingWords = companyWords.filter(w => placeWords.some(pw => pw.includes(w) || w.includes(pw)));
    score = companyWords.length > 0 ? matchingWords.length / companyWords.length : 0;

    const placePhone = (place.internationalPhoneNumber || place.nationalPhoneNumber || '').replace(/[^\d]/g, '');
    if (companyPhone && placePhone && (placePhone.includes(companyPhone.slice(-10)) || companyPhone.includes(placePhone.slice(-10)))) {
      score += 0.5;
    }

    if (score > bestScore && score >= 0.4) {
      bestScore = score;
      bestMatch = place;
    }
  }

  if (!bestMatch) {
    results.push({ json: { ...company } });
    continue;
  }

  const website = bestMatch.websiteUri || '';
  let domain = null;
  if (website) {
    const match = website.match(/^https?:\/\/(?:www\.)?([^\/]+)/i);
    if (match) domain = match[1];
  }

  // Check domain against blocklist
  let _domain_blocked = false;
  let _domain_blocked_platform = '';
  if (domain) {
    const lowerDomain = domain.toLowerCase();
    for (const blocked of BLOCKED_DOMAINS) {
      if (lowerDomain === blocked || lowerDomain.endsWith('.' + blocked)) {
        _domain_blocked = true;
        _domain_blocked_platform = blocked;
        domain = null;
        break;
      }
    }
  }

  // Merge found data into the company item so downstream nodes see it
  const updated = { ...company };
  if (bestMatch.id && !company.google_place_id) updated.google_place_id = bestMatch.id;
  if (domain) {
    updated.domain = domain;
    updated.has_website = true;
  }
  if (_domain_blocked) {
    updated._domain_blocked = true;
    updated._domain_blocked_platform = _domain_blocked_platform;
  }
  if (bestMatch.rating && !company.google_rating) updated.google_rating = bestMatch.rating;
  if (bestMatch.userRatingCount && !company.google_review_count) updated.google_review_count = bestMatch.userRatingCount;

  // Build Supabase patch payload - only include domain if not blocked
  const patch = {};
  if (updated.google_place_id !== company.google_place_id) patch.google_place_id = updated.google_place_id;
  if (domain) {
    patch.domain = domain;
    if (updated.has_website !== company.has_website) patch.has_website = updated.has_website;
  }
  if (updated.google_rating !== company.google_rating) patch.google_rating = updated.google_rating;
  if (updated.google_review_count !== company.google_review_count) patch.google_review_count = updated.google_review_count;

  updated._backfill_patch = Object.keys(patch).length > 0 ? patch : null;
  updated._backfill_matched = bestMatch.displayName?.text || '';
  updated._backfill_score = bestScore;

  results.push({ json: updated });
}

return results;
===== END NODE =====

===== NODE: Merge Website Results =====
// Merge website-enriched (from both paths: with website and without)
const items = $input.all();
const results = [];
// Enrichment Config is a single-item node, .first() is correct here
const config = $('Enrichment Config').first().json;
const skipGoogleDetails = config.skip_google_details === 'true' || config.skip_google_details === true;

for (const entry of items) {
  const item = entry.json;
  const enrichment = item._website_enrichment || {};

  // Prepare the enriched company object
  const enriched = {
    id: item.id,
    name: item.name,
    phone: item.phone,
    domain: item.domain,
    address: item.address,
    city: item.city,
    state: item.state,
    country: item.country,
    google_place_id: item.google_place_id,
    category: item.category,
    has_website: item.has_website,
    google_review_count: item.google_review_count,
    google_rating: item.google_rating,
    source_urls: item.source_urls,
    on_yelp: item.on_yelp,
    on_groupon: item.on_groupon,

    // Enriched fields from website analysis
    has_online_booking: enrichment.has_online_booking || false,
    booking_platform: enrichment.booking_platform || null,
    has_paid_ads: enrichment.has_paid_ads || false,
    estimated_size: enrichment.estimated_size || null,

    // Email fields from website scraping (BUG-F012 fix)
    _emails_found: enrichment.emails_found || [],
    _best_email: enrichment.best_email || null,

    // Backfill data from Google Places lookup (BUG-F013 fix)
    _backfill_patch: item._backfill_patch || null,

    // Social links for later processing
    _social_links_found: enrichment.social_links_found || [],
    _website_fetch_status: enrichment._website_fetch_status || 'unknown',
    _website_error: enrichment._website_error || null,
    _needs_social_discovery: (enrichment.social_links_found || []).length === 0,
    _skip_google_details: skipGoogleDetails
  };

  results.push({ json: enriched });
}

return results;
===== END NODE =====

===== NODE: Parse Google Details =====
// runOnceForAllItems — index-paired with Has Google Place ID?
const upstreamAll = $('Has Google Place ID?').all();
const inputAll = $input.all();
const results = [];

for (let i = 0; i < inputAll.length; i++) {
  const company = upstreamAll[i].json;
  const details = inputAll[i].json;

  // Extract incremental data from Google Places Details
  let opening_hours = null;
  let business_status = null;
  let photo_count = 0;
  let price_level = null;
  let additional_types = [];

  if (details && !details.error) {
    if (details.regularOpeningHours && details.regularOpeningHours.periods) {
      opening_hours = details.regularOpeningHours;
    } else if (details.currentOpeningHours && details.currentOpeningHours.periods) {
      opening_hours = details.currentOpeningHours;
    }
    business_status = details.businessStatus || null;
    if (details.photos && Array.isArray(details.photos)) {
      photo_count = details.photos.length;
    }
    price_level = details.priceLevel || null;
    if (details.types && Array.isArray(details.types)) {
      additional_types = details.types;
    }
  }

  results.push({
    json: {
      ...company,
      _google_details: {
        opening_hours,
        business_status,
        photo_count,
        price_level,
        additional_types,
        _fetch_status: details.error ? 'error' : 'success'
      }
    }
  });
}

return results;
===== END NODE =====

===== NODE: Prepare Company Update =====
const items = $input.all();
const results = [];

for (const entry of items) {
  const item = entry.json;
  const now = new Date().toISOString();

  // Build the PATCH payload for Supabase
  const updatePayload = {
    has_online_booking: item.has_online_booking || false,
    booking_platform: item.booking_platform || null,
    has_paid_ads: item.has_paid_ads || false,
    estimated_size: item.estimated_size || null,
    enrichment_status: 'partially_enriched',
    enriched_at: now
  };

  // Include backfill data ONLY from companies that went through the backfill path
  // This prevents 409 conflicts when PATCHing domain on companies that already have one
  const backfill = item._backfill_patch || {};
  if (backfill.domain) updatePayload.domain = backfill.domain;
  if (backfill.google_place_id) updatePayload.google_place_id = backfill.google_place_id;
  if (backfill.google_rating) updatePayload.google_rating = backfill.google_rating;
  if (backfill.google_review_count) updatePayload.google_review_count = backfill.google_review_count;

  // has_website can change via website analysis (not just backfill)
  if (item.has_website) updatePayload.has_website = item.has_website;

  // Include website-scraped email if found (BUG-F012 fix: read from flat field)
  const websiteEmail = item._best_email || null;
  if (websiteEmail) {
    updatePayload.email = websiteEmail;
    // email_status stays NULL - will be verified in Step 4
  }

  results.push({
    json: {
      _company_id: item.id,
      _update_payload: updatePayload,
      // Pass through everything for social discovery
      ...item
    }
  });
}

return results;
===== END NODE =====

===== NODE: Prepare Social Processing =====
// runOnceForAllItems — index-paired with Prepare Company Update
// Enrichment Config is a single-item node, hoisted outside loop
const upstreamAll = $('Prepare Company Update').all();
const inputAll = $input.all();
const config = $('Enrichment Config').first().json;
const skipSocial = config.skip_social_discovery === 'true' || config.skip_social_discovery === true;
const results = [];

for (let i = 0; i < inputAll.length; i++) {
  const item = upstreamAll[i].json;

  const socialLinks = item._social_links_found || [];
  const needsDiscovery = item._needs_social_discovery && !skipSocial;

  results.push({
    json: {
      company_id: item.id,
      company_name: item.name,
      city: item.city,
      state: item.state,
      domain: item.domain,
      social_links_found: socialLinks,
      needs_social_discovery: needsDiscovery,
      _skip_social: skipSocial
    }
  });
}

return results;
===== END NODE =====

===== NODE: Prepare Social Profiles Insert =====
// Insert social profiles found from website HTML into Supabase social_profiles table
const items = $input.all();
const results = [];

for (const entry of items) {
  const item = entry.json;
  const links = item.social_links_found || [];

  if (links.length === 0) {
    results.push({ json: { _social_inserts: 0, company_id: item.company_id } });
    continue;
  }

  // Build an array of social_profiles rows
  const rows = links.map(link => ({
    company_id: item.company_id,
    platform: link.platform,
    profile_url: link.url,
    follower_count: null,
    post_count: null,
    last_post_date: null,
    scraped_at: new Date().toISOString()
  }));

  results.push({
    json: {
      _social_rows: rows,
      _social_inserts: rows.length,
      company_id: item.company_id,
      company_name: item.company_name,
      city: item.city,
      state: item.state,
      needs_social_discovery: false
    }
  });
}

return results;
===== END NODE =====

===== NODE: Parse Batch =====
// Supabase HTTP node may return items individually (one per row) or as a single array.
// Handle both cases.
const allInputs = $input.all();

let companies = [];

if (allInputs.length === 1 && Array.isArray(allInputs[0].json)) {
  // Single item containing an array
  companies = allInputs[0].json;
} else if (allInputs.length === 1 && allInputs[0].json[0]) {
  // Single item with nested array
  companies = allInputs[0].json;
} else {
  // Multiple items, one company per item (this is what n8n HTTP node does)
  companies = allInputs.map(i => i.json);
}

if (!companies || companies.length === 0 || (companies.length === 1 && !companies[0].id)) {
  return [{ json: { _empty: true, _count: 0, _message: 'No companies to enrich in this batch' } }];
}

console.log(`Batch loaded: ${companies.length} companies to enrich`);

return companies.map(c => ({ json: c }));
===== END NODE =====

===== NODE: Collapse to Single2 =====
// Collapse 2 convergence paths (Insert + Insert Flagged) into single item
// ADR-024: Fire once per execution (suppress secondary batches)
// ADR-025: Wait for all Step 1 inserts to complete before triggering Step 2
// Google results arrive in ~5s, Yelp/Apify takes 60-120s.
// Poll discovered count until stable, then fire.
// BUG-028: Require count > 0 to prevent race condition where Insert to Supabase
// hasn't committed yet. Max iterations raised from 10 to 30 (450s max).
const staticData = $getWorkflowStaticData('global');
if (staticData._collapse2_fired) {
  return [];
}
staticData._collapse2_fired = true;

const metro = $('Metro Config').first().json.metro_name;
const headers = {
  'apikey': $env.SUPABASE_SERVICE_KEY,
  'Authorization': 'Bearer ' + $env.SUPABASE_SERVICE_KEY
};

let prevCount = -1;
let stableRounds = 0;

for (let i = 0; i < 30; i++) {
  // Wait 15 seconds between checks
  await new Promise(r => setTimeout(r, 15000));

  // Count discovered companies for this metro
  const rows = await this.helpers.httpRequest({
    method: 'GET',
    url: $env.SUPABASE_URL + '/rest/v1/companies?enrichment_status=eq.discovered&discovery_metro=eq.' + encodeURIComponent(metro) + '&select=id',
    headers,
    json: true
  });
  const count = Array.isArray(rows) ? rows.length : 0;

  if (count === prevCount && count > 0) {
    stableRounds++;
    if (stableRounds >= 2) break; // Stable for 30s — all inserts done
  } else {
    stableRounds = 0;
  }
  prevCount = count;
}

return [{ json: { _trigger: 'step1_insert_complete', _discovered_count: prevCount } }];
===== END NODE =====

===== NODE: Metro Config =====
// Clear convergence-suppression flags from previous execution
const staticData = $getWorkflowStaticData('global');
delete staticData._collapse1_fired;
delete staticData._collapse2_fired;
delete staticData._enriched_contact_ids;

// Dynamic Metro Config — reads metro_name from webhook query parameter
const METROS = {
  'Austin, TX':     { latitude: '30.2672',  longitude: '-97.7431',  yelp_location: 'Austin, TX', radius_meters: '15000' },
  'Denver, CO':     { latitude: '39.7392',  longitude: '-104.9903', yelp_location: 'Denver, CO', radius_meters: '15000' },
  'Phoenix, AZ':    { latitude: '33.4484',  longitude: '-112.0740', yelp_location: 'Phoenix, AZ', radius_meters: '15000' },
  'Toronto, ON':    { latitude: '43.6532',  longitude: '-79.3832',  yelp_location: 'Toronto, ON', radius_meters: '15000' },
  'San Diego, CA':  { latitude: '32.7157',  longitude: '-117.1611', yelp_location: 'San Diego, CA', radius_meters: '15000' },
  'Boise, ID':      { latitude: '43.6150',  longitude: '-116.2023', yelp_location: 'Boise, ID', radius_meters: '25000' },
  'Portland, OR':   { latitude: '45.5152',  longitude: '-122.6784', yelp_location: 'Portland, OR', radius_meters: '15000' },
};

const webhookData = $('Webhook').first().json;
const metroName = (webhookData.query && webhookData.query.metro_name) || '';

if (!metroName) {
  throw new Error('Missing required query parameter: metro_name. Use ?metro_name=City, ST');
}

const metro = METROS[metroName];
if (!metro) {
  const available = Object.keys(METROS).join(', ');
  throw new Error(`Unknown metro: "${metroName}". Available: ${available}`);
}

return [{
  json: {
    metro_name: metroName,
    latitude: metro.latitude,
    longitude: metro.longitude,
    radius_meters: metro.radius_meters,
    search_queries: 'massage therapy,massage clinic,massage therapist,spa massage,therapeutic massage,deep tissue massage,sports massage,bodywork,day spa,wellness spa,relaxation massage,licensed massage therapist',
    yelp_location: metro.yelp_location
  }
}];
===== END NODE =====

===== NODE: Solo Practitioner Check =====
// runOnceForAllItems — hoist name list + helper outside loop
const items = $input.all();
const results = [];

const commonFirstNames = new Set([
  'aaron','abby','abigail','adam','adrian','adriana','aiden','aimee','alana','albert',
  'alec','alexa','alexander','alexandra','alexis','alice','alicia','alina','alison','allison',
  'alyssa','amanda','amber','amelia','amy','ana','andrea','andrew','angela','angelica',
  'angie','anita','ann','anna','anne','annie','anthony','april','aria','ariana',
  'ashley','audrey','austin','autumn','ava','avery','bailey','barbara','beatrice','becky',
  'bella','ben','benjamin','beth','bethany','betty','beverly','bianca','blake','bonnie',
  'brad','bradley','brandi','brandon','brandy','breanna','brenda','brent','brett','brian',
  'briana','brianna','bridget','brittany','brittney','brooke','bruce','bryan','caitlin','caleb',
  'cameron','camila','candace','cara','carina','carl','carla','carlos','carly','carmen',
  'carol','carolina','caroline','carolyn','carrie','casey','cassandra','cassidy','catherine','cathy',
  'cecilia','celeste','celia','chad','charlene','charles','charlie','charlotte','chase','chelsea',
  'cheryl','chloe','chris','christa','christian','christina','christine','christopher','cindy','claire',
  'clara','claudia','cody','colleen','connor','constance','corey','corinne','courtney','craig',
  'crystal','cynthia','daisy','dale','dana','daniel','daniela','danielle','daphne','darlene',
  'darren','dave','david','dawn','dean','deanna','debbie','deborah','debra','denise',
  'derek','desiree','destiny','diana','diane','dianne','dolores','dominic','donna','doris',
  'dorothy','douglas','drew','dustin','dylan','eddie','edith','edward','eileen','elaine',
  'elena','elisa','elizabeth','ella','ellen','ellie','emily','emma','eric','erica',
  'erika','erin','ernest','esther','ethan','eugene','eva','evan','evelyn','faith',
  'faye','felicia','fiona','florence','frances','frank','gabriel','gabriela','gabriella','gabrielle',
  'gail','gary','gavin','genevieve','george','georgia','gerald','gina','giselle','gladys',
  'glen','glenn','gloria','grace','grant','greg','gregory','gretchen','hailey','haley',
  'hannah','harold','harriet','harry','hayden','hazel','heather','heidi','helen','henry',
  'hillary','holly','hope','howard','hunter','ian','irene','iris','isaac','isabel',
  'isabella','ivy','jack','jackie','jackson','jacob','jacqueline','jade','jaime','jake',
  'james','jamie','jan','jane','janet','janice','jared','jasmine','jason','jay',
  'jean','jeanette','jeanne','jeff','jeffrey','jenna','jennifer','jenny','jeremy','jerry',
  'jesse','jessica','jill','jillian','jim','jimmy','jo','joan','joann','joanna',
  'joanne','jocelyn','jodi','jody','joe','joel','johanna','john','johnny','jolene',
  'jon','jonathan','jordan','jorge','jose','joseph','josephine','josh','joshua','joy',
  'joyce','juan','judith','judy','julia','julian','juliana','julie','june','justin',
  'kaitlyn','kara','karen','karina','karl','kate','katelyn','katherine','kathleen','kathryn',
  'kathy','katie','katrina','kay','kayla','keith','kelley','kelli','kelly','kelsey',
  'ken','kendra','kenneth','kenny','kerry','kevin','kim','kimberly','kirsten','krista',
  'kristen','kristin','kristina','kristy','kyle','kylie','lacey','lana','lance','larry',
  'laura','lauren','laurie','leah','lee','leigh','lena','leo','leon','leslie',
  'lexy','liam','lillian','lily','linda','lindsay','lindsey','lisa','logan','lois',
  'lora','lorena','lori','lorraine','louis','louise','lucia','luis','luke','lydia',
  'lynn','mackenzie','madeline','madison','maggie','malik','mallory','mandy','marc','marcia',
  'marco','marcus','margaret','maria','mariah','marie','marilyn','marina','mario','marisa',
  'marissa','mark','marlene','marsha','martha','martin','mary','mason','matt','matthew',
  'maureen','max','maya','megan','meghan','melanie','melinda','melissa','melody','meredith',
  'mia','michael','michele','michelle','miguel','mike','mildred','mindy','miranda','misty',
  'mitchell','molly','monica','monique','morgan','mya','nadia','nancy','naomi','natalia',
  'natalie','natasha','nathan','nathaniel','neil','nelson','nicholas','nicole','nina','noah',
  'noel','nora','norma','olivia','owen','paige','pam','pamela','patricia','patrick',
  'patty','paul','paula','pauline','peggy','penny','peter','philip','phyllis','priscilla',
  'rachel','ralph','ramona','randall','randy','ray','raymond','rebecca','regina','renee',
  'rhonda','ricardo','richard','rick','ricky','riley','rita','rob','robert','roberta',
  'robin','rochelle','rodney','roger','ronald','rosa','rosalie','rose','rosemary','roxanne',
  'ruby','russell','ruth','ryan','sabrina','sally','samantha','samuel','sandra','sandy',
  'sara','sarah','savannah','scott','sean','selena','serena','seth','shana','shane',
  'shannon','sharon','shawn','sheila','shelby','shelley','shelly','sheri','sherri','sherry',
  'shirley','sierra','silvia','simone','sofia','sonia','sonya','sophia','stacey','stacy',
  'stella','stephanie','stephen','steve','steven','sue','summer','susan','suzanne','sydney',
  'sylvia','tabitha','tamara','tammy','tanya','tara','tatiana','taylor','teresa','terri',
  'terry','tess','tessa','theresa','thomas','tiffany','tim','timothy','tina','tito',
  'todd','tom','tommy','toni','tony','tonya','tracey','traci','tracy','travis',
  'tricia','trisha','troy','tyler','valerie','vanessa','vera','veronica','vicki','vicky',
  'victoria','vincent','violet','virginia','vivian','wade','walter','wanda','warren','wayne',
  'wendy','wesley','whitney','william','willie','wilma','xavier','yolanda','yvette','yvonne',
  'zachary','zoe'
]);

function isLikelyFirstName(word) {
  return commonFirstNames.has(word.toLowerCase());
}

for (const entry of items) {
  const item = entry.json;
  const name = (item.name || '').trim();
  const estimatedSize = item.estimated_size;

  let isSolo = false;
  let firstName = null;
  let lastName = null;

  // Pattern 1: "by Name" pattern - "Bodywork by Benna", "Massage by Celeste"
  const byPattern = name.match(/\bby\s+([A-Z][a-z]+)(?:\s+([A-Z][a-z]+))?/i);
  if (byPattern) {
    const candidate = byPattern[1];
    if (isLikelyFirstName(candidate) || estimatedSize === 'solo') {
      isSolo = true;
      firstName = candidate;
      lastName = byPattern[2] || null;
    }
  }

  // Pattern 2: "with Name" pattern
  if (!firstName) {
    const withPattern = name.match(/\bwith\s+([A-Z][a-z]+)(?:\s+([A-Z][a-z]+))?/i);
    if (withPattern) {
      const candidate = withPattern[1];
      if (isLikelyFirstName(candidate) || estimatedSize === 'solo') {
        isSolo = true;
        firstName = candidate;
        lastName = withPattern[2] || null;
      }
    }
  }

  // Pattern 3: Possessive - "Lexy's Massage"
  if (!firstName) {
    const possessiveMatch = name.match(/^([A-Z][a-z]+)'s\s+/i);
    if (possessiveMatch && isLikelyFirstName(possessiveMatch[1])) {
      isSolo = true;
      firstName = possessiveMatch[1];
    }
  }

  // Pattern 4: "FirstName LastName, LMT/CMT/RMT"
  if (!firstName) {
    const nameFirst = name.match(/^([A-Z][a-z]+)\s+([A-Z][a-z]+)(?:\s*[,|]\s*|\s+)(?:LMT|CMT|RMT|Licensed|Massage|Bodywork|Therapeutic|Wellness)/i);
    if (nameFirst) {
      const fn = nameFirst[1];
      const ln = nameFirst[2];
      if (isLikelyFirstName(fn) && !commonFirstNames.has(ln.toLowerCase())) {
        isSolo = true;
        firstName = fn;
        lastName = ln;
      }
    }
  }

  // Pattern 5: "FirstName LastName's Massage/Spa"
  if (!firstName) {
    const possessiveFullName = name.match(/^([A-Z][a-z]+)\s+([A-Z][a-z]+)'s\s+(?:Massage|Bodywork|Wellness|Spa|Healing)/i);
    if (possessiveFullName && isLikelyFirstName(possessiveFullName[1])) {
      isSolo = true;
      firstName = possessiveFullName[1];
      lastName = possessiveFullName[2];
    }
  }

  // Pattern 6: Three-part name with title
  if (!firstName) {
    const threePartName = name.match(/^([A-Z][a-z]+)\s+([A-Z][a-z]+)\s+([A-Z][a-z]+),?\s+(?:LMT|CMT|RMT|Licensed)/i);
    if (threePartName && isLikelyFirstName(threePartName[1])) {
      isSolo = true;
      firstName = threePartName[1];
      lastName = threePartName[3];
    }
  }

  // Pattern 7: Name embedded after comma
  if (!firstName) {
    const commaNameMatch = name.match(/,\s*([A-Z][a-z]+)\s+([A-Z][a-z]+)(?:\s*,?\s*(?:LMT|CMT|RMT|Licensed))?/i);
    if (commaNameMatch && isLikelyFirstName(commaNameMatch[1])) {
      isSolo = true;
      firstName = commaNameMatch[1];
      lastName = commaNameMatch[2];
    }
  }

  // If estimated_size is solo but no name extracted, still flag as solo
  if (estimatedSize === 'solo' && !isSolo) {
    isSolo = true;
  }

  // Reject if extracted first name matches the company's city
  if (firstName && item.city && firstName.toLowerCase() === item.city.toLowerCase()) {
    firstName = null;
    lastName = null;
  }

  results.push({
    json: {
      ...item,
      _is_solo: isSolo,
      _solo_first_name: firstName,
      _solo_last_name: lastName
    }
  });
}

return results;
===== END NODE =====

===== NODE: Prepare Solo Contact =====
const items = $input.all();
const results = [];

for (const entry of items) {
  const item = entry.json;
  results.push({
    json: {
      _contact: {
        company_id: item.id,
        first_name: item._solo_first_name || null,
        last_name: item._solo_last_name || null,
        role: 'owner',
        is_owner: true,
        email_business: null,
        email_personal: null,
        phone_direct: null,
        linkedin_url: null,
        location: [item.city, item.state].filter(Boolean).join(', ') || null,
        cultural_affinity: null,
        source: 'solo_detection'
      },
      _company_name: item.name,
      _company_id: item.id,
      _source_method: 'solo_detection',
      _has_contact: !!(item._solo_first_name)
    }
  });
}

return results;
===== END NODE =====

===== NODE: Parse Apollo Search =====
// runOnceForAllItems — index-paired with Solo Practitioner Check
const upstreamAll = $('Solo Practitioner Check').all();
const inputAll = $input.all();
const results = [];

// Hoisted keyword arrays
const ownerKeywords = ['owner', 'founder', 'ceo', 'proprietor', 'principal', 'co-founder'];
const managerKeywords = ['manager', 'director', 'general manager', 'gm', 'head'];
const practitionerKeywords = ['massage', 'therapist', 'lmt', 'cmt', 'rmt', 'bodywork', 'esthetician'];

for (let i = 0; i < inputAll.length; i++) {
  const company = upstreamAll[i].json;
  const response = inputAll[i].json;
  const people = response.people || [];

  if (!people || people.length === 0) {
    results.push({
      json: {
        ...company,
        _apollo_found: false,
        _apollo_person_id: null,
        _apollo_person_count: 0
      }
    });
    continue;
  }

  // Score people by role relevance - prefer owners/founders
  let bestPerson = null;
  let bestScore = -1;

  for (const person of people) {
    const title = (person.title || '').toLowerCase();
    let score = 0;

    if (ownerKeywords.some(k => title.includes(k))) score = 10;
    else if (managerKeywords.some(k => title.includes(k))) score = 5;
    else if (practitionerKeywords.some(k => title.includes(k))) score = 3;
    else score = 1;

    // Bonus for having email available
    if (person.has_email === true || person.has_email === 'true') score += 1;

    if (score > bestScore) {
      bestScore = score;
      bestPerson = person;
    }
  }

  console.log(`Apollo search for ${company.domain}: ${people.length} people found. Best: ${bestPerson.first_name} (${bestPerson.title || 'no title'}, score ${bestScore})`);

  results.push({
    json: {
      ...company,
      _apollo_found: true,
      _apollo_person_id: bestPerson.id,
      _apollo_first_name: bestPerson.first_name,
      _apollo_last_name_obfuscated: bestPerson.last_name_obfuscated || null,
      _apollo_title: bestPerson.title || null,
      _apollo_person_count: people.length
    }
  });
}

return results;
===== END NODE =====

===== NODE: Parse Apollo Enrich =====
// runOnceForAllItems — index-paired with Parse Apollo Search
const upstreamAll = $('Parse Apollo Search').all();
const inputAll = $input.all();
const results = [];

for (let i = 0; i < inputAll.length; i++) {
  const company = upstreamAll[i].json;
  const response = inputAll[i].json;
  const person = response.person || response.match || response;

  if (!person || !person.first_name) {
    // Enrichment failed but we still have search data
    results.push({
      json: {
        _contact: {
          company_id: company.id,
          first_name: company._apollo_first_name || null,
          last_name: null,
          role: (company._apollo_title || '').toLowerCase().includes('owner') ? 'owner' : 'unknown',
          is_owner: (company._apollo_title || '').toLowerCase().includes('owner'),
          email_business: null,
          email_personal: null,
          phone_direct: null,
          linkedin_url: null,
          location: [company.city, company.state].filter(Boolean).join(', ') || null,
          cultural_affinity: null,
          source: 'apollo'
        },
        _company_name: company.name,
        _company_id: company.id,
        _source_method: 'apollo_search_only',
        _has_contact: !!(company._apollo_first_name)
      }
    });
    continue;
  }

  // Extract phone number
  let phoneNumber = null;
  if (person.phone_numbers && person.phone_numbers.length > 0) {
    phoneNumber = person.phone_numbers[0].sanitized_number || person.phone_numbers[0].raw_number || null;
  }

  // Determine role
  const title = (person.title || '').toLowerCase();
  let role = 'unknown';
  let isOwner = false;
  if (['owner', 'founder', 'ceo', 'proprietor', 'principal', 'co-founder'].some(k => title.includes(k))) {
    role = 'owner';
    isOwner = true;
  } else if (['manager', 'director', 'gm', 'general manager'].some(k => title.includes(k))) {
    role = 'manager';
  } else if (['massage', 'therapist', 'lmt', 'cmt', 'rmt', 'esthetician'].some(k => title.includes(k))) {
    role = 'practitioner';
  }

  results.push({
    json: {
      _contact: {
        company_id: company.id,
        first_name: person.first_name || null,
        last_name: person.last_name || null,
        role: role,
        is_owner: isOwner,
        email_business: person.email || null,
        email_personal: (person.personal_emails && person.personal_emails[0]) || null,
        phone_direct: phoneNumber,
        linkedin_url: person.linkedin_url || null,
        location: [person.city, person.state].filter(Boolean).join(', ') || [company.city, company.state].filter(Boolean).join(', ') || null,
        cultural_affinity: null,
        source: 'apollo'
      },
      _company_name: company.name,
      _company_id: company.id,
      _source_method: 'apollo_enriched',
      _has_contact: true
    }
  });
}

return results;
===== END NODE =====

===== NODE: Apollo Search Only Contact =====
// Apollo search found someone but enrichment is disabled - use search-only data
const items = $input.all();
const results = [];

for (const entry of items) {
  const item = entry.json;
  results.push({
    json: {
      _contact: {
        company_id: item.id,
        first_name: item._apollo_first_name || null,
        last_name: null,
        role: (item._apollo_title || '').toLowerCase().includes('owner') ? 'owner' : 'unknown',
        is_owner: (item._apollo_title || '').toLowerCase().includes('owner'),
        email_business: null,
        email_personal: null,
        phone_direct: null,
        linkedin_url: null,
        location: [item.city, item.state].filter(Boolean).join(', ') || null,
        cultural_affinity: null,
        source: 'apollo'
      },
      _company_name: item.name,
      _company_id: item.id,
      _source_method: 'apollo_search_only',
      _has_contact: !!(item._apollo_first_name)
    }
  });
}

return results;
===== END NODE =====

===== NODE: Parse About Page =====
// runOnceForAllItems — index-paired with Solo Practitioner Check
// Has async this.helpers.httpRequest() inside loop (required per-item)
const upstreamAll = $('Solo Practitioner Check').all();
const inputAll = $input.all();
const results = [];

const additionalPaths = ['/about-us', '/about-me', '/our-team', '/team', '/our-story'];

const commonFirstNames = new Set([
  'aaron','abby','abigail','adam','adrian','adriana','aiden','aimee','alana','albert',
  'alexa','alexander','alexandra','alexis','alice','alicia','alison','allison','amanda','amber',
  'amelia','amy','ana','andrea','andrew','angela','angelica','angie','anita','ann',
  'anna','anne','annie','anthony','april','aria','ariana','ashley','audrey','ava',
  'avery','bailey','barbara','becky','bella','ben','benjamin','beth','bethany','betty',
  'beverly','bianca','blake','bonnie','brad','bradley','brandi','brandon','brandy','brenda',
  'brent','brian','brianna','bridget','brittany','brooke','bruce','bryan','caitlin','caleb',
  'cameron','candace','cara','carl','carla','carlos','carly','carmen','carol','caroline',
  'carolyn','carrie','casey','cassandra','catherine','cathy','celeste','chad','charlene','charles',
  'charlotte','chelsea','cheryl','chloe','chris','christina','christine','christopher','cindy','claire',
  'clara','claudia','colleen','connor','courtney','craig','crystal','cynthia','daisy','dale',
  'dana','daniel','daniela','danielle','darlene','dave','david','dawn','dean','deanna',
  'debbie','deborah','debra','denise','derek','desiree','diana','diane','dolores','donna',
  'doris','dorothy','douglas','drew','dustin','dylan','eddie','edward','eileen','elaine',
  'elena','elizabeth','ella','ellen','emily','emma','eric','erica','erika','erin',
  'esther','ethan','eva','evelyn','faith','felicia','fiona','florence','frances','frank',
  'gabriel','gabriela','gabrielle','gail','gary','george','georgia','gerald','gina','glen',
  'glenn','gloria','grace','greg','gregory','hailey','haley','hannah','harold','harry',
  'hazel','heather','heidi','helen','henry','holly','hope','howard','hunter','ian',
  'irene','iris','isaac','isabel','isabella','ivy','jack','jackie','jacob','jacqueline',
  'jade','jaime','jake','james','jamie','jane','janet','janice','jared','jasmine',
  'jason','jay','jean','jeff','jeffrey','jenna','jennifer','jenny','jeremy','jerry',
  'jesse','jessica','jill','jim','jimmy','joan','joanna','joanne','jocelyn','jodi',
  'joe','joel','john','johnny','jon','jonathan','jordan','jose','joseph','josh',
  'joshua','joy','joyce','judith','judy','julia','julie','june','justin','kaitlyn',
  'kara','karen','karina','kate','katelyn','katherine','kathleen','kathryn','kathy','katie',
  'katrina','kay','kayla','keith','kelly','kelsey','ken','kendra','kenneth','kevin',
  'kim','kimberly','kirsten','krista','kristen','kristin','kristina','kristy','kyle','kylie',
  'lacey','lana','lance','larry','laura','lauren','laurie','leah','lee','leigh',
  'lena','leon','leslie','lexy','liam','lillian','lily','linda','lindsay','lindsey',
  'lisa','logan','lois','lori','lorraine','louis','louise','lucia','luis','luke',
  'lydia','lynn','mackenzie','madeline','madison','maggie','mallory','mandy','marc','marcia',
  'marcus','margaret','maria','marie','marilyn','marina','mario','marisa','mark','marlene',
  'martha','martin','mary','matt','matthew','maureen','max','maya','megan','meghan',
  'melanie','melinda','melissa','melody','meredith','mia','michael','michele','michelle','miguel',
  'mike','mildred','mindy','miranda','misty','molly','monica','monique','morgan','nadia',
  'nancy','naomi','natalia','natalie','natasha','nathan','nicholas','nicole','nina','noah',
  'nora','norma','olivia','owen','paige','pamela','patricia','patrick','paul','paula',
  'peggy','penny','peter','philip','phyllis','priscilla','rachel','ralph','randy','ray',
  'raymond','rebecca','regina','renee','rhonda','richard','rick','riley','rita','robert',
  'roberta','robin','rodney','roger','ronald','rosa','rose','rosemary','ruby','russell',
  'ruth','ryan','sabrina','sally','samantha','samuel','sandra','sandy','sara','sarah',
  'savannah','scott','sean','selena','serena','seth','shannon','sharon','shawn','sheila',
  'shelby','shelly','sheri','sherry','shirley','sierra','simone','sofia','sonia','sophia',
  'stacey','stacy','stella','stephanie','stephen','steve','steven','sue','summer','susan',
  'suzanne','sydney','sylvia','tamara','tammy','tanya','tara','tatiana','taylor','teresa',
  'terri','terry','tessa','theresa','thomas','tiffany','timothy','tina','tito','todd',
  'tom','toni','tony','tonya','tracey','tracy','travis','tricia','troy','tyler',
  'valerie','vanessa','vera','veronica','vicki','victoria','vincent','violet','virginia','vivian',
  'walter','wanda','wayne','wendy','wesley','whitney','william','willie','wilma','xavier',
  'yolanda','yvette','yvonne','zachary','zoe'
]);

function isLikelyFirstName(word) {
  return commonFirstNames.has((word || '').toLowerCase());
}

function extractName(html) {
  if (!html || html.length < 100) return null;
  const textOnly = html.replace(/<[^>]+>/g, ' ').replace(/\s+/g, ' ');

  const patterns = [
    /(?:owner|owned\s+by|founded\s+by|proprietor)[:\s]+([A-Z][a-z]+)\s+([A-Z][a-z]+)/i,
    /(?:hi,?\s+i'?m|hello,?\s+i'?m|my\s+name\s+is|i\s+am)\s+([A-Z][a-z]+)\s+([A-Z][a-z]+)/i,
    /(?:^|\s)about\s+([A-Z][a-z]+)\s+([A-Z][a-z]+)(?:\s*[,|]|\s+(?:LMT|CMT|RMT|Licensed))/i,
    /(?:^|\s)meet\s+([A-Z][a-z]+)\s+([A-Z][a-z]+)(?:\s*[,|]|\s+(?:LMT|CMT|RMT|Licensed|is\s+a|has\s+been))/i,
    /([A-Z][a-z]+)\s+([A-Z][a-z]+),?\s+(?:LMT|CMT|RMT|Licensed\s+Massage)/i
  ];

  for (const pattern of patterns) {
    for (const source of [textOnly, html]) {
      const match = source.match(pattern);
      if (match) {
        const fn = match[1];
        const ln = match[2];
        if (isLikelyFirstName(fn) &&
            fn.length >= 2 && fn.length <= 20 &&
            ln.length >= 2 && ln.length <= 20) {
          return { firstName: fn, lastName: ln };
        }
      }
    }
  }
  return null;
}

for (let i = 0; i < inputAll.length; i++) {
  const company = upstreamAll[i].json;
  const response = inputAll[i].json;

  // Step 1: Check the upstream /about response
  let bestHtml = '';
  let usedPath = '/about';
  const rawHtml = response.body || response.data || '';
  if (typeof rawHtml === 'string' && rawHtml.length > 500) {
    bestHtml = rawHtml;
  }

  // Step 2: Try to extract name from /about
  let nameResult = bestHtml ? extractName(bestHtml) : null;

  // Step 3: If /about didn't yield a name, try additional paths
  if (!nameResult && company.domain) {
    for (const path of additionalPaths) {
      try {
        const resp = await this.helpers.httpRequest({
          method: 'GET',
          url: `https://${company.domain}${path}`,
          headers: { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36' },
          returnFullResponse: true,
          timeout: 10000,
          json: false,
        });
        const html = resp.body || '';
        if (typeof html === 'string' && html.length > 500) {
          const found = extractName(html);
          if (found) {
            nameResult = found;
            usedPath = path;
            console.log(`Found name on ${path}: ${found.firstName} ${found.lastName}`);
            break;
          }
        }
      } catch(e) {
        // Path doesn't exist or timed out — try next
      }
    }
  }

  const hasContact = !!(nameResult);

  results.push({
    json: {
      _contact: hasContact ? {
        company_id: company.id,
        first_name: nameResult.firstName,
        last_name: nameResult.lastName,
        role: 'owner',
        is_owner: true,
        email_business: null,
        email_personal: null,
        phone_direct: null,
        linkedin_url: null,
        location: [company.city, company.state].filter(Boolean).join(', ') || null,
        cultural_affinity: null,
        source: 'website'
      } : null,
      _company_name: company.name,
      _company_id: company.id,
      _source_method: hasContact ? `website_scrape_${usedPath.replace('/', '')}` : 'website_scrape',
      _has_contact: hasContact
    }
  });
}

return results;
===== END NODE =====

===== NODE: No Domain Fallback =====
// runOnceForAllItems — hoist name list + helper outside loop
const items = $input.all();
const results = [];

const commonFirstNames = new Set([
  'aaron','abby','abigail','adam','adrian','adriana','aiden','aimee','alana','albert',
  'alexa','alexander','alexandra','alexis','alice','alicia','alison','allison','amanda','amber',
  'amelia','amy','ana','andrea','andrew','angela','angelica','angie','anita','ann',
  'anna','anne','annie','anthony','april','aria','ariana','ashley','audrey','ava',
  'avery','bailey','barbara','becky','bella','ben','benjamin','beth','bethany','betty',
  'beverly','bianca','blake','bonnie','brad','bradley','brandi','brandon','brandy','brenda',
  'brent','brian','brianna','bridget','brittany','brooke','bruce','bryan','caitlin','caleb',
  'cameron','candace','cara','carl','carla','carlos','carly','carmen','carol','caroline',
  'carolyn','carrie','casey','cassandra','catherine','cathy','celeste','chad','charlene','charles',
  'charlotte','chelsea','cheryl','chloe','chris','christina','christine','christopher','cindy','claire',
  'clara','claudia','colleen','connor','courtney','craig','crystal','cynthia','daisy','dale',
  'dana','daniel','daniela','danielle','darlene','dave','david','dawn','dean','deanna',
  'debbie','deborah','debra','denise','derek','desiree','diana','diane','dolores','donna',
  'doris','dorothy','douglas','drew','dustin','dylan','eddie','edward','eileen','elaine',
  'elena','elizabeth','ella','ellen','emily','emma','eric','erica','erika','erin',
  'esther','ethan','eva','evelyn','faith','felicia','fiona','florence','frances','frank',
  'gabriel','gabriela','gabrielle','gail','gary','george','georgia','gerald','gina','glen',
  'glenn','gloria','grace','greg','gregory','hailey','haley','hannah','harold','harry',
  'hazel','heather','heidi','helen','henry','holly','hope','howard','hunter','ian',
  'irene','iris','isaac','isabel','isabella','ivy','jack','jackie','jacob','jacqueline',
  'jade','jaime','jake','james','jamie','jane','janet','janice','jared','jasmine',
  'jason','jay','jean','jeff','jeffrey','jenna','jennifer','jenny','jeremy','jerry',
  'jesse','jessica','jill','jim','jimmy','joan','joanna','joanne','jocelyn','jodi',
  'joe','joel','john','johnny','jon','jonathan','jordan','jose','joseph','josh',
  'joshua','joy','joyce','judith','judy','julia','julie','june','justin','kaitlyn',
  'kara','karen','karina','kate','katelyn','katherine','kathleen','kathryn','kathy','katie',
  'katrina','kay','kayla','keith','kelly','kelsey','ken','kendra','kenneth','kevin',
  'kim','kimberly','kirsten','krista','kristen','kristin','kristina','kristy','kyle','kylie',
  'lacey','lana','lance','larry','laura','lauren','laurie','leah','lee','leigh',
  'lena','leon','leslie','lexy','liam','lillian','lily','linda','lindsay','lindsey',
  'lisa','logan','lois','lori','lorraine','louis','louise','lucia','luis','luke',
  'lydia','lynn','mackenzie','madeline','madison','maggie','mallory','mandy','marc','marcia',
  'marcus','margaret','maria','marie','marilyn','marina','mario','marisa','mark','marlene',
  'martha','martin','mary','matt','matthew','maureen','max','maya','megan','meghan',
  'melanie','melinda','melissa','melody','meredith','mia','michael','michele','michelle','miguel',
  'mike','mildred','mindy','miranda','misty','molly','monica','monique','morgan','nadia',
  'nancy','naomi','natalia','natalie','natasha','nathan','nicholas','nicole','nina','noah',
  'nora','norma','olivia','owen','paige','pamela','patricia','patrick','paul','paula',
  'peggy','penny','peter','philip','phyllis','priscilla','rachel','ralph','randy','ray',
  'raymond','rebecca','regina','renee','rhonda','richard','rick','riley','rita','robert',
  'roberta','robin','rodney','roger','ronald','rosa','rose','rosemary','ruby','russell',
  'ruth','ryan','sabrina','sally','samantha','samuel','sandra','sandy','sara','sarah',
  'savannah','scott','sean','selena','serena','seth','shannon','sharon','shawn','sheila',
  'shelby','shelly','sheri','sherry','shirley','sierra','simone','sofia','sonia','sophia',
  'stacey','stacy','stella','stephanie','stephen','steve','steven','sue','summer','susan',
  'suzanne','sydney','sylvia','tamara','tammy','tanya','tara','tatiana','taylor','teresa',
  'terri','terry','tessa','theresa','thomas','tiffany','timothy','tina','tito','todd',
  'tom','toni','tony','tonya','tracey','tracy','travis','tricia','troy','tyler',
  'valerie','vanessa','vera','veronica','vicki','victoria','vincent','violet','virginia','vivian',
  'walter','wanda','wayne','wendy','wesley','whitney','william','willie','wilma','xavier',
  'yolanda','yvette','yvonne','zachary','zoe'
]);

function isLikelyFirstName(word) {
  return commonFirstNames.has(word.toLowerCase());
}

for (const entry of items) {
  const item = entry.json;
  const name = (item.name || '').trim();

  let firstName = null;
  let lastName = null;

  // Pattern 1: "by Name"
  const byPattern = name.match(/\bby\s+([A-Z][a-z]+)(?:\s+([A-Z][a-z]+))?/i);
  if (byPattern && isLikelyFirstName(byPattern[1])) {
    firstName = byPattern[1];
    lastName = byPattern[2] || null;
  }

  // Pattern 2: "with Name"
  if (!firstName) {
    const withPattern = name.match(/\bwith\s+([A-Z][a-z]+)(?:\s+([A-Z][a-z]+))?/i);
    if (withPattern && isLikelyFirstName(withPattern[1])) {
      firstName = withPattern[1];
      lastName = withPattern[2] || null;
    }
  }

  // Pattern 3: Possessive
  if (!firstName) {
    const possessive = name.match(/^([A-Z][a-z]+)'s\s+/i);
    if (possessive && isLikelyFirstName(possessive[1])) {
      firstName = possessive[1];
    }
  }

  // Pattern 4: "FirstName LastName, LMT"
  if (!firstName) {
    const credMatch = name.match(/^([A-Z][a-z]+)\s+([A-Z][a-z]+)(?:\s*,?\s*(?:LMT|CMT|RMT|Licensed))/i);
    if (credMatch && isLikelyFirstName(credMatch[1])) {
      firstName = credMatch[1];
      lastName = credMatch[2];
    }
  }

  // Pattern 5: Name after comma
  if (!firstName) {
    const commaMatch = name.match(/,\s*([A-Z][a-z]+)\s+([A-Z][a-z]+)/i);
    if (commaMatch && isLikelyFirstName(commaMatch[1])) {
      firstName = commaMatch[1];
      lastName = commaMatch[2];
    }
  }

  // Pattern 6: Validated first+last before business keyword
  if (!firstName) {
    const nameKeyword = name.match(/^([A-Z][a-z]+)\s+([A-Z][a-z]+)\s+(?:Massage|Bodywork|Therapeutic|Wellness|Healing|Spa)/i);
    if (nameKeyword && isLikelyFirstName(nameKeyword[1]) && !isLikelyFirstName(nameKeyword[2])) {
      firstName = nameKeyword[1];
      lastName = nameKeyword[2];
    }
  }

  const hasContact = !!(firstName);

  results.push({
    json: {
      _contact: hasContact ? {
        company_id: item.id,
        first_name: firstName,
        last_name: lastName,
        role: 'owner',
        is_owner: true,
        email_business: null,
        email_personal: null,
        phone_direct: null,
        linkedin_url: null,
        location: [item.city, item.state].filter(Boolean).join(', ') || null,
        cultural_affinity: null,
        source: 'manual'
      } : null,
      _company_name: item.name,
      _company_id: item.id,
      _source_method: 'no_domain_name_extraction',
      _has_contact: hasContact
    }
  });
}

return results;
===== END NODE =====

===== NODE: Validate & Clean Contact =====
// Validate & Clean Contact — runOnceForAllItems
// Cleans emails, phones, names, LinkedIn URLs before Supabase insert.
// Nulls out invalid data rather than blocking the insert.
// Adds _validation_flags array for audit trail.

const items = $input.all();
const results = [];

// Helper functions accept flags array as parameter (not closure)
function validateEmail(email, fieldName, flags) {
  if (!email) return null;
  let cleaned = email.trim().toLowerCase();
  const emailRegex = /^[a-zA-Z0-9._%+\-]+@[a-zA-Z0-9.\-]+\.[a-zA-Z]{2,}$/;
  if (!emailRegex.test(cleaned)) {
    flags.push(`${fieldName}_invalid_format: "${email}"`);
    return null;
  }
  const junkPatterns = [
    /^noreply@/, /^no-reply@/, /^donotreply@/, /^do-not-reply@/,
    /^test@/, /^admin@example\./, /^info@example\./, /^user@example\./,
    /^sample@/, /^fake@/, /^placeholder@/, /^null@/, /^none@/, /^na@/,
    /^n\/a@/, /^unknown@/, /^abuse@/, /^postmaster@/, /^mailer-daemon@/
  ];
  if (junkPatterns.some(p => p.test(cleaned))) {
    flags.push(`${fieldName}_junk_pattern: "${cleaned}"`);
    return null;
  }
  const rolePatterns = [
    /^info@/, /^contact@/, /^hello@/, /^support@/, /^sales@/, /^office@/,
    /^billing@/, /^reception@/, /^frontdesk@/, /^front\.desk@/,
    /^appointments@/, /^booking@/, /^bookings@/, /^schedule@/,
    /^scheduling@/, /^inquiries@/, /^inquiry@/, /^general@/, /^team@/, /^staff@/
  ];
  if (rolePatterns.some(p => p.test(cleaned))) {
    flags.push(`${fieldName}_role_based_kept: "${cleaned}"`);
  }
  const junkDomains = [
    'example.com', 'example.org', 'example.net', 'test.com', 'test.org',
    'placeholder.com', 'fake.com', 'noemail.com', 'nomail.com', 'none.com',
    'localhost', 'mailinator.com', 'guerrillamail.com', 'tempmail.com',
    'throwaway.email', 'yopmail.com'
  ];
  const domain = cleaned.split('@')[1];
  if (junkDomains.includes(domain)) {
    flags.push(`${fieldName}_junk_domain: "${domain}"`);
    return null;
  }
  const localPart = cleaned.split('@')[0];
  if (/^\d+$/.test(localPart)) {
    flags.push(`${fieldName}_numeric_local: "${cleaned}"`);
    return null;
  }
  if (localPart.startsWith('.') || localPart.endsWith('.') || localPart.includes('..')) {
    flags.push(`${fieldName}_malformed_local: "${cleaned}"`);
    return null;
  }
  return cleaned;
}

function validatePhone(phone, fieldName, flags) {
  if (!phone) return null;
  if (typeof phone === 'object' && phone !== null) {
    phone = phone.sanitized_number || phone.raw_number || phone.number || '';
  }
  let cleaned = phone.toString().trim();
  cleaned = cleaned.replace(/[^\d]/g, '');
  if (!cleaned || cleaned.length === 0) {
    flags.push(`${fieldName}_empty_after_strip`);
    return null;
  }
  if (cleaned.length === 11 && cleaned.startsWith('1')) {
    // already has country code
  } else if (cleaned.length === 10) {
    cleaned = '1' + cleaned;
  } else if (cleaned.length < 10) {
    flags.push(`${fieldName}_too_short: "${phone}" (${cleaned.length} digits)`);
    return null;
  } else if (cleaned.length > 11) {
    flags.push(`${fieldName}_possibly_international: "${phone}" (${cleaned.length} digits)`);
    return '+' + cleaned;
  }
  const areaCode = cleaned.substring(1, 4);
  if (areaCode.startsWith('0') || areaCode.startsWith('1')) {
    flags.push(`${fieldName}_invalid_area_code: "${areaCode}"`);
    return null;
  }
  return '+' + cleaned;
}

function cleanName(name, fieldName, flags) {
  if (!name) return null;
  let cleaned = name.trim();
  cleaned = cleaned.replace(/\*+$/, '').trim();
  if (cleaned.length <= 1) {
    flags.push(`${fieldName}_too_short: "${name}"`);
    return null;
  }
  if (/^\d+$/.test(cleaned)) {
    flags.push(`${fieldName}_numeric: "${name}"`);
    return null;
  }
  if (/\d/.test(cleaned)) {
    flags.push(`${fieldName}_contains_digits: "${name}"`);
    return null;
  }
  const junkNames = [
    'unknown', 'n/a', 'na', 'none', 'null', 'test',
    'owner', 'manager', 'admin', 'info', 'contact'
  ];
  if (junkNames.includes(cleaned.toLowerCase())) {
    flags.push(`${fieldName}_junk_name: "${name}"`);
    return null;
  }
  const credentials = [
    'lmt', 'cmt', 'rmt', 'lmbt', 'lmp', 'bctmb', 'nctmb', 'nctm',
    'cpt', 'cst', 'mld', 'nmt', 'amt', 'abmp'
  ];
  if (credentials.includes(cleaned.toLowerCase())) {
    flags.push(`${fieldName}_credential_not_name: "${name}"`);
    return null;
  }
  if (cleaned === cleaned.toUpperCase() || cleaned === cleaned.toLowerCase()) {
    cleaned = cleaned.charAt(0).toUpperCase() + cleaned.slice(1).toLowerCase();
  }
  return cleaned;
}

function validateLinkedIn(url, flags) {
  if (!url) return null;
  let cleaned = url.trim();
  if (!/linkedin\.com\/in\//i.test(cleaned)) {
    if (/linkedin\.com/i.test(cleaned)) {
      flags.push(`linkedin_not_personal_profile: "${cleaned}"`);
    } else {
      flags.push(`linkedin_invalid_url: "${cleaned}"`);
    }
    return null;
  }
  if (!cleaned.startsWith('http')) {
    cleaned = 'https://' + cleaned;
  }
  cleaned = cleaned.replace(/^http:\/\//, 'https://');
  return cleaned;
}

for (const entry of items) {
  const item = entry.json;
  const contact = item._contact;
  const flags = [];

  if (!contact) {
    results.push({ json: { ...item, _validation_flags: ['no_contact_object'] } });
    continue;
  }

  contact.email_business = validateEmail(contact.email_business, 'email_business', flags);
  contact.email_personal = validateEmail(contact.email_personal, 'email_personal', flags);
  contact.phone_direct = validatePhone(contact.phone_direct, 'phone_direct', flags);
  contact.first_name = cleanName(contact.first_name, 'first_name', flags);
  contact.last_name = cleanName(contact.last_name, 'last_name', flags);

  if (!contact.first_name) {
    flags.push('contact_has_no_valid_first_name');
  }

  contact.linkedin_url = validateLinkedIn(contact.linkedin_url, flags);

  if (contact.location) {
    contact.location = contact.location.trim();
    if (!contact.location || contact.location === ',' || contact.location.length < 2) {
      contact.location = null;
      flags.push('location_empty_after_clean');
    }
  }

  const hasValidContact = !!(contact.first_name);

  if (flags.length > 0) {
    console.log(`Validation [${item._company_name}] (${item._source_method}): ${flags.join(', ')}`);
  }

  results.push({
    json: {
      _contact: contact,
      _company_name: item._company_name,
      _company_id: item._company_id,
      _source_method: item._source_method,
      _has_contact: hasValidContact,
      _validation_flags: flags
    }
  });
}

return results;
===== END NODE =====

===== NODE: Filter & Parse Batch =====
// Get companies from upstream Fetch Companies node
const companyItems = $('Fetch Companies').all();
let companies = [];
if (companyItems.length === 1 && Array.isArray(companyItems[0].json)) {
  companies = companyItems[0].json;
} else {
  companies = companyItems.map(i => i.json);
}

// Get existing contact company_ids
const contactItems = $input.all();
let existingIds = new Set();
for (const item of contactItems) {
  if (item.json && item.json.company_id) {
    existingIds.add(item.json.company_id);
  }
  // Handle array response
  if (Array.isArray(item.json)) {
    for (const row of item.json) {
      if (row.company_id) existingIds.add(row.company_id);
    }
  }
}

// Filter out companies that already have contacts
const filtered = companies.filter(c => c.id && !existingIds.has(c.id));

console.log(`Companies: ${companies.length} total, ${existingIds.size} already have contacts, ${filtered.length} need people discovery`);

if (filtered.length === 0) {
  return [{ json: { _empty: true, _count: 0, _message: 'All companies already have contacts or no companies to process' } }];
}

return filtered.map(c => ({ json: c }));
===== END NODE =====

===== NODE: Collapse to Single1 =====
// Collapse 7 convergence paths into single item to prevent Task Runner crash loop
// ADR-024: Suppress redundant convergence batches — only fire once per execution
const staticData = $getWorkflowStaticData('global');
if (staticData._collapse1_fired) {
  return [];
}
staticData._collapse1_fired = true;

// ADR-026: Stabilization polling — wait for Step 2 to finish enriching ALL companies
// before triggering Step 3a. Without this, Step 3a fires after the first company
// exits Step 2, missing ~95% of companies for new cities.
const metro = $('Metro Config').first().json.metro_name;
const headers = {
  'apikey': $env.SUPABASE_SERVICE_KEY,
  'Authorization': 'Bearer ' + $env.SUPABASE_SERVICE_KEY
};

let prevCount = -1;
let stableRounds = 0;

for (let i = 0; i < 80; i++) {
  await new Promise(r => setTimeout(r, 15000));

  const rows = await this.helpers.httpRequest({
    method: 'GET',
    url: $env.SUPABASE_URL + '/rest/v1/companies?enrichment_status=eq.discovered&discovery_metro=eq.' + encodeURIComponent(metro) + '&select=id',
    headers,
    json: true
  });
  const count = Array.isArray(rows) ? rows.length : 0;

  // Wait for discovered count to reach 0 (all companies processed by Step 2)
  if (count === prevCount && count === 0) {
    stableRounds++;
    if (stableRounds >= 2) break;
  } else {
    stableRounds = 0;
  }
  prevCount = count;
}

return [{ json: { _trigger: 'social_processing_complete', _remaining_discovered: prevCount } }];
===== END NODE =====

===== NODE: Enrich Contacts =====
// Enrich Contacts — Single Code node replacing the entire Step 4 branching pipeline
// Mode: runOnceForAllItems
// Uses this.helpers.httpRequest() for inline HTTP calls (NOT $http which is unavailable)

const config = $('Step 4 Config').first().json;
const contacts = $input.all().filter(item => !item.json._empty);

const results = [];

// Helper: delay between API calls for rate limiting
const delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));

// Dedup guard: track companies that already had email set/verified this execution
const staticData = $getWorkflowStaticData('global');
if (!staticData._companyEmailsSet) staticData._companyEmailsSet = {};
const companyEmailsSet = staticData._companyEmailsSet;

// BUG-F019 FIX: Clear ALL stale keys from previous executions.
// $getWorkflowStaticData('global') persists across executions, not just batches.
// Without this, company phone/email dedup guards from previous runs permanently
// block verification for companies that were already processed.
// Within a single execution, keys are rebuilt as contacts are processed.
for (const key of Object.keys(companyEmailsSet)) {
  delete companyEmailsSet[key];
}

// ADR-024: Per-contact dedup — track enriched contacts across convergence batches
if (!staticData._enriched_contact_ids) {
  staticData._enriched_contact_ids = {};
}

// Phone validation (from Prepare Contact Update)
function validatePhone(phone) {
  if (!phone) return null;
  if (typeof phone === 'object' && phone !== null) {
    phone = phone.sanitized_number || phone.raw_number || phone.number || '';
  }
  let cleaned = phone.toString().trim().replace(/[^\d]/g, '');
  if (!cleaned || cleaned.length === 0) return null;
  if (cleaned.length === 11 && cleaned.startsWith('1')) { /* ok */ }
  else if (cleaned.length === 10) { cleaned = '1' + cleaned; }
  else if (cleaned.length < 10) { return null; }
  else if (cleaned.length > 11 && cleaned.length <= 15) {
    // International number - allow if not starting with 1 (NA)
    if (cleaned.startsWith('1')) return null;  // NA number too long
    return '+' + cleaned;
  }
  else if (cleaned.length > 15) { return null; }  // ITU max is 15 digits
  const areaCode = cleaned.substring(1, 4);
  if (areaCode.startsWith('0') || areaCode.startsWith('1')) return null;
  return '+' + cleaned;
}

// Role-based email detection (same 19+1 patterns as Validate & Clean Contact)
const rolePatterns = [
  /^info@/i, /^contact@/i, /^hello@/i, /^support@/i, /^sales@/i,
  /^office@/i, /^billing@/i, /^reception@/i, /^frontdesk@/i, /^front\.desk@/i,
  /^appointments@/i, /^booking@/i, /^bookings@/i, /^schedule@/i, /^scheduling@/i,
  /^inquiries@/i, /^inquiry@/i, /^general@/i, /^team@/i, /^staff@/i
];

function isRoleBased(email) {
  if (!email) return false;
  return rolePatterns.some(p => p.test(email));
}

// Free webmail domains (role-based check doesn't apply to these)
const freeWebmailDomains = [
  'gmail.com', 'yahoo.com', 'outlook.com', 'hotmail.com', 'aol.com',
  'icloud.com', 'me.com', 'mac.com', 'live.com', 'msn.com',
  'protonmail.com', 'proton.me', 'zoho.com', 'yandex.com',
  'mail.com', 'gmx.com', 'fastmail.com', 'tutanota.com'
];

function isFreeWebmail(email) {
  if (!email) return false;
  const domain = email.split('@')[1];
  return freeWebmailDomains.includes(domain);
}

// Helper: verify an email via Hunter Verifier API
async function verifyEmail(email) {
  try {
    const verifyUrl = `https://api.hunter.io/v2/email-verifier?email=${encodeURIComponent(email)}&api_key=${$env.HUNTER_API_KEY}`;
    const verifyResp = await this.helpers.httpRequest({ method: 'GET', url: verifyUrl, headers: { 'Accept': 'application/json' }, json: true });
    const vBody = verifyResp.data || verifyResp;
    if (vBody && vBody.status) {
      let status;
      switch (vBody.status) {
        case 'valid': status = 'verified'; break;
        case 'invalid': status = 'invalid'; break;
        case 'accept_all': status = 'accept_all'; break;
        case 'disposable': status = 'invalid'; break;
        case 'webmail': status = 'verified'; break;
        default: status = 'risky'; break;
      }
      return { status, score: vBody.score || null, verified_at: new Date().toISOString() };
    }
  } catch(e) {
    console.log(`Verifier error for ${email}: ${e.message}`);
  }
  return null;
}

// Helper: verify a phone number via Telnyx Number Lookup API
async function verifyPhone(phoneNumber) {
  try {
    const resp = await this.helpers.httpRequest({
      method: 'GET',
      url: `https://api.telnyx.com/v2/number_lookup/${encodeURIComponent(phoneNumber)}?type=carrier`,
      headers: {
        'Authorization': `Bearer ${$env.TELNYX_API_KEY}`,
        'Accept': 'application/json'
      },
      json: true
    });
    const data = resp.data || resp;
    if (data && data.valid === false) {
      return { phone_status: 'invalid', phone_line_type: null, phone_carrier: null };
    }
    // Map carrier type
    let lineType = null;
    const carrierType = (data.carrier && data.carrier.type) || null;
    if (carrierType) {
      const typeMap = { 'mobile': 'mobile', 'landline': 'landline', 'fixed line': 'landline', 'voip': 'voip', 'toll free': 'toll_free', 'toll_free': 'toll_free' };
      lineType = typeMap[carrierType.toLowerCase()] || null;
    }
    const carrierName = (data.carrier && data.carrier.name) || null;
    const phoneStatus = lineType === 'voip' ? 'voip' : 'valid';
    return {
      phone_status: phoneStatus,
      phone_line_type: lineType,
      phone_carrier: carrierName
    };
  } catch(e) {
    // 404 or 422 = invalid number
    if (e.statusCode === 404 || e.statusCode === 422) {
      return { phone_status: 'invalid', phone_line_type: null, phone_carrier: null };
    }
    console.log(`Telnyx error for ${phoneNumber}: ${e.message} (status: ${e.statusCode || 'unknown'})`);
    return { phone_status: null, phone_line_type: null, phone_carrier: null, _error: `${e.statusCode || 'unknown'}: ${e.message}` };
  }
}

for (const item of contacts) {
  const contact = { ...item.json };

  // ADR-024: Skip if already enriched in a previous convergence batch
  const contactId = contact.id;
  if (staticData._enriched_contact_ids[contactId]) {
    results.push({
      json: {
        _contact_id: contactId,
        _company_id: contact.company_id,
        _first_name: contact.first_name,
        _last_name: contact.last_name,
        _company_name: contact._company_name,
        _skip_reason: 'already_enriched_in_earlier_batch',
        _has_updates: false
      }
    });
    continue;
  }
  // Mark as enriched
  staticData._enriched_contact_ids[contactId] = true;

  // Initialize enrichment fields
  contact._hunter_email = null;
  contact._hunter_score = 0;
  contact._hunter_linkedin = null;
  contact._hunter_phone = null;
  contact._snovio_email = null;
  contact._email_source = null;
  contact._best_email = contact.email_business || null;
  contact._best_phone = contact.phone_direct || contact._company_phone || null;
  contact._best_linkedin = contact.linkedin_url || null;
  contact._email_status = null;
  contact._email_verified_at = null;
  contact._verifier_score = null;
  contact._cultural_affinity = contact.cultural_affinity || null;
  contact._namsor_country = null;
  contact._namsor_region = null;
  contact._namsor_probability = null;
  contact._company_email_routed = false;
  contact._company_email_verified = false;
  contact._phone_status = null;
  contact._phone_line_type = null;
  contact._phone_carrier = null;
  contact._company_phone_verified = false;
  contact._phone_error = null;

  const needsEmail = !contact.email_business;
  const hasDomainAndName = contact._company_domain && contact.first_name;
  const verifiedStatuses = ['verified', 'invalid', 'risky', 'accept_all'];
  const emailNeedsVerification = contact.email_business && !verifiedStatuses.includes(contact.email_status);

  // EMAIL WATERFALL

  if (needsEmail && hasDomainAndName) {
    // --- HUNTER EMAIL FINDER ---
    if (config.skip_hunter !== 'true') {
      try {
        const hunterUrl = `https://api.hunter.io/v2/email-finder?domain=${encodeURIComponent(contact._company_domain)}&first_name=${encodeURIComponent(contact.first_name)}&last_name=${encodeURIComponent(contact.last_name || '')}&api_key=${$env.HUNTER_API_KEY}`;
        const hunterResp = await this.helpers.httpRequest({ method: 'GET', url: hunterUrl, headers: { 'Accept': 'application/json' }, json: true });
        const hData = hunterResp.data || hunterResp;
        if (hData && hData.email && (hData.score === undefined || hData.score >= 50)) {
          contact._hunter_email = hData.email;
          contact._hunter_score = hData.score || 0;
          contact._hunter_linkedin = hData.linkedin_url || null;
          contact._hunter_phone = hData.phone_number || null;
          contact._email_source = 'hunter';
        }
        await delay(200);
      } catch(e) {
        console.log(`Hunter error for ${contact.first_name}: ${e.message}`);
      }
    }

    // --- SNOV.IO EMAIL FINDER (fallback) ---
    if (!contact._hunter_email && config.skip_snovio !== 'true') {
      try {
        const snovResp = await this.helpers.httpRequest({
          method: 'POST',
          url: 'https://api.snov.io/v1/get-emails-from-names',
          headers: { 'Content-Type': 'application/json' },
          body: {
            firstName: contact.first_name,
            lastName: contact.last_name || '',
            domain: contact._company_domain
          },
          json: true
        });
        const emails = snovResp.emails || snovResp.data?.emails || [];
        if (Array.isArray(emails) && emails.length > 0) {
          const valid = emails.find(e => e.emailStatus === 'valid' || e.status === 'valid') || emails[0];
          contact._snovio_email = valid.email || valid.value || null;
          if (contact._snovio_email) contact._email_source = 'snovio';
        }
        await delay(500);
      } catch(e) {
        console.log(`Snov.io error for ${contact.first_name}: ${e.message}`);
      }
    }

    contact._best_email = contact._hunter_email || contact._snovio_email || null;
    contact._best_phone = contact.phone_direct || contact._hunter_phone || contact._company_phone || null;
    contact._best_linkedin = contact.linkedin_url || contact._hunter_linkedin || null;
  } else if (contact.email_business) {
    contact._best_email = contact.email_business;
    contact._email_source = 'existing';
  }

  // COMPANY EMAIL ROUTING
  // If contact's email is role-based, route it to the company

  if (contact._best_email && isRoleBased(contact._best_email) && !isFreeWebmail(contact._best_email)) {
    const companyId = contact.company_id;
    const companyHasEmail = !!(contact._company_email);

    if (!companyHasEmail && !companyEmailsSet[companyId]) {
      contact._routed_company_email = contact._best_email;
      contact._company_email_routed = true;
      companyEmailsSet[companyId] = contact._best_email;
      console.log(`Routed role-based email ${contact._best_email} to company ${contact._company_name || companyId}`);
    }

    if (contact.email_personal) {
      contact._best_email = contact.email_personal;
      contact._email_source = 'personal_promoted';
      console.log(`Promoted personal email ${contact.email_personal} for ${contact.first_name} (role-based went to company)`);
    }
  }

  // EMAIL VERIFICATION (contact email)

  if (contact._best_email && config.skip_hunter_verifier !== 'true') {
    const shouldVerify = !contact.email_business || emailNeedsVerification || contact._email_source === 'hunter' || contact._email_source === 'snovio' || contact._email_source === 'personal_promoted';
    if (shouldVerify) {
      const vResult = await verifyEmail.call(this, contact._best_email);
      if (vResult) {
        contact._email_status = vResult.status;
        contact._email_verified_at = vResult.verified_at;
        contact._verifier_score = vResult.score;
      }
      await delay(700);
    }
  } else if (contact._best_email) {
    contact._email_status = 'unverified';
  }

  // COMPANY EMAIL VERIFICATION
  // Verify company email if it hasn't been verified yet (from website scrape OR routing)

  const companyEmailToVerify = contact._routed_company_email || contact._company_email;
  const companyEmailNeedsVerification = companyEmailToVerify && !contact._company_email_status;
  const companyId = contact.company_id;

  if (companyEmailNeedsVerification && config.skip_hunter_verifier !== 'true' && !companyEmailsSet[companyId + '_verified']) {
    const vResult = await verifyEmail.call(this, companyEmailToVerify);
    let companyPatch = {};

    if (contact._routed_company_email) {
      companyPatch.email = contact._routed_company_email;
    }

    if (vResult) {
      companyPatch.email_status = vResult.status;
      contact._company_email_verified = true;
      console.log(`Verified company email ${companyEmailToVerify}: ${vResult.status}`);
    }

    if (Object.keys(companyPatch).length > 0) {
      try {
        await this.helpers.httpRequest({
          method: 'PATCH',
          url: `${$env.SUPABASE_URL}/rest/v1/companies?id=eq.${companyId}`,
          headers: {
            'apikey': $env.SUPABASE_SERVICE_KEY,
            'Authorization': `Bearer ${$env.SUPABASE_SERVICE_KEY}`,
            'Content-Type': 'application/json',
            'Prefer': 'return=minimal'
          },
          body: companyPatch,
          json: true
        });
        console.log(`PATCHed company ${contact._company_name || companyId}: ${JSON.stringify(companyPatch)}`);
      } catch(e) {
        console.log(`Company PATCH error for ${companyId}: ${e.message}`);
      }
    }

    companyEmailsSet[companyId + '_verified'] = true;
    await delay(700);
  } else if (contact._routed_company_email && !companyEmailsSet[companyId + '_verified']) {
    try {
      await this.helpers.httpRequest({
        method: 'PATCH',
        url: `${$env.SUPABASE_URL}/rest/v1/companies?id=eq.${companyId}`,
        headers: {
          'apikey': $env.SUPABASE_SERVICE_KEY,
          'Authorization': `Bearer ${$env.SUPABASE_SERVICE_KEY}`,
          'Content-Type': 'application/json',
          'Prefer': 'return=minimal'
        },
        body: { email: contact._routed_company_email },
        json: true
      });
      console.log(`PATCHed company email (unverified) ${contact._company_name || companyId}: ${contact._routed_company_email}`);
    } catch(e) {
      console.log(`Company PATCH error for ${companyId}: ${e.message}`);
    }
    companyEmailsSet[companyId + '_verified'] = true;
    await delay(50);
  }

  // NAMSOR CULTURAL AFFINITY

  if (!contact.cultural_affinity && contact.first_name && (contact.last_name || '').length > 0 && config.skip_namsor !== 'true') {
    try {
      const namsorUrl = `https://v2.namsor.com/NamSorAPIv2/api2/json/origin/${encodeURIComponent(contact.first_name)}/${encodeURIComponent(contact.last_name || 'Unknown')}`;
      const namsorResp = await this.helpers.httpRequest({ method: 'GET', url: namsorUrl, headers: { 'X-API-KEY': $env.NAMSOR_API_KEY, 'Accept': 'application/json' }, json: true });
      if (namsorResp && namsorResp.countryOrigin) {
        const parts = [];
        if (namsorResp.regionOrigin) parts.push(namsorResp.regionOrigin);
        if (namsorResp.subRegionOrigin && namsorResp.subRegionOrigin !== namsorResp.regionOrigin) parts.push(namsorResp.subRegionOrigin);
        if (namsorResp.countryOrigin) parts.push(namsorResp.countryOrigin);
        contact._cultural_affinity = parts.join(' / ');
        if (namsorResp.probabilityCalibrated && namsorResp.probabilityCalibrated < 0.3) {
          contact._cultural_affinity += ' (low confidence)';
        }
        contact._namsor_country = namsorResp.countryOrigin;
        contact._namsor_region = namsorResp.regionOrigin;
        contact._namsor_probability = namsorResp.probabilityCalibrated;
      }
      await delay(100);
    } catch(e) {
      console.log(`NamSor error for ${contact.first_name}: ${e.message}`);
    }
  }

  // PHONE VERIFICATION (Telnyx Number Lookup)

  if (contact._best_phone && !contact.phone_status && config.skip_phone_verifier !== 'true') {
    const phoneResult = await verifyPhone.call(this, contact._best_phone);
    if (phoneResult) {
      contact._phone_status = phoneResult.phone_status;
      contact._phone_line_type = phoneResult.phone_line_type;
      contact._phone_carrier = phoneResult.phone_carrier;
      if (phoneResult._error) {
        contact._phone_error = phoneResult._error;
      } else {
        console.log(`Phone verified ${contact._best_phone}: ${phoneResult.phone_status} (${phoneResult.phone_line_type || 'unknown type'}, ${phoneResult.phone_carrier || 'unknown carrier'})`);
      }
    }
    await delay(100);
  }

  // COMPANY PHONE VERIFICATION (Telnyx)
  if (contact._company_phone && !contact._company_phone_status && config.skip_phone_verifier !== 'true' && !companyEmailsSet[companyId + '_phone_verified']) {
    const compPhoneResult = await verifyPhone.call(this, contact._company_phone);
    if (compPhoneResult && !compPhoneResult._error) {
      try {
        await this.helpers.httpRequest({
          method: 'PATCH',
          url: `${$env.SUPABASE_URL}/rest/v1/companies?id=eq.${companyId}`,
          headers: {
            'apikey': $env.SUPABASE_SERVICE_KEY,
            'Authorization': `Bearer ${$env.SUPABASE_SERVICE_KEY}`,
            'Content-Type': 'application/json',
            'Prefer': 'return=minimal'
          },
          body: {
            phone_status: compPhoneResult.phone_status,
            phone_line_type: compPhoneResult.phone_line_type
          },
          json: true
        });
        contact._company_phone_verified = true;
        console.log(`Company phone verified ${contact._company_phone}: ${compPhoneResult.phone_status} (${compPhoneResult.phone_line_type || 'unknown'})`);
      } catch(e) {
        console.log(`Company phone PATCH error for ${companyId}: ${e.message}`);
      }
    } else if (compPhoneResult && compPhoneResult._error) {
      contact._phone_error = contact._phone_error || compPhoneResult._error;
    }
    companyEmailsSet[companyId + '_phone_verified'] = true;
    await delay(100);
  }

  // BUILD UPDATE PAYLOAD

  const update = {};
  if (contact._best_email && !contact.email_business) {
    update.email_business = contact._best_email;
  }
  if (contact._email_status && contact._email_status !== 'unverified') {
    update.email_status = contact._email_status;
    update.email_verified_at = contact._email_verified_at;
    if (contact._email_status === 'invalid') {
      update.email_business = null;
    }
  } else if (contact._best_email || contact.email_business) {
    update.email_status = 'unverified';
  }

  const newPhone = validatePhone(contact._best_phone);
  if (newPhone && !contact.phone_direct) update.phone_direct = newPhone;
  if (contact._best_linkedin && !contact.linkedin_url) update.linkedin_url = contact._best_linkedin;
  if (contact._cultural_affinity && !contact.cultural_affinity) update.cultural_affinity = contact._cultural_affinity;

  // Phone verification fields
  if (contact._phone_status) {
    update.phone_status = contact._phone_status;
    update.phone_verified_at = new Date().toISOString();
    update.phone_line_type = contact._phone_line_type;
    update.phone_carrier = contact._phone_carrier;
    if (contact._phone_status === 'invalid' || contact._phone_status === 'disconnected') {
      update.phone_direct = null;  // Remove bad numbers, keep status for audit
    }
  }

  contact._update_payload = Object.keys(update).length > 0 ? update : null;
  contact._has_updates = Object.keys(update).length > 0;

  // SUPABASE UPDATE (inline)

  if (contact._has_updates) {
    try {
      await this.helpers.httpRequest({
        method: 'PATCH',
        url: `${$env.SUPABASE_URL}/rest/v1/contacts?id=eq.${contact.id}`,
        headers: {
          'apikey': $env.SUPABASE_SERVICE_KEY,
          'Authorization': `Bearer ${$env.SUPABASE_SERVICE_KEY}`,
          'Content-Type': 'application/json',
          'Prefer': 'return=minimal'
        },
        body: update,
        json: true
      });
      console.log(`Updated ${contact.first_name} ${contact.last_name || ''}: ${JSON.stringify(update)}`);
    } catch(e) {
      console.log(`Supabase update error for ${contact.id}: ${e.message}`);
      contact._update_error = e.message;
    }
    await delay(50);
  }

  results.push({
    json: {
      _contact_id: contact.id,
      _company_id: contact.company_id,
      _first_name: contact.first_name,
      _last_name: contact.last_name,
      _company_name: contact._company_name,
      _update_payload: contact._update_payload,
      _has_updates: contact._has_updates,
      _email_source: contact._email_source,
      _email_status: contact._email_status,
      _verifier_score: contact._verifier_score,
      _namsor_country: contact._namsor_country,
      _namsor_probability: contact._namsor_probability,
      _company_email_routed: contact._company_email_routed,
      _company_email_verified: contact._company_email_verified,
      _routed_company_email: contact._routed_company_email || null,
      _phone_status: contact._phone_status,
      _phone_line_type: contact._phone_line_type,
      _phone_carrier: contact._phone_carrier,
      _company_phone_verified: contact._company_phone_verified,
      _phone_error: contact._phone_error,
      _update_error: contact._update_error || null
    }
  });
}

if (results.length === 0) {
  return [{ json: { _empty: true, _count: 0 } }];
}

return results;
===== END NODE =====

===== NODE: Filter & Merge Contacts =====
// Merge contacts with their company data and filter to those needing enrichment
// Metro-scoped: only process contacts whose company is in the current metro
const contactItems = $('Fetch Contacts').all();
const companyItems = $('Fetch Companies1').all();

// Parse contacts - deduplicate by id
let rawContacts = [];
for (const item of contactItems) {
  if (item.json && Array.isArray(item.json)) {
    rawContacts.push(...item.json);
  } else if (item.json && item.json.id) {
    rawContacts.push(item.json);
  }
}

// Deduplicate by contact id
const seenIds = new Set();
let contacts = [];
for (const c of rawContacts) {
  if (c.id && !seenIds.has(c.id)) {
    seenIds.add(c.id);
    contacts.push(c);
  }
}

// Parse companies into a lookup map (map deduplicates naturally)
// NOTE: Fetch Companies1 is now metro-scoped, so this map only contains current metro companies
let companyMap = {};
for (const item of companyItems) {
  if (Array.isArray(item.json)) {
    for (const co of item.json) {
      if (co.id) companyMap[co.id] = co;
    }
  } else if (item.json && item.json.id) {
    companyMap[item.json.id] = item.json;
  }
}

// Filter contacts that need enrichment:
// any contact where there's still something to enrich
const needsEnrichment = contacts.filter(c => {
  const missingEmail = !c.email_business;
  const missingCulturalAffinity = !c.cultural_affinity;
  const missingPhone = !c.phone_direct;
  const missingLinkedin = !c.linkedin_url;
  const verifiedStatuses = ['verified', 'invalid', 'risky', 'accept_all'];
  const emailNeedsVerification = c.email_business && !verifiedStatuses.includes(c.email_status);
  const phoneNeedsVerification = c.phone_direct && !c.phone_status;
  return missingEmail || missingCulturalAffinity || missingPhone || missingLinkedin || emailNeedsVerification || phoneNeedsVerification;
});

// Metro filter: only keep contacts whose company is in the metro-scoped companyMap
const metroFiltered = needsEnrichment.filter(c => companyMap[c.company_id]);
const crossMetroSkipped = needsEnrichment.length - metroFiltered.length;

console.log(`Contacts: ${rawContacts.length} raw, ${contacts.length} unique, ${needsEnrichment.length} need enrichment, ${crossMetroSkipped} skipped (other metro), ${metroFiltered.length} in current metro`);

if (metroFiltered.length === 0) {
  return [{ json: { _empty: true, _count: 0, _message: 'All contacts are already enriched or belong to other metros' } }];
}

// Merge company data into each contact
const merged = metroFiltered.map(c => {
  const company = companyMap[c.company_id];
  return {
    json: {
      ...c,
      _company_name: company.name || null,
      _company_domain: company.domain || null,
      _company_phone: company.phone || null,
      _company_email: company.email || null,
      _company_email_status: company.email_status || null,
      _company_phone_status: company.phone_status || null,
      _company_phone_line_type: company.phone_line_type || null,
      _company_city: company.city || null,
      _company_state: company.state || null
    }
  };
});

return merged;
===== END NODE =====

===== NODE: Run Summary1 =====
// Final summary of the enrichment batch run
const config = $('Enrichment Config').first().json;

// Collect stats from various paths
let companiesProcessed = 0;
let websitesFetched = 0;
let websiteErrors = 0;
let bookingDetected = 0;
let paidAdsDetected = 0;
let socialFromWebsite = 0;
let fbDiscovered = 0;
let igDiscovered = 0;

try {
  const batchItems = $('Parse Batch').all();
  companiesProcessed = batchItems.filter(i => !i.json._empty).length;
} catch(e) {}

try {
  const websiteItems = $('Analyze Website HTML').all();
  for (const item of websiteItems) {
    const enrichment = item.json._website_enrichment || {};
    if (enrichment._website_fetch_status === 'success') websitesFetched++;
    if (enrichment._website_fetch_status === 'error') websiteErrors++;
    if (enrichment.has_online_booking) bookingDetected++;
    if (enrichment.has_paid_ads) paidAdsDetected++;
    socialFromWebsite += (enrichment.social_links_found || []).length;
  }
} catch(e) {}

try {
  const fbResults = $('Match FB Results to Companies').first().json;
  fbDiscovered = fbResults._fb_match_count || 0;
} catch(e) {}

try {
  const igResults = $('Match IG Results to Companies').first().json;
  igDiscovered = igResults._ig_match_count || 0;
} catch(e) {}

const summary = {
  run_completed_at: new Date().toISOString(),
  batch_size: config.batch_size,
  batch_offset: config.batch_offset,
  companies_processed: companiesProcessed,
  websites_fetched_successfully: websitesFetched,
  website_fetch_errors: websiteErrors,
  booking_platforms_detected: bookingDetected,
  paid_ads_detected: paidAdsDetected,
  social_links_from_websites: socialFromWebsite,
  facebook_pages_discovered: fbDiscovered,
  instagram_profiles_discovered: igDiscovered,
  total_social_profiles_created: socialFromWebsite + fbDiscovered + igDiscovered,
  next_offset: Number(config.batch_offset) + Number(config.batch_size),
  message: `Enriched ${companiesProcessed} companies. Update batch_offset to ${Number(config.batch_offset) + Number(config.batch_size)} for next run.`
};

console.log('=== ENRICHMENT RUN SUMMARY ===');
console.log(JSON.stringify(summary, null, 2));

return [{ json: summary }];
===== END NODE =====

===== NODE: Run Summary =====
const allItems = $('Deduplicate Records').all();
const metro = $('Metro Config').first().json.metro_name;
const fromGoogle = allItems.filter(i => (i.json.source_urls || []).some(s => s.source === 'google_places')).length;
const fromYelp = allItems.filter(i => (i.json.source_urls || []).some(s => s.source === 'yelp_apify')).length;
const bothSources = allItems.filter(i => { const s = (i.json.source_urls || []).map(x => x.source); return s.includes('google_places') && s.includes('yelp_apify'); }).length;
const fuzzyFlagged = allItems.filter(i => i.json._fuzzy_match_flag).length;

const summary = {
  metro, run_timestamp: new Date().toISOString(),
  total_unique_records: allItems.length,
  found_on_google: fromGoogle, found_on_yelp: fromYelp, found_on_both: bothSources,
  flagged_for_review: fuzzyFlagged,
  clean_records: allItems.length - fuzzyFlagged,
  sources_used: ['google_places', 'yelp_apify']
};
console.log('=== DISCOVERY RUN SUMMARY ===');
console.log(JSON.stringify(summary, null, 2));
return [{ json: summary }];
===== END NODE =====

===== NODE: Skip - No Website =====
// For companies without a website, pass through with empty enrichment
// but still check domain for booking platform signals
const items = $input.all();
const results = [];

const bookingSignatures = {
  'jane_app': ['jane.app', 'janeapp.com'],
  'acuity': ['acuityscheduling.com', 'squareup.com/appointments'],
  'mindbody': ['mindbodyonline.com', 'clients.mindbodyonline.com', 'mindbody.io'],
  'square': ['square.site', 'squareup.com'],
  'vagaro': ['vagaro.com'],
  'fresha': ['fresha.com', 'shedul.com'],
  'schedulicity': ['schedulicity.com'],
  'schedulista': ['schedulista.com'],
  'booksy': ['booksy.com'],
  'massagebook': ['massagebook.com'],
  'genbook': ['genbook.com'],
  'noterro': ['noterro.com'],
  'clinicsense': ['clinicsense.com'],
  'wix_bookings': ['wix.com/booking'],
  'calendly': ['calendly.com']
};

for (const entry of items) {
  const item = entry.json;
  const domain = (item.domain || '').toLowerCase();

  let booking_platform = null;
  let has_online_booking = false;

  for (const [platform, signatures] of Object.entries(bookingSignatures)) {
    for (const sig of signatures) {
      if (domain.includes(sig)) {
        booking_platform = platform;
        has_online_booking = true;
        break;
      }
    }
    if (has_online_booking) break;
  }

  results.push({
    json: {
      ...item,
      _website_enrichment: {
        has_online_booking,
        booking_platform,
        has_paid_ads: false,
        estimated_size: null,
        social_links_found: [],
        _website_fetch_status: 'skipped_no_website'
      }
    }
  });
}

return results;
===== END NODE =====

===== NODE: Skip Google Details =====
// Companies without Google Place ID skip details fetch
const items = $input.all();
const results = [];

for (const entry of items) {
  const company = entry.json;
  results.push({
    json: {
      ...company,
      _google_details: {
        opening_hours: null,
        business_status: null,
        photo_count: 0,
        price_level: null,
        additional_types: [],
        _fetch_status: 'skipped'
      }
    }
  });
}

return results;
===== END NODE =====

===== NODE: Collapse to Single3 =====
// Collapse 3+ convergence paths (Insert Contact + About no-name + No Domain no-name) into single item
// Prevents 5-7x batch multiplication on Step 4 pre-collapse path
// Run Summary3 uses $('NodeName').all() references which resolve globally by name
return [{ json: { _trigger: 'step3a_contacts_complete' } }];
===== END NODE =====
