===== NODE: Filter & Parse Batch =====
// Get companies from upstream Fetch Companies node
const companyItems = $('Fetch Companies').all();
let companies = [];
if (companyItems.length === 1 && Array.isArray(companyItems[0].json)) {
  companies = companyItems[0].json;
} else {
  companies = companyItems.map(i => i.json);
}

// Get existing contact company_ids
const contactItems = $input.all();
let existingIds = new Set();
for (const item of contactItems) {
  if (item.json && item.json.company_id) {
    existingIds.add(item.json.company_id);
  }
  // Handle array response
  if (Array.isArray(item.json)) {
    for (const row of item.json) {
      if (row.company_id) existingIds.add(row.company_id);
    }
  }
}

// Filter out companies that already have contacts
const filtered = companies.filter(c => c.id && !existingIds.has(c.id));

console.log(`Companies: ${companies.length} total, ${existingIds.size} already have contacts, ${filtered.length} need people discovery`);

if (filtered.length === 0) {
  return [{ json: { _empty: true, _count: 0, _message: 'All companies already have contacts or no companies to process' } }];
}

return filtered.map(c => ({ json: c }));
===== END NODE =====

===== NODE: Solo Practitioner Check =====
// runOnceForAllItems — hoist name list + helper outside loop
const items = $input.all();
const results = [];

const commonFirstNames = new Set([
  'aaron','abby','abigail','adam','adrian','adriana','aiden','aimee','alana','albert',
  'alec','alexa','alexander','alexandra','alexis','alice','alicia','alina','alison','allison',
  'alyssa','amanda','amber','amelia','amy','ana','andrea','andrew','angela','angelica',
  'angie','anita','ann','anna','anne','annie','anthony','april','aria','ariana',
  'ashley','audrey','austin','autumn','ava','avery','bailey','barbara','beatrice','becky',
  'bella','ben','benjamin','beth','bethany','betty','beverly','bianca','blake','bonnie',
  'brad','bradley','brandi','brandon','brandy','breanna','brenda','brent','brett','brian',
  'briana','brianna','bridget','brittany','brittney','brooke','bruce','bryan','caitlin','caleb',
  'cameron','camila','candace','cara','carina','carl','carla','carlos','carly','carmen',
  'carol','carolina','caroline','carolyn','carrie','casey','cassandra','cassidy','catherine','cathy',
  'cecilia','celeste','celia','chad','charlene','charles','charlie','charlotte','chase','chelsea',
  'cheryl','chloe','chris','christa','christian','christina','christine','christopher','cindy','claire',
  'clara','claudia','cody','colleen','connor','constance','corey','corinne','courtney','craig',
  'crystal','cynthia','daisy','dale','dana','daniel','daniela','danielle','daphne','darlene',
  'darren','dave','david','dawn','dean','deanna','debbie','deborah','debra','denise',
  'derek','desiree','destiny','diana','diane','dianne','dolores','dominic','donna','doris',
  'dorothy','douglas','drew','dustin','dylan','eddie','edith','edward','eileen','elaine',
  'elena','elisa','elizabeth','ella','ellen','ellie','emily','emma','eric','erica',
  'erika','erin','ernest','esther','ethan','eugene','eva','evan','evelyn','faith',
  'faye','felicia','fiona','florence','frances','frank','gabriel','gabriela','gabriella','gabrielle',
  'gail','gary','gavin','genevieve','george','georgia','gerald','gina','giselle','gladys',
  'glen','glenn','gloria','grace','grant','greg','gregory','gretchen','hailey','haley',
  'hannah','harold','harriet','harry','hayden','hazel','heather','heidi','helen','henry',
  'hillary','holly','hope','howard','hunter','ian','irene','iris','isaac','isabel',
  'isabella','ivy','jack','jackie','jackson','jacob','jacqueline','jade','jaime','jake',
  'james','jamie','jan','jane','janet','janice','jared','jasmine','jason','jay',
  'jean','jeanette','jeanne','jeff','jeffrey','jenna','jennifer','jenny','jeremy','jerry',
  'jesse','jessica','jill','jillian','jim','jimmy','jo','joan','joann','joanna',
  'joanne','jocelyn','jodi','jody','joe','joel','johanna','john','johnny','jolene',
  'jon','jonathan','jordan','jorge','jose','joseph','josephine','josh','joshua','joy',
  'joyce','juan','judith','judy','julia','julian','juliana','julie','june','justin',
  'kaitlyn','kara','karen','karina','karl','kate','katelyn','katherine','kathleen','kathryn',
  'kathy','katie','katrina','kay','kayla','keith','kelley','kelli','kelly','kelsey',
  'ken','kendra','kenneth','kenny','kerry','kevin','kim','kimberly','kirsten','krista',
  'kristen','kristin','kristina','kristy','kyle','kylie','lacey','lana','lance','larry',
  'laura','lauren','laurie','leah','lee','leigh','lena','leo','leon','leslie',
  'lexy','liam','lillian','lily','linda','lindsay','lindsey','lisa','logan','lois',
  'lora','lorena','lori','lorraine','louis','louise','lucia','luis','luke','lydia',
  'lynn','mackenzie','madeline','madison','maggie','malik','mallory','mandy','marc','marcia',
  'marco','marcus','margaret','maria','mariah','marie','marilyn','marina','mario','marisa',
  'marissa','mark','marlene','marsha','martha','martin','mary','mason','matt','matthew',
  'maureen','max','maya','megan','meghan','melanie','melinda','melissa','melody','meredith',
  'mia','michael','michele','michelle','miguel','mike','mildred','mindy','miranda','misty',
  'mitchell','molly','monica','monique','morgan','mya','nadia','nancy','naomi','natalia',
  'natalie','natasha','nathan','nathaniel','neil','nelson','nicholas','nicole','nina','noah',
  'noel','nora','norma','olivia','owen','paige','pam','pamela','patricia','patrick',
  'patty','paul','paula','pauline','peggy','penny','peter','philip','phyllis','priscilla',
  'rachel','ralph','ramona','randall','randy','ray','raymond','rebecca','regina','renee',
  'rhonda','ricardo','richard','rick','ricky','riley','rita','rob','robert','roberta',
  'robin','rochelle','rodney','roger','ronald','rosa','rosalie','rose','rosemary','roxanne',
  'ruby','russell','ruth','ryan','sabrina','sally','samantha','samuel','sandra','sandy',
  'sara','sarah','savannah','scott','sean','selena','serena','seth','shana','shane',
  'shannon','sharon','shawn','sheila','shelby','shelley','shelly','sheri','sherri','sherry',
  'shirley','sierra','silvia','simone','sofia','sonia','sonya','sophia','stacey','stacy',
  'stella','stephanie','stephen','steve','steven','sue','summer','susan','suzanne','sydney',
  'sylvia','tabitha','tamara','tammy','tanya','tara','tatiana','taylor','teresa','terri',
  'terry','tess','tessa','theresa','thomas','tiffany','tim','timothy','tina','tito',
  'todd','tom','tommy','toni','tony','tonya','tracey','traci','tracy','travis',
  'tricia','trisha','troy','tyler','valerie','vanessa','vera','veronica','vicki','vicky',
  'victoria','vincent','violet','virginia','vivian','wade','walter','wanda','warren','wayne',
  'wendy','wesley','whitney','william','willie','wilma','xavier','yolanda','yvette','yvonne',
  'zachary','zoe'
]);

function isLikelyFirstName(word) {
  return commonFirstNames.has(word.toLowerCase());
}

for (const entry of items) {
  const item = entry.json;
  const name = (item.name || '').trim();
  const estimatedSize = item.estimated_size;

  let isSolo = false;
  let firstName = null;
  let lastName = null;

  // Pattern 1: "by Name" pattern - "Bodywork by Benna", "Massage by Celeste"
  const byPattern = name.match(/\bby\s+([A-Z][a-z]+)(?:\s+([A-Z][a-z]+))?/i);
  if (byPattern) {
    const candidate = byPattern[1];
    if (isLikelyFirstName(candidate) || estimatedSize === 'solo') {
      isSolo = true;
      firstName = candidate;
      lastName = byPattern[2] || null;
    }
  }

  // Pattern 2: "with Name" pattern
  if (!firstName) {
    const withPattern = name.match(/\bwith\s+([A-Z][a-z]+)(?:\s+([A-Z][a-z]+))?/i);
    if (withPattern) {
      const candidate = withPattern[1];
      if (isLikelyFirstName(candidate) || estimatedSize === 'solo') {
        isSolo = true;
        firstName = candidate;
        lastName = withPattern[2] || null;
      }
    }
  }

  // Pattern 3: Possessive - "Lexy's Massage"
  if (!firstName) {
    const possessiveMatch = name.match(/^([A-Z][a-z]+)'s\s+/i);
    if (possessiveMatch && isLikelyFirstName(possessiveMatch[1])) {
      isSolo = true;
      firstName = possessiveMatch[1];
    }
  }

  // Pattern 4: "FirstName LastName, LMT/CMT/RMT"
  if (!firstName) {
    const nameFirst = name.match(/^([A-Z][a-z]+)\s+([A-Z][a-z]+)(?:\s*[,|]\s*|\s+)(?:LMT|CMT|RMT|Licensed|Massage|Bodywork|Therapeutic|Wellness)/i);
    if (nameFirst) {
      const fn = nameFirst[1];
      const ln = nameFirst[2];
      if (isLikelyFirstName(fn) && !commonFirstNames.has(ln.toLowerCase())) {
        isSolo = true;
        firstName = fn;
        lastName = ln;
      }
    }
  }

  // Pattern 5: "FirstName LastName's Massage/Spa"
  if (!firstName) {
    const possessiveFullName = name.match(/^([A-Z][a-z]+)\s+([A-Z][a-z]+)'s\s+(?:Massage|Bodywork|Wellness|Spa|Healing)/i);
    if (possessiveFullName && isLikelyFirstName(possessiveFullName[1])) {
      isSolo = true;
      firstName = possessiveFullName[1];
      lastName = possessiveFullName[2];
    }
  }

  // Pattern 6: Three-part name with title
  if (!firstName) {
    const threePartName = name.match(/^([A-Z][a-z]+)\s+([A-Z][a-z]+)\s+([A-Z][a-z]+),?\s+(?:LMT|CMT|RMT|Licensed)/i);
    if (threePartName && isLikelyFirstName(threePartName[1])) {
      isSolo = true;
      firstName = threePartName[1];
      lastName = threePartName[3];
    }
  }

  // Pattern 7: Name embedded after comma
  if (!firstName) {
    const commaNameMatch = name.match(/,\s*([A-Z][a-z]+)\s+([A-Z][a-z]+)(?:\s*,?\s*(?:LMT|CMT|RMT|Licensed))?/i);
    if (commaNameMatch && isLikelyFirstName(commaNameMatch[1])) {
      isSolo = true;
      firstName = commaNameMatch[1];
      lastName = commaNameMatch[2];
    }
  }

  // If estimated_size is solo but no name extracted, still flag as solo
  if (estimatedSize === 'solo' && !isSolo) {
    isSolo = true;
  }

  // Reject if extracted first name matches the company's city
  if (firstName && item.city && firstName.toLowerCase() === item.city.toLowerCase()) {
    firstName = null;
    lastName = null;
  }

  results.push({
    json: {
      ...item,
      _is_solo: isSolo,
      _solo_first_name: firstName,
      _solo_last_name: lastName
    }
  });
}

return results;
===== END NODE =====

===== NODE: Prepare Solo Contact =====
const items = $input.all();
const results = [];

for (const entry of items) {
  const item = entry.json;
  results.push({
    json: {
      _contact: {
        company_id: item.id,
        first_name: item._solo_first_name || null,
        last_name: item._solo_last_name || null,
        role: 'owner',
        is_owner: true,
        email_business: null,
        email_personal: null,
        phone_direct: null,
        linkedin_url: null,
        location: [item.city, item.state].filter(Boolean).join(', ') || null,
        cultural_affinity: null,
        source: 'solo_detection'
      },
      _company_name: item.name,
      _company_id: item.id,
      _source_method: 'solo_detection',
      _has_contact: !!(item._solo_first_name)
    }
  });
}

return results;
===== END NODE =====

===== NODE: Parse Apollo Search =====
// runOnceForAllItems — index-paired with Solo Practitioner Check
const upstreamAll = $('Solo Practitioner Check').all();
const inputAll = $input.all();
const results = [];

// Hoisted keyword arrays
const ownerKeywords = ['owner', 'founder', 'ceo', 'proprietor', 'principal', 'co-founder'];
const managerKeywords = ['manager', 'director', 'general manager', 'gm', 'head'];
const practitionerKeywords = ['massage', 'therapist', 'lmt', 'cmt', 'rmt', 'bodywork', 'esthetician'];

for (let i = 0; i < inputAll.length; i++) {
  const company = upstreamAll[i].json;
  const response = inputAll[i].json;
  const people = response.people || [];

  if (!people || people.length === 0) {
    results.push({
      json: {
        ...company,
        _apollo_found: false,
        _apollo_person_id: null,
        _apollo_person_count: 0
      }
    });
    continue;
  }

  // Score people by role relevance - prefer owners/founders
  let bestPerson = null;
  let bestScore = -1;

  for (const person of people) {
    const title = (person.title || '').toLowerCase();
    let score = 0;

    if (ownerKeywords.some(k => title.includes(k))) score = 10;
    else if (managerKeywords.some(k => title.includes(k))) score = 5;
    else if (practitionerKeywords.some(k => title.includes(k))) score = 3;
    else score = 1;

    // Bonus for having email available
    if (person.has_email === true || person.has_email === 'true') score += 1;

    if (score > bestScore) {
      bestScore = score;
      bestPerson = person;
    }
  }

  console.log(`Apollo search for ${company.domain}: ${people.length} people found. Best: ${bestPerson.first_name} (${bestPerson.title || 'no title'}, score ${bestScore})`);

  results.push({
    json: {
      ...company,
      _apollo_found: true,
      _apollo_person_id: bestPerson.id,
      _apollo_first_name: bestPerson.first_name,
      _apollo_last_name_obfuscated: bestPerson.last_name_obfuscated || null,
      _apollo_title: bestPerson.title || null,
      _apollo_person_count: people.length
    }
  });
}

return results;
===== END NODE =====

===== NODE: Parse Apollo Enrich =====
// runOnceForAllItems — index-paired with Parse Apollo Search
const upstreamAll = $('Parse Apollo Search').all();
const inputAll = $input.all();
const results = [];

for (let i = 0; i < inputAll.length; i++) {
  const company = upstreamAll[i].json;
  const response = inputAll[i].json;
  const person = response.person || response.match || response;

  if (!person || !person.first_name) {
    // Enrichment failed but we still have search data
    results.push({
      json: {
        _contact: {
          company_id: company.id,
          first_name: company._apollo_first_name || null,
          last_name: null,
          role: (company._apollo_title || '').toLowerCase().includes('owner') ? 'owner' : 'unknown',
          is_owner: (company._apollo_title || '').toLowerCase().includes('owner'),
          email_business: null,
          email_personal: null,
          phone_direct: null,
          linkedin_url: null,
          location: [company.city, company.state].filter(Boolean).join(', ') || null,
          cultural_affinity: null,
          source: 'apollo'
        },
        _company_name: company.name,
        _company_id: company.id,
        _source_method: 'apollo_search_only',
        _has_contact: !!(company._apollo_first_name)
      }
    });
    continue;
  }

  // Extract phone number
  let phoneNumber = null;
  if (person.phone_numbers && person.phone_numbers.length > 0) {
    phoneNumber = person.phone_numbers[0].sanitized_number || person.phone_numbers[0].raw_number || null;
  }

  // Determine role
  const title = (person.title || '').toLowerCase();
  let role = 'unknown';
  let isOwner = false;
  if (['owner', 'founder', 'ceo', 'proprietor', 'principal', 'co-founder'].some(k => title.includes(k))) {
    role = 'owner';
    isOwner = true;
  } else if (['manager', 'director', 'gm', 'general manager'].some(k => title.includes(k))) {
    role = 'manager';
  } else if (['massage', 'therapist', 'lmt', 'cmt', 'rmt', 'esthetician'].some(k => title.includes(k))) {
    role = 'practitioner';
  }

  results.push({
    json: {
      _contact: {
        company_id: company.id,
        first_name: person.first_name || null,
        last_name: person.last_name || null,
        role: role,
        is_owner: isOwner,
        email_business: person.email || null,
        email_personal: (person.personal_emails && person.personal_emails[0]) || null,
        phone_direct: phoneNumber,
        linkedin_url: person.linkedin_url || null,
        location: [person.city, person.state].filter(Boolean).join(', ') || [company.city, company.state].filter(Boolean).join(', ') || null,
        cultural_affinity: null,
        source: 'apollo'
      },
      _company_name: company.name,
      _company_id: company.id,
      _source_method: 'apollo_enriched',
      _has_contact: true
    }
  });
}

return results;
===== END NODE =====

===== NODE: Apollo Search Only Contact =====
// Apollo search found someone but enrichment is disabled - use search-only data
const items = $input.all();
const results = [];

for (const entry of items) {
  const item = entry.json;
  results.push({
    json: {
      _contact: {
        company_id: item.id,
        first_name: item._apollo_first_name || null,
        last_name: null,
        role: (item._apollo_title || '').toLowerCase().includes('owner') ? 'owner' : 'unknown',
        is_owner: (item._apollo_title || '').toLowerCase().includes('owner'),
        email_business: null,
        email_personal: null,
        phone_direct: null,
        linkedin_url: null,
        location: [item.city, item.state].filter(Boolean).join(', ') || null,
        cultural_affinity: null,
        source: 'apollo'
      },
      _company_name: item.name,
      _company_id: item.id,
      _source_method: 'apollo_search_only',
      _has_contact: !!(item._apollo_first_name)
    }
  });
}

return results;
===== END NODE =====

===== NODE: Parse About Page =====
// runOnceForAllItems — index-paired with Solo Practitioner Check
// Has async this.helpers.httpRequest() inside loop (required per-item)
const upstreamAll = $('Solo Practitioner Check').all();
const inputAll = $input.all();
const results = [];

const additionalPaths = ['/about-us', '/about-me', '/our-team', '/team', '/our-story'];

const commonFirstNames = new Set([
  'aaron','abby','abigail','adam','adrian','adriana','aiden','aimee','alana','albert',
  'alexa','alexander','alexandra','alexis','alice','alicia','alison','allison','amanda','amber',
  'amelia','amy','ana','andrea','andrew','angela','angelica','angie','anita','ann',
  'anna','anne','annie','anthony','april','aria','ariana','ashley','audrey','ava',
  'avery','bailey','barbara','becky','bella','ben','benjamin','beth','bethany','betty',
  'beverly','bianca','blake','bonnie','brad','bradley','brandi','brandon','brandy','brenda',
  'brent','brian','brianna','bridget','brittany','brooke','bruce','bryan','caitlin','caleb',
  'cameron','candace','cara','carl','carla','carlos','carly','carmen','carol','caroline',
  'carolyn','carrie','casey','cassandra','catherine','cathy','celeste','chad','charlene','charles',
  'charlotte','chelsea','cheryl','chloe','chris','christina','christine','christopher','cindy','claire',
  'clara','claudia','colleen','connor','courtney','craig','crystal','cynthia','daisy','dale',
  'dana','daniel','daniela','danielle','darlene','dave','david','dawn','dean','deanna',
  'debbie','deborah','debra','denise','derek','desiree','diana','diane','dolores','donna',
  'doris','dorothy','douglas','drew','dustin','dylan','eddie','edward','eileen','elaine',
  'elena','elizabeth','ella','ellen','emily','emma','eric','erica','erika','erin',
  'esther','ethan','eva','evelyn','faith','felicia','fiona','florence','frances','frank',
  'gabriel','gabriela','gabrielle','gail','gary','george','georgia','gerald','gina','glen',
  'glenn','gloria','grace','greg','gregory','hailey','haley','hannah','harold','harry',
  'hazel','heather','heidi','helen','henry','holly','hope','howard','hunter','ian',
  'irene','iris','isaac','isabel','isabella','ivy','jack','jackie','jacob','jacqueline',
  'jade','jaime','jake','james','jamie','jane','janet','janice','jared','jasmine',
  'jason','jay','jean','jeff','jeffrey','jenna','jennifer','jenny','jeremy','jerry',
  'jesse','jessica','jill','jim','jimmy','joan','joanna','joanne','jocelyn','jodi',
  'joe','joel','john','johnny','jon','jonathan','jordan','jose','joseph','josh',
  'joshua','joy','joyce','judith','judy','julia','julie','june','justin','kaitlyn',
  'kara','karen','karina','kate','katelyn','katherine','kathleen','kathryn','kathy','katie',
  'katrina','kay','kayla','keith','kelly','kelsey','ken','kendra','kenneth','kevin',
  'kim','kimberly','kirsten','krista','kristen','kristin','kristina','kristy','kyle','kylie',
  'lacey','lana','lance','larry','laura','lauren','laurie','leah','lee','leigh',
  'lena','leon','leslie','lexy','liam','lillian','lily','linda','lindsay','lindsey',
  'lisa','logan','lois','lori','lorraine','louis','louise','lucia','luis','luke',
  'lydia','lynn','mackenzie','madeline','madison','maggie','mallory','mandy','marc','marcia',
  'marcus','margaret','maria','marie','marilyn','marina','mario','marisa','mark','marlene',
  'martha','martin','mary','matt','matthew','maureen','max','maya','megan','meghan',
  'melanie','melinda','melissa','melody','meredith','mia','michael','michele','michelle','miguel',
  'mike','mildred','mindy','miranda','misty','molly','monica','monique','morgan','nadia',
  'nancy','naomi','natalia','natalie','natasha','nathan','nicholas','nicole','nina','noah',
  'nora','norma','olivia','owen','paige','pamela','patricia','patrick','paul','paula',
  'peggy','penny','peter','philip','phyllis','priscilla','rachel','ralph','randy','ray',
  'raymond','rebecca','regina','renee','rhonda','richard','rick','riley','rita','robert',
  'roberta','robin','rodney','roger','ronald','rosa','rose','rosemary','ruby','russell',
  'ruth','ryan','sabrina','sally','samantha','samuel','sandra','sandy','sara','sarah',
  'savannah','scott','sean','selena','serena','seth','shannon','sharon','shawn','sheila',
  'shelby','shelly','sheri','sherry','shirley','sierra','simone','sofia','sonia','sophia',
  'stacey','stacy','stella','stephanie','stephen','steve','steven','sue','summer','susan',
  'suzanne','sydney','sylvia','tamara','tammy','tanya','tara','tatiana','taylor','teresa',
  'terri','terry','tessa','theresa','thomas','tiffany','timothy','tina','tito','todd',
  'tom','toni','tony','tonya','tracey','tracy','travis','tricia','troy','tyler',
  'valerie','vanessa','vera','veronica','vicki','victoria','vincent','violet','virginia','vivian',
  'walter','wanda','wayne','wendy','wesley','whitney','william','willie','wilma','xavier',
  'yolanda','yvette','yvonne','zachary','zoe'
]);

function isLikelyFirstName(word) {
  return commonFirstNames.has((word || '').toLowerCase());
}

function extractName(html) {
  if (!html || html.length < 100) return null;
  const textOnly = html.replace(/<[^>]+>/g, ' ').replace(/\s+/g, ' ');

  const patterns = [
    /(?:owner|owned\s+by|founded\s+by|proprietor)[:\s]+([A-Z][a-z]+)\s+([A-Z][a-z]+)/i,
    /(?:hi,?\s+i'?m|hello,?\s+i'?m|my\s+name\s+is|i\s+am)\s+([A-Z][a-z]+)\s+([A-Z][a-z]+)/i,
    /(?:^|\s)about\s+([A-Z][a-z]+)\s+([A-Z][a-z]+)(?:\s*[,|]|\s+(?:LMT|CMT|RMT|Licensed))/i,
    /(?:^|\s)meet\s+([A-Z][a-z]+)\s+([A-Z][a-z]+)(?:\s*[,|]|\s+(?:LMT|CMT|RMT|Licensed|is\s+a|has\s+been))/i,
    /([A-Z][a-z]+)\s+([A-Z][a-z]+),?\s+(?:LMT|CMT|RMT|Licensed\s+Massage)/i
  ];

  for (const pattern of patterns) {
    for (const source of [textOnly, html]) {
      const match = source.match(pattern);
      if (match) {
        const fn = match[1];
        const ln = match[2];
        if (isLikelyFirstName(fn) &&
            fn.length >= 2 && fn.length <= 20 &&
            ln.length >= 2 && ln.length <= 20) {
          return { firstName: fn, lastName: ln };
        }
      }
    }
  }
  return null;
}

for (let i = 0; i < inputAll.length; i++) {
  const company = upstreamAll[i].json;
  const response = inputAll[i].json;

  // Step 1: Check the upstream /about response
  let bestHtml = '';
  let usedPath = '/about';
  const rawHtml = response.body || response.data || '';
  if (typeof rawHtml === 'string' && rawHtml.length > 500) {
    bestHtml = rawHtml;
  }

  // Step 2: Try to extract name from /about
  let nameResult = bestHtml ? extractName(bestHtml) : null;

  // Step 3: If /about didn't yield a name, try additional paths
  if (!nameResult && company.domain) {
    for (const path of additionalPaths) {
      try {
        const resp = await this.helpers.httpRequest({
          method: 'GET',
          url: `https://${company.domain}${path}`,
          headers: { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36' },
          returnFullResponse: true,
          timeout: 10000,
          json: false,
        });
        const html = resp.body || '';
        if (typeof html === 'string' && html.length > 500) {
          const found = extractName(html);
          if (found) {
            nameResult = found;
            usedPath = path;
            console.log(`Found name on ${path}: ${found.firstName} ${found.lastName}`);
            break;
          }
        }
      } catch(e) {
        // Path doesn't exist or timed out — try next
      }
    }
  }

  const hasContact = !!(nameResult);

  results.push({
    json: {
      _contact: hasContact ? {
        company_id: company.id,
        first_name: nameResult.firstName,
        last_name: nameResult.lastName,
        role: 'owner',
        is_owner: true,
        email_business: null,
        email_personal: null,
        phone_direct: null,
        linkedin_url: null,
        location: [company.city, company.state].filter(Boolean).join(', ') || null,
        cultural_affinity: null,
        source: 'website'
      } : null,
      _company_name: company.name,
      _company_id: company.id,
      _source_method: hasContact ? `website_scrape_${usedPath.replace('/', '')}` : 'website_scrape',
      _has_contact: hasContact
    }
  });
}

return results;
===== END NODE =====

===== NODE: No Domain Fallback =====
// runOnceForAllItems — hoist name list + helper outside loop
const items = $input.all();
const results = [];

const commonFirstNames = new Set([
  'aaron','abby','abigail','adam','adrian','adriana','aiden','aimee','alana','albert',
  'alexa','alexander','alexandra','alexis','alice','alicia','alison','allison','amanda','amber',
  'amelia','amy','ana','andrea','andrew','angela','angelica','angie','anita','ann',
  'anna','anne','annie','anthony','april','aria','ariana','ashley','audrey','ava',
  'avery','bailey','barbara','becky','bella','ben','benjamin','beth','bethany','betty',
  'beverly','bianca','blake','bonnie','brad','bradley','brandi','brandon','brandy','brenda',
  'brent','brian','brianna','bridget','brittany','brooke','bruce','bryan','caitlin','caleb',
  'cameron','candace','cara','carl','carla','carlos','carly','carmen','carol','caroline',
  'carolyn','carrie','casey','cassandra','catherine','cathy','celeste','chad','charlene','charles',
  'charlotte','chelsea','cheryl','chloe','chris','christina','christine','christopher','cindy','claire',
  'clara','claudia','colleen','connor','courtney','craig','crystal','cynthia','daisy','dale',
  'dana','daniel','daniela','danielle','darlene','dave','david','dawn','dean','deanna',
  'debbie','deborah','debra','denise','derek','desiree','diana','diane','dolores','donna',
  'doris','dorothy','douglas','drew','dustin','dylan','eddie','edward','eileen','elaine',
  'elena','elizabeth','ella','ellen','emily','emma','eric','erica','erika','erin',
  'esther','ethan','eva','evelyn','faith','felicia','fiona','florence','frances','frank',
  'gabriel','gabriela','gabrielle','gail','gary','george','georgia','gerald','gina','glen',
  'glenn','gloria','grace','greg','gregory','hailey','haley','hannah','harold','harry',
  'hazel','heather','heidi','helen','henry','holly','hope','howard','hunter','ian',
  'irene','iris','isaac','isabel','isabella','ivy','jack','jackie','jacob','jacqueline',
  'jade','jaime','jake','james','jamie','jane','janet','janice','jared','jasmine',
  'jason','jay','jean','jeff','jeffrey','jenna','jennifer','jenny','jeremy','jerry',
  'jesse','jessica','jill','jim','jimmy','joan','joanna','joanne','jocelyn','jodi',
  'joe','joel','john','johnny','jon','jonathan','jordan','jose','joseph','josh',
  'joshua','joy','joyce','judith','judy','julia','julie','june','justin','kaitlyn',
  'kara','karen','karina','kate','katelyn','katherine','kathleen','kathryn','kathy','katie',
  'katrina','kay','kayla','keith','kelly','kelsey','ken','kendra','kenneth','kevin',
  'kim','kimberly','kirsten','krista','kristen','kristin','kristina','kristy','kyle','kylie',
  'lacey','lana','lance','larry','laura','lauren','laurie','leah','lee','leigh',
  'lena','leon','leslie','lexy','liam','lillian','lily','linda','lindsay','lindsey',
  'lisa','logan','lois','lori','lorraine','louis','louise','lucia','luis','luke',
  'lydia','lynn','mackenzie','madeline','madison','maggie','mallory','mandy','marc','marcia',
  'marcus','margaret','maria','marie','marilyn','marina','mario','marisa','mark','marlene',
  'martha','martin','mary','matt','matthew','maureen','max','maya','megan','meghan',
  'melanie','melinda','melissa','melody','meredith','mia','michael','michele','michelle','miguel',
  'mike','mildred','mindy','miranda','misty','molly','monica','monique','morgan','nadia',
  'nancy','naomi','natalia','natalie','natasha','nathan','nicholas','nicole','nina','noah',
  'nora','norma','olivia','owen','paige','pamela','patricia','patrick','paul','paula',
  'peggy','penny','peter','philip','phyllis','priscilla','rachel','ralph','randy','ray',
  'raymond','rebecca','regina','renee','rhonda','richard','rick','riley','rita','robert',
  'roberta','robin','rodney','roger','ronald','rosa','rose','rosemary','ruby','russell',
  'ruth','ryan','sabrina','sally','samantha','samuel','sandra','sandy','sara','sarah',
  'savannah','scott','sean','selena','serena','seth','shannon','sharon','shawn','sheila',
  'shelby','shelly','sheri','sherry','shirley','sierra','simone','sofia','sonia','sophia',
  'stacey','stacy','stella','stephanie','stephen','steve','steven','sue','summer','susan',
  'suzanne','sydney','sylvia','tamara','tammy','tanya','tara','tatiana','taylor','teresa',
  'terri','terry','tessa','theresa','thomas','tiffany','timothy','tina','tito','todd',
  'tom','toni','tony','tonya','tracey','tracy','travis','tricia','troy','tyler',
  'valerie','vanessa','vera','veronica','vicki','victoria','vincent','violet','virginia','vivian',
  'walter','wanda','wayne','wendy','wesley','whitney','william','willie','wilma','xavier',
  'yolanda','yvette','yvonne','zachary','zoe'
]);

function isLikelyFirstName(word) {
  return commonFirstNames.has(word.toLowerCase());
}

for (const entry of items) {
  const item = entry.json;
  const name = (item.name || '').trim();

  let firstName = null;
  let lastName = null;

  // Pattern 1: "by Name"
  const byPattern = name.match(/\bby\s+([A-Z][a-z]+)(?:\s+([A-Z][a-z]+))?/i);
  if (byPattern && isLikelyFirstName(byPattern[1])) {
    firstName = byPattern[1];
    lastName = byPattern[2] || null;
  }

  // Pattern 2: "with Name"
  if (!firstName) {
    const withPattern = name.match(/\bwith\s+([A-Z][a-z]+)(?:\s+([A-Z][a-z]+))?/i);
    if (withPattern && isLikelyFirstName(withPattern[1])) {
      firstName = withPattern[1];
      lastName = withPattern[2] || null;
    }
  }

  // Pattern 3: Possessive
  if (!firstName) {
    const possessive = name.match(/^([A-Z][a-z]+)'s\s+/i);
    if (possessive && isLikelyFirstName(possessive[1])) {
      firstName = possessive[1];
    }
  }

  // Pattern 4: "FirstName LastName, LMT"
  if (!firstName) {
    const credMatch = name.match(/^([A-Z][a-z]+)\s+([A-Z][a-z]+)(?:\s*,?\s*(?:LMT|CMT|RMT|Licensed))/i);
    if (credMatch && isLikelyFirstName(credMatch[1])) {
      firstName = credMatch[1];
      lastName = credMatch[2];
    }
  }

  // Pattern 5: Name after comma
  if (!firstName) {
    const commaMatch = name.match(/,\s*([A-Z][a-z]+)\s+([A-Z][a-z]+)/i);
    if (commaMatch && isLikelyFirstName(commaMatch[1])) {
      firstName = commaMatch[1];
      lastName = commaMatch[2];
    }
  }

  // Pattern 6: Validated first+last before business keyword
  if (!firstName) {
    const nameKeyword = name.match(/^([A-Z][a-z]+)\s+([A-Z][a-z]+)\s+(?:Massage|Bodywork|Therapeutic|Wellness|Healing|Spa)/i);
    if (nameKeyword && isLikelyFirstName(nameKeyword[1]) && !isLikelyFirstName(nameKeyword[2])) {
      firstName = nameKeyword[1];
      lastName = nameKeyword[2];
    }
  }

  const hasContact = !!(firstName);

  results.push({
    json: {
      _contact: hasContact ? {
        company_id: item.id,
        first_name: firstName,
        last_name: lastName,
        role: 'owner',
        is_owner: true,
        email_business: null,
        email_personal: null,
        phone_direct: null,
        linkedin_url: null,
        location: [item.city, item.state].filter(Boolean).join(', ') || null,
        cultural_affinity: null,
        source: 'manual'
      } : null,
      _company_name: item.name,
      _company_id: item.id,
      _source_method: 'no_domain_name_extraction',
      _has_contact: hasContact
    }
  });
}

return results;
===== END NODE =====

===== NODE: Validate & Clean Contact =====
// Validate & Clean Contact — runOnceForAllItems
// Cleans emails, phones, names, LinkedIn URLs before Supabase insert.
// Nulls out invalid data rather than blocking the insert.
// Adds _validation_flags array for audit trail.

const items = $input.all();
const results = [];

// Helper functions accept flags array as parameter (not closure)
function validateEmail(email, fieldName, flags) {
  if (!email) return null;
  let cleaned = email.trim().toLowerCase();
  const emailRegex = /^[a-zA-Z0-9._%+\-]+@[a-zA-Z0-9.\-]+\.[a-zA-Z]{2,}$/;
  if (!emailRegex.test(cleaned)) {
    flags.push(`${fieldName}_invalid_format: "${email}"`);
    return null;
  }
  const junkPatterns = [
    /^noreply@/, /^no-reply@/, /^donotreply@/, /^do-not-reply@/,
    /^test@/, /^admin@example\./, /^info@example\./, /^user@example\./,
    /^sample@/, /^fake@/, /^placeholder@/, /^null@/, /^none@/, /^na@/,
    /^n\/a@/, /^unknown@/, /^abuse@/, /^postmaster@/, /^mailer-daemon@/
  ];
  if (junkPatterns.some(p => p.test(cleaned))) {
    flags.push(`${fieldName}_junk_pattern: "${cleaned}"`);
    return null;
  }
  const rolePatterns = [
    /^info@/, /^contact@/, /^hello@/, /^support@/, /^sales@/, /^office@/,
    /^billing@/, /^reception@/, /^frontdesk@/, /^front\.desk@/,
    /^appointments@/, /^booking@/, /^bookings@/, /^schedule@/,
    /^scheduling@/, /^inquiries@/, /^inquiry@/, /^general@/, /^team@/, /^staff@/
  ];
  if (rolePatterns.some(p => p.test(cleaned))) {
    flags.push(`${fieldName}_role_based_kept: "${cleaned}"`);
  }
  const junkDomains = [
    'example.com', 'example.org', 'example.net', 'test.com', 'test.org',
    'placeholder.com', 'fake.com', 'noemail.com', 'nomail.com', 'none.com',
    'localhost', 'mailinator.com', 'guerrillamail.com', 'tempmail.com',
    'throwaway.email', 'yopmail.com'
  ];
  const domain = cleaned.split('@')[1];
  if (junkDomains.includes(domain)) {
    flags.push(`${fieldName}_junk_domain: "${domain}"`);
    return null;
  }
  const localPart = cleaned.split('@')[0];
  if (/^\d+$/.test(localPart)) {
    flags.push(`${fieldName}_numeric_local: "${cleaned}"`);
    return null;
  }
  if (localPart.startsWith('.') || localPart.endsWith('.') || localPart.includes('..')) {
    flags.push(`${fieldName}_malformed_local: "${cleaned}"`);
    return null;
  }
  return cleaned;
}

function validatePhone(phone, fieldName, flags) {
  if (!phone) return null;
  if (typeof phone === 'object' && phone !== null) {
    phone = phone.sanitized_number || phone.raw_number || phone.number || '';
  }
  let cleaned = phone.toString().trim();
  cleaned = cleaned.replace(/[^\d]/g, '');
  if (!cleaned || cleaned.length === 0) {
    flags.push(`${fieldName}_empty_after_strip`);
    return null;
  }
  if (cleaned.length === 11 && cleaned.startsWith('1')) {
    // already has country code
  } else if (cleaned.length === 10) {
    cleaned = '1' + cleaned;
  } else if (cleaned.length < 10) {
    flags.push(`${fieldName}_too_short: "${phone}" (${cleaned.length} digits)`);
    return null;
  } else if (cleaned.length > 11) {
    flags.push(`${fieldName}_possibly_international: "${phone}" (${cleaned.length} digits)`);
    return '+' + cleaned;
  }
  const areaCode = cleaned.substring(1, 4);
  if (areaCode.startsWith('0') || areaCode.startsWith('1')) {
    flags.push(`${fieldName}_invalid_area_code: "${areaCode}"`);
    return null;
  }
  return '+' + cleaned;
}

function cleanName(name, fieldName, flags) {
  if (!name) return null;
  let cleaned = name.trim();
  cleaned = cleaned.replace(/\*+$/, '').trim();
  if (cleaned.length <= 1) {
    flags.push(`${fieldName}_too_short: "${name}"`);
    return null;
  }
  if (/^\d+$/.test(cleaned)) {
    flags.push(`${fieldName}_numeric: "${name}"`);
    return null;
  }
  if (/\d/.test(cleaned)) {
    flags.push(`${fieldName}_contains_digits: "${name}"`);
    return null;
  }
  const junkNames = [
    'unknown', 'n/a', 'na', 'none', 'null', 'test',
    'owner', 'manager', 'admin', 'info', 'contact'
  ];
  if (junkNames.includes(cleaned.toLowerCase())) {
    flags.push(`${fieldName}_junk_name: "${name}"`);
    return null;
  }
  const credentials = [
    'lmt', 'cmt', 'rmt', 'lmbt', 'lmp', 'bctmb', 'nctmb', 'nctm',
    'cpt', 'cst', 'mld', 'nmt', 'amt', 'abmp'
  ];
  if (credentials.includes(cleaned.toLowerCase())) {
    flags.push(`${fieldName}_credential_not_name: "${name}"`);
    return null;
  }
  if (cleaned === cleaned.toUpperCase() || cleaned === cleaned.toLowerCase()) {
    cleaned = cleaned.charAt(0).toUpperCase() + cleaned.slice(1).toLowerCase();
  }
  return cleaned;
}

function validateLinkedIn(url, flags) {
  if (!url) return null;
  let cleaned = url.trim();
  if (!/linkedin\.com\/in\//i.test(cleaned)) {
    if (/linkedin\.com/i.test(cleaned)) {
      flags.push(`linkedin_not_personal_profile: "${cleaned}"`);
    } else {
      flags.push(`linkedin_invalid_url: "${cleaned}"`);
    }
    return null;
  }
  if (!cleaned.startsWith('http')) {
    cleaned = 'https://' + cleaned;
  }
  cleaned = cleaned.replace(/^http:\/\//, 'https://');
  return cleaned;
}

for (const entry of items) {
  const item = entry.json;
  const contact = item._contact;
  const flags = [];

  if (!contact) {
    results.push({ json: { ...item, _validation_flags: ['no_contact_object'] } });
    continue;
  }

  contact.email_business = validateEmail(contact.email_business, 'email_business', flags);
  contact.email_personal = validateEmail(contact.email_personal, 'email_personal', flags);
  contact.phone_direct = validatePhone(contact.phone_direct, 'phone_direct', flags);
  contact.first_name = cleanName(contact.first_name, 'first_name', flags);
  contact.last_name = cleanName(contact.last_name, 'last_name', flags);

  if (!contact.first_name) {
    flags.push('contact_has_no_valid_first_name');
  }

  contact.linkedin_url = validateLinkedIn(contact.linkedin_url, flags);

  if (contact.location) {
    contact.location = contact.location.trim();
    if (!contact.location || contact.location === ',' || contact.location.length < 2) {
      contact.location = null;
      flags.push('location_empty_after_clean');
    }
  }

  const hasValidContact = !!(contact.first_name);

  if (flags.length > 0) {
    console.log(`Validation [${item._company_name}] (${item._source_method}): ${flags.join(', ')}`);
  }

  results.push({
    json: {
      _contact: contact,
      _company_name: item._company_name,
      _company_id: item._company_id,
      _source_method: item._source_method,
      _has_contact: hasValidContact,
      _validation_flags: flags
    }
  });
}

return results;
===== END NODE =====

===== NODE: Collapse to Single1 =====
// Collapse 7 convergence paths into single item to prevent Task Runner crash loop
// Run Summary1 uses $('NodeName').all() references which resolve globally by name
// ADR-024: Suppress redundant convergence batches — only fire once per execution
const staticData = $getWorkflowStaticData('global');
if (staticData._collapse1_fired) {
  return [];
}
staticData._collapse1_fired = true;
return [{ json: { _trigger: 'social_processing_complete' } }];
===== END NODE =====

===== NODE: Collapse to Single3 =====
// Collapse 3+ convergence paths (Insert Contact + About no-name + No Domain no-name) into single item
// Prevents 5-7x batch multiplication on Step 4 pre-collapse path
// Run Summary3 uses $('NodeName').all() references which resolve globally by name
return [{ json: { _trigger: 'step3a_contacts_complete' } }];
===== END NODE =====
