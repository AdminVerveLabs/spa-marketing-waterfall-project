{
  "nodes": [
    {
      "parameters": {
        "jsCode": "const response = $input.first().json;\nconst prevData = $('Extract Run ID').first().json;\n\nlet status = 'UNKNOWN';\nlet datasetId = prevData.datasetId || '';\n\n// Single run response\nif (response.data && response.data.status && !response.data.items) {\n  status = response.data.status;\n  if (response.data.defaultDatasetId) datasetId = response.data.defaultDatasetId;\n}\n// List response\nelse if (response.data && response.data.items && response.data.items.length > 0) {\n  status = response.data.items[0].status;\n  if (response.data.items[0].defaultDatasetId) datasetId = response.data.items[0].defaultDatasetId;\n}\n\n// Increment poll count from previous Parse Status if looping, otherwise from Extract Run ID\nlet pollCount = 0;\ntry {\n  pollCount = $('Parse Status').first().json.pollCount || 0;\n} catch(e) {\n  pollCount = prevData.pollCount || 0;\n}\npollCount++;\n\nreturn [{ json: { runId: prevData.runId, datasetId, pollCount, status } }];"
      },
      "id": "d7861f94-bfc5-4f69-9f11-b82f2815ba8c",
      "name": "Parse Status",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -9616,
        224
      ]
    },
    {
      "parameters": {
        "url": "=https://api.apify.com/v2/actor-runs/{{ $('Extract Run ID').first().json.runId }}?token={{ $env.APIFY_API_TOKEN }}",
        "options": {
          "timeout": 15000
        }
      },
      "id": "6ce308da-fda1-430e-a1ed-ef0605941bcd",
      "name": "Check Run Status",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -9840,
        224
      ],
      "alwaysOutputData": true,
      "onError": "continueRegularOutput"
    },
    {
      "id": "a1b2c3d4-lead-score-summary-02",
      "name": "Run Summary5",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -4600,
        192
      ],
      "parameters": {
        "jsCode": "// Step 5: Lead Scoring Summary\nconst input = $input.first().json;\n\n// Check if the RPC call succeeded\n// Supabase RPC for void functions returns empty string or null on success\nconst rpcFailed = input.error || input.message || (typeof input === 'object' && input.code);\n\nconst summary = {\n  run_completed_at: new Date().toISOString(),\n  step: 'Step 5: Lead Scoring',\n  scoring_status: rpcFailed ? 'FAILED' : 'SUCCESS',\n  rpc_response: rpcFailed ? JSON.stringify(input) : 'calculate_lead_scores() executed successfully',\n  message: rpcFailed\n    ? `Lead scoring FAILED: ${JSON.stringify(input)}. Scores not updated \u2014 pipeline still completed.`\n    : 'Lead scoring complete. All company lead_score values recalculated from scoring_rules table.'\n};\n\nconsole.log('=== STEP 5: LEAD SCORING SUMMARY ===');\nconsole.log(JSON.stringify(summary, null, 2));\n\nreturn [{ json: summary }];"
      },
      "notes": "Logs whether the lead scoring RPC call succeeded or failed."
    },
    {
      "parameters": {
        "jsCode": "const response = $input.first().json;\nlet runId = '';\nlet datasetId = '';\n\nif (response.data) {\n  runId = response.data.id || '';\n  datasetId = response.data.defaultDatasetId || '';\n}\n\nif (!runId) {\n  throw new Error('Failed to start Apify run. Response: ' + JSON.stringify(response).substring(0, 500));\n}\n\nreturn [{ json: { runId, datasetId, pollCount: 0 } }];"
      },
      "id": "ca8aee6f-7b5b-40b6-8d16-3902dceea5c6",
      "name": "Extract Run ID",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -10288,
        288
      ]
    },
    {
      "parameters": {
        "jsCode": "const metro = $('Metro Config').first().json.metro_name;\nconst query = $('Split Search Queries').first().json.query || '';\nconst results = [];\n\n// Booking platform domain blocklist\nconst BLOCKED_DOMAINS = ['wixsite.com','wix.com','setmore.com','schedulista.com','glossgenius.com','square.site','genbook.com','jane.app','acuityscheduling.com','mindbodyonline.com','mindbody.io','vagaro.com','fresha.com','schedulicity.com','booksy.com','massagebook.com','noterro.com','clinicsense.com','calendly.com','squarespace.com'];\n// Business type blocklist - filter non-target businesses before Supabase insert\nconst BUSINESS_TYPE_BLOCKLIST = ['school','college','university','association','federation','union','board of','institute','academy','program'];\n\n\nfor (const item of items) {\n  const biz = item.json;\n  if (!biz.name) continue;\n\n  // Business type filter - skip non-target businesses\n  const _bizNameLower = biz.name.toLowerCase();\n  const _bizCatLower = ((biz.categories || []).join(', ')).toLowerCase();\n  if (BUSINESS_TYPE_BLOCKLIST.some(kw => _bizNameLower.includes(kw) || _bizCatLower.includes(kw))) continue;\n\n  let phone = (biz.phone || '').replace(/[^\\d+]/g, '');\n  if (phone && !phone.startsWith('+')) {\n    phone = '+1' + phone.replace(/^1/, '');\n  }\n\n  let domain = '';\n  if (biz.website) {\n    try {\n      domain = new URL(biz.website.startsWith('http') ? biz.website : 'https://' + biz.website)\n        .hostname.replace(/^www\\./, '');\n    } catch(e) {}\n  }\n\n  // Check domain against blocklist\n  let _domain_blocked = false;\n  let _domain_blocked_platform = '';\n  if (domain) {\n    const lowerDomain = domain.toLowerCase();\n    for (const blocked of BLOCKED_DOMAINS) {\n      if (lowerDomain === blocked || lowerDomain.endsWith('.' + blocked)) {\n        _domain_blocked = true;\n        _domain_blocked_platform = blocked;\n        domain = '';\n        break;\n      }\n    }\n  }\n\n  const addr = biz.address || {};\n  const fullAddress = [addr.addressLine1, addr.addressLine2, addr.addressLine3]\n    .filter(Boolean).join(', ');\n\n  results.push({\n    json: {\n      name: biz.name,\n      phone: phone,\n      domain: domain,\n      address: fullAddress,\n      city: addr.city || '',\n      state: addr.regionCode || '',\n      country: addr.country || 'US',\n      google_place_id: '',\n      category: (biz.categories || []).join(', '),\n      google_rating: null,\n      google_review_count: 0,\n      yelp_rating: biz.aggregatedRating || null,\n      yelp_review_count: biz.reviewCount || 0,\n      has_website: _domain_blocked ? false : !!biz.website,\n      yelp_url: biz.directUrl || '',\n      yelp_is_claimed: biz.claimed || false,\n      yelp_is_advertiser: biz.advertiser || false,\n      source_urls: [{source: 'yelp_apify', url: biz.directUrl || '', query_used: query}],\n      discovery_metro: metro,\n      discovery_source: 'yelp_apify',\n      _domain_blocked,\n      _domain_blocked_platform\n    }\n  });\n}\n\nreturn results.length > 0 ? results : [{ json: { _empty: true } }];"
      },
      "id": "ca715d3a-ef73-4e5b-82cc-2f181555ee2a",
      "name": "Normalize Yelp Results",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -8944,
        288
      ],
      "notes": "After testing, change $('Test Input (Remove After Testing)') to $('Metro Config') and $('Split Search Queries')."
    },
    {
      "id": "a1b2c3d4-lead-score-http-0001",
      "name": "Calculate Lead Scores",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -5100,
        192
      ],
      "parameters": {
        "method": "POST",
        "url": "={{ $env.SUPABASE_URL }}/rest/v1/rpc/calculate_lead_scores",
        "authentication": "none",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "apikey",
              "value": "={{ $env.SUPABASE_SERVICE_KEY }}"
            },
            {
              "name": "Authorization",
              "value": "=Bearer {{ $env.SUPABASE_SERVICE_KEY }}"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "{}",
        "options": {
          "response": {
            "response": {
              "neverError": true
            }
          }
        }
      },
      "notes": "Step 5: Call Supabase RPC to recalculate all lead scores based on scoring_rules table."
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://api.apify.com/v2/actor-tasks/uplifted_veranda~yelp-scraper-task/runs?token={{ $env.APIFY_API_TOKEN }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"searchTerms\": [\"{{ $json.query }}\"],\n  \"locations\": [\"{{ $json.yelp_location }}\"],\n  \"searchLimit\": 100,\n  \"maxImages\": 0,\n  \"reviewLimit\": 0\n}",
        "options": {
          "timeout": 30000
        }
      },
      "id": "b0bba0ff-f1a6-4e25-bdea-6002b7ed869c",
      "name": "Start Apify Run",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -10512,
        288
      ],
      "alwaysOutputData": true,
      "onError": "continueRegularOutput",
      "notes": "Starts the Apify task. Returns run object with data.id for polling."
    },
    {
      "id": "a1b2c3d4-collapse-summary2-01",
      "name": "Collapse to Single2",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -7712,
        192
      ],
      "parameters": {
        "jsCode": "// Collapse 2 convergence paths (Insert + Insert Flagged) into single item\n// ADR-024: Fire once per execution (suppress secondary batches)\n// ADR-025: Wait for all Step 1 inserts to complete before triggering Step 2\n// Google results arrive in ~5s, Yelp/Apify takes 60-120s.\n// Poll discovered count until stable, then fire.\n// BUG-028: Require count > 0 to prevent race condition where Insert to Supabase\n// hasn't committed yet. Max iterations raised from 10 to 30 (450s max).\nconst staticData = $getWorkflowStaticData('global');\nif (staticData._collapse2_fired) {\n  return [];\n}\nstaticData._collapse2_fired = true;\n\nconst metro = $('Metro Config').first().json.metro_name;\nconst headers = {\n  'apikey': $env.SUPABASE_SERVICE_KEY,\n  'Authorization': 'Bearer ' + $env.SUPABASE_SERVICE_KEY\n};\n\nlet prevCount = -1;\nlet stableRounds = 0;\n\nfor (let i = 0; i < 30; i++) {\n  // Wait 15 seconds between checks\n  await new Promise(r => setTimeout(r, 15000));\n\n  // Count discovered companies for this metro\n  const rows = await this.helpers.httpRequest({\n    method: 'GET',\n    url: $env.SUPABASE_URL + '/rest/v1/companies?enrichment_status=eq.discovered&discovery_metro=eq.' + encodeURIComponent(metro) + '&select=id',\n    headers,\n    json: true\n  });\n  const count = Array.isArray(rows) ? rows.length : 0;\n\n  if (count === prevCount && count > 0) {\n    stableRounds++;\n    if (stableRounds >= 2) break; // Stable for 30s \u2014 all inserts done\n  } else {\n    stableRounds = 0;\n  }\n  prevCount = count;\n}\n\nreturn [{ json: { _trigger: 'step1_insert_complete', _discovered_count: prevCount } }];"
      }
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $env.SUPABASE_URL }}/rest/v1/companies?on_conflict=google_place_id",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "apikey",
              "value": "={{ $env.SUPABASE_SERVICE_KEY }}"
            },
            {
              "name": "Authorization",
              "value": "=Bearer {{ $env.SUPABASE_SERVICE_KEY }}"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            },
            {
              "name": "Prefer",
              "value": "resolution=merge-duplicates"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({ name: $json.name, phone: $json.phone, domain: $json.domain, address: $json.address, city: $json.city, state: $json.state, country: $json.country, google_place_id: $json.google_place_id, category: $json.category, has_website: $json.has_website, source_urls: $json.source_urls, discovery_metro: $json.discovery_metro, enrichment_status: 'discovered', discovered_at: new Date().toISOString() }) }}",
        "options": {
          "batching": {
            "batch": {}
          }
        }
      },
      "id": "f4cdac90-eda5-4c9c-8e3e-aa2f04cf45ab",
      "name": "Insert to Supabase",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -7824,
        288
      ],
      "alwaysOutputData": true,
      "onError": "continueRegularOutput",
      "notes": "Clean records. Uses service_role key (bypasses RLS)."
    },
    {
      "id": "66759275-0ca5-4b3c-ab6d-b3e52db64922",
      "name": "Metro Config",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -10960,
        192
      ],
      "parameters": {
        "jsCode": "// Clear convergence-suppression flag from previous execution\n// Only Collapse to Single2 remains in simplified workflow\nconst staticData = $getWorkflowStaticData('global');\ndelete staticData._collapse2_fired;\n\n// Dynamic Metro Config \u2014 reads metro_name from webhook query parameter\nconst METROS = {\n  'Austin, TX':     { latitude: '30.2672',  longitude: '-97.7431',  yelp_location: 'Austin, TX', radius_meters: '15000' },\n  'Denver, CO':     { latitude: '39.7392',  longitude: '-104.9903', yelp_location: 'Denver, CO', radius_meters: '15000' },\n  'Phoenix, AZ':    { latitude: '33.4484',  longitude: '-112.0740', yelp_location: 'Phoenix, AZ', radius_meters: '15000' },\n  'Toronto, ON':    { latitude: '43.6532',  longitude: '-79.3832',  yelp_location: 'Toronto, ON', radius_meters: '15000' },\n  'San Diego, CA':  { latitude: '32.7157',  longitude: '-117.1611', yelp_location: 'San Diego, CA', radius_meters: '15000' },\n  'Boise, ID':      { latitude: '43.6150',  longitude: '-116.2023', yelp_location: 'Boise, ID', radius_meters: '25000' },\n  'Portland, OR':   { latitude: '45.5152',  longitude: '-122.6784', yelp_location: 'Portland, OR', radius_meters: '15000' },\n};\n\nconst webhookData = $('Webhook').first().json;\nconst metroName = (webhookData.query && webhookData.query.metro_name) || '';\n\nif (!metroName) {\n  throw new Error('Missing required query parameter: metro_name. Use ?metro_name=City, ST');\n}\n\nconst metro = METROS[metroName];\nif (!metro) {\n  const available = Object.keys(METROS).join(', ');\n  throw new Error(`Unknown metro: \"${metroName}\". Available: ${available}`);\n}\n\nreturn [{\n  json: {\n    metro_name: metroName,\n    latitude: metro.latitude,\n    longitude: metro.longitude,\n    radius_meters: metro.radius_meters,\n    search_queries: 'massage therapy,massage clinic,massage therapist,spa massage,therapeutic massage,deep tissue massage,sports massage,bodywork,day spa,wellness spa,relaxation massage,licensed massage therapist',\n    yelp_location: metro.yelp_location\n  }\n}];\n"
      },
      "notes": "Dynamic metro lookup \u2014 reads metro_name from webhook ?metro_name=City, ST query parameter. Add new metros to the METROS object."
    },
    {
      "parameters": {
        "url": "=https://api.apify.com/v2/datasets/{{ $json.datasetId }}/items?token={{ $env.APIFY_API_TOKEN }}",
        "options": {
          "timeout": 60000
        }
      },
      "id": "78eece76-1e81-4ce4-aef2-637dfd3815be",
      "name": "Fetch Apify Results",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -9168,
        288
      ],
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "fuzzy-check",
              "leftValue": "={{ $json._fuzzy_match_flag }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "21269bb4-ab43-49df-94ec-17640d94777d",
      "name": "Fuzzy Match?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        -8048,
        192
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $env.SUPABASE_URL }}/rest/v1/companies?on_conflict=google_place_id",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "apikey",
              "value": "={{ $env.SUPABASE_SERVICE_KEY }}"
            },
            {
              "name": "Authorization",
              "value": "=Bearer {{ $env.SUPABASE_SERVICE_KEY }}"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            },
            {
              "name": "Prefer",
              "value": "resolution=merge-duplicates"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({ name: $json.name, phone: $json.phone, domain: $json.domain, address: $json.address, city: $json.city, state: $json.state, country: $json.country, google_place_id: $json.google_place_id, category: $json.category, has_website: $json.has_website, source_urls: $json.source_urls, discovery_metro: $json.discovery_metro, enrichment_status: 'needs_review', discovered_at: new Date().toISOString() }) }}",
        "options": {}
      },
      "id": "6014b12d-87d3-45bc-9a6c-678a3c1031a2",
      "name": "Insert Flagged (Needs Review)",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -7824,
        96
      ],
      "notes": "Fuzzy-matched records. Status = needs_review for manual dedup.",
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "jsCode": "const now = new Date().toISOString();\nreturn $input.all().map(item => {\n  const r = item.json;\n  return { json: {\n    name: r.name, phone: r.phone || null, domain: r.domain || null,\n    address: r.address || null, city: r.city || null, state: r.state || null,\n    country: r.country || 'US', google_place_id: r.google_place_id || null,\n    category: r.category || null, has_website: r.has_website || false,\n    has_online_booking: false, booking_platform: null, has_paid_ads: false,\n    on_groupon: false,\n    on_yelp: (r.source_urls || []).some(s => s.source === 'yelp_apify'),\n    google_review_count: r.google_review_count || 0,\n    google_rating: r.google_rating || null,\n    estimated_size: null, source_urls: r.source_urls || [],\n    enrichment_status: r._fuzzy_match_flag ? 'needs_review' : 'discovered',\n    lead_score: 0, discovered_at: now, enriched_at: null,\n    discovery_metro: r.discovery_metro || null,\n    _fuzzy_match_flag: r._fuzzy_match_flag || false\n  }};\n});"
      },
      "id": "59bd4554-e739-4428-bd72-53b502f85f61",
      "name": "Prepare for Supabase",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -8272,
        192
      ]
    },
    {
      "parameters": {
        "jsCode": "const config = $input.first().json;\nconst queries = config.search_queries.split(',').map(q => q.trim());\nreturn queries.map(query => ({\n  json: {\n    query,\n    latitude: config.latitude,\n    longitude: config.longitude,\n    radius_meters: config.radius_meters,\n    metro_name: config.metro_name,\n    yelp_location: config.yelp_location\n  }\n}));"
      },
      "id": "3bbcf320-b713-415a-aca4-1f8fd1e54409",
      "name": "Split Search Queries",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -10736,
        192
      ]
    },
    {
      "parameters": {
        "jsCode": "const allInputs = JSON.parse(JSON.stringify($input.all().map(i => i.json)));\nconst allPlaces = [];\n\nfor (const input of allInputs) {\n  const places = input.places || [];\n  const q = input.query || '';\n  places.forEach(p => { p._query = q; });\n  allPlaces.push(...places);\n}\n\nconst metro = JSON.parse(JSON.stringify($('Metro Config').first().json)).metro_name;\n\n// Booking platform domain blocklist\nconst BLOCKED_DOMAINS = ['wixsite.com','wix.com','setmore.com','schedulista.com','glossgenius.com','square.site','genbook.com','jane.app','acuityscheduling.com','mindbodyonline.com','mindbody.io','vagaro.com','fresha.com','schedulicity.com','booksy.com','massagebook.com','noterro.com','clinicsense.com','calendly.com','squarespace.com'];\n// Business type blocklist - filter non-target businesses before Supabase insert\nconst BUSINESS_TYPE_BLOCKLIST = ['school','college','university','association','federation','union','board of','institute','academy','program'];\n\n\nreturn allPlaces.map(place => {\n  // Business type filter - skip non-target businesses\n  const _bizName = (place.displayName && place.displayName.text) || '';\n  const _bizCategory = (place.primaryTypeDisplayName && place.primaryTypeDisplayName.text) || place.primaryType || '';\n  const _bizNameLower = _bizName.toLowerCase();\n  const _bizCatLower = _bizCategory.toLowerCase();\n  if (BUSINESS_TYPE_BLOCKLIST.some(kw => _bizNameLower.includes(kw) || _bizCatLower.includes(kw))) return null;\n\n  let city = '', state = '', country = '';\n  if (place.addressComponents) {\n    for (const comp of place.addressComponents) {\n      if (comp.types && comp.types.includes('locality')) city = comp.longText || '';\n      if (comp.types && comp.types.includes('administrative_area_level_1')) state = comp.shortText || '';\n      if (comp.types && comp.types.includes('country')) country = comp.shortText || '';\n    }\n  }\n\n  let phone = place.internationalPhoneNumber || place.nationalPhoneNumber || '';\n  let phoneNormalized = phone.replace(/[^\\d+]/g, '');\n  if (phoneNormalized && !phoneNormalized.startsWith('+')) {\n    phoneNormalized = '+1' + phoneNormalized.replace(/^1/, '');\n  }\n\n  const website = place.websiteUri || '';\n  let domain = '';\n  if (website) {\n    const match = website.match(/^https?:\\/\\/(?:www\\.)?([^\\/]+)/i);\n    if (match) domain = match[1];\n  }\n\n  // Check domain against blocklist\n  let _domain_blocked = false;\n  let _domain_blocked_platform = '';\n  if (domain) {\n    const lowerDomain = domain.toLowerCase();\n    for (const blocked of BLOCKED_DOMAINS) {\n      if (lowerDomain === blocked || lowerDomain.endsWith('.' + blocked)) {\n        _domain_blocked = true;\n        _domain_blocked_platform = blocked;\n        domain = '';\n        break;\n      }\n    }\n  }\n\n  return {\n    json: {\n      name: (place.displayName && place.displayName.text) || '',\n      phone: phoneNormalized,\n      domain: domain,\n      address: place.formattedAddress || '',\n      city, state, country: country || 'US',\n      google_place_id: place.id || '',\n      category: (place.primaryTypeDisplayName && place.primaryTypeDisplayName.text) || place.primaryType || '',\n      google_rating: place.rating || null,\n      google_review_count: place.userRatingCount || 0,\n      has_website: _domain_blocked ? false : !!website,\n      google_maps_url: place.googleMapsUri || '',\n      source_urls: [{source: 'google_places', url: place.googleMapsUri || '', query_used: place._query || ''}],\n      discovery_metro: metro,\n      discovery_source: 'google_places',\n      _domain_blocked,\n      _domain_blocked_platform\n    }\n  };\n}).filter(Boolean);"
      },
      "id": "a9c14e44-5d37-4994-8a7a-b9283a47f5fe",
      "name": "Normalize Google Results",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -8944,
        48
      ]
    },
    {
      "parameters": {
        "amount": 20
      },
      "id": "13385ec3-d78d-4bbd-8579-d67fd6d52395",
      "name": "Wait 30s",
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1.1,
      "position": [
        -10064,
        288
      ],
      "webhookId": "58f36f86-6055-45a5-84d5-f71b858202b8"
    },
    {
      "parameters": {
        "jsCode": "const allItems = $('Deduplicate Records').all();\nconst metro = $('Metro Config').first().json.metro_name;\nconst fromGoogle = allItems.filter(i => (i.json.source_urls || []).some(s => s.source === 'google_places')).length;\nconst fromYelp = allItems.filter(i => (i.json.source_urls || []).some(s => s.source === 'yelp_apify')).length;\nconst bothSources = allItems.filter(i => { const s = (i.json.source_urls || []).map(x => x.source); return s.includes('google_places') && s.includes('yelp_apify'); }).length;\nconst fuzzyFlagged = allItems.filter(i => i.json._fuzzy_match_flag).length;\n\nconst summary = {\n  metro, run_timestamp: new Date().toISOString(),\n  total_unique_records: allItems.length,\n  found_on_google: fromGoogle, found_on_yelp: fromYelp, found_on_both: bothSources,\n  flagged_for_review: fuzzyFlagged,\n  clean_records: allItems.length - fuzzyFlagged,\n  sources_used: ['google_places', 'yelp_apify']\n};\nconsole.log('=== DISCOVERY RUN SUMMARY ===');\nconsole.log(JSON.stringify(summary, null, 2));\nreturn [{ json: summary }];"
      },
      "id": "d53e0354-3695-4aaf-948e-92e8bf3e80c4",
      "name": "Run Summary",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -7600,
        192
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://places.googleapis.com/v1/places:searchText",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "X-Goog-FieldMask",
              "value": "places.id,places.displayName,places.formattedAddress,places.nationalPhoneNumber,places.internationalPhoneNumber,places.websiteUri,places.googleMapsUri,places.rating,places.userRatingCount,places.primaryType,places.primaryTypeDisplayName,places.addressComponents,nextPageToken"
            },
            {
              "name": "X-Goog-Api-Key",
              "value": "={{ $env.GOOGLE_PLACES_API_KEY }}"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"textQuery\": \"{{ $json.query }}\",\n  \"locationBias\": {\n    \"circle\": {\n      \"center\": {\n        \"latitude\": {{ $json.latitude }},\n        \"longitude\": {{ $json.longitude }}\n      },\n      \"radius\": {{ $json.radius_meters }}\n    }\n  },\n  \"maxResultCount\": 20\n}",
        "options": {}
      },
      "id": "ecf3e8c2-15ac-4259-8944-94009fae0e13",
      "name": "Google Places - Text Search",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -9168,
        48
      ],
      "notes": "Google Places API (v1). Needs HTTP Header Auth credential: name='X-Goog-Api-Key', value=your API key."
    },
    {
      "parameters": {
        "jsCode": "const items = $input.all().map(i => i.json);\nconst canonical = [];\nconst phoneIndex = {};\nconst domainIndex = {};\n\nfunction normalizePhone(p) { return (p || '').replace(/[^\\d+]/g, ''); }\nfunction normalizeDomain(d) { return (d || '').toLowerCase().replace(/^www\\./, '').trim(); }\nfunction normalizeName(n) { return (n || '').toLowerCase().replace(/[^a-z0-9\\s]/g, '').trim(); }\nfunction nameSimilarity(a, b) {\n  const setA = new Set(normalizeName(a).split(/\\s+/));\n  const setB = new Set(normalizeName(b).split(/\\s+/));\n  const intersection = new Set([...setA].filter(x => setB.has(x)));\n  const union = new Set([...setA, ...setB]);\n  return union.size === 0 ? 0 : intersection.size / union.size;\n}\n\nfor (const item of items) {\n  const phone = normalizePhone(item.phone);\n  const domain = normalizeDomain(item.domain);\n  const city = (item.city || '').toLowerCase();\n  let matched = false;\n\n  if (phone && phone.length >= 10 && phoneIndex[phone] !== undefined) {\n    const existing = canonical[phoneIndex[phone]];\n    existing.source_urls = [...(existing.source_urls || []), ...(item.source_urls || [])];\n    if (!existing.domain && item.domain) existing.domain = item.domain;\n    if (!existing.google_place_id && item.google_place_id) existing.google_place_id = item.google_place_id;\n    if (!existing.has_website && item.has_website) existing.has_website = item.has_website;\n    if (item.google_rating) existing.google_rating = item.google_rating;\n    if (item.google_review_count) existing.google_review_count = item.google_review_count;\n    if (item.yelp_rating) existing.yelp_rating = item.yelp_rating;\n    if (item.yelp_review_count) existing.yelp_review_count = item.yelp_review_count;\n    if (item.yelp_url) existing.yelp_url = item.yelp_url;\n    matched = true;\n  }\n\n  if (!matched && domain && domainIndex[domain] !== undefined) {\n    const existing = canonical[domainIndex[domain]];\n    existing.source_urls = [...(existing.source_urls || []), ...(item.source_urls || [])];\n    if (!existing.phone && item.phone) existing.phone = item.phone;\n    if (!existing.google_place_id && item.google_place_id) existing.google_place_id = item.google_place_id;\n    if (item.google_rating) existing.google_rating = item.google_rating;\n    if (item.google_review_count) existing.google_review_count = item.google_review_count;\n    if (item.yelp_rating) existing.yelp_rating = item.yelp_rating;\n    if (item.yelp_review_count) existing.yelp_review_count = item.yelp_review_count;\n    if (item.yelp_url) existing.yelp_url = item.yelp_url;\n    matched = true;\n  }\n\n  if (!matched) {\n    let fuzzyMatch = false;\n    for (let i = 0; i < canonical.length; i++) {\n      const existing = canonical[i];\n      if ((existing.city || '').toLowerCase() === city && city !== '') {\n        if (nameSimilarity(existing.name, item.name) >= 0.85) {\n          existing.source_urls = [...(existing.source_urls || []), ...(item.source_urls || [])];\n          existing._fuzzy_match_flag = true;\n          existing._fuzzy_match_names = [...(existing._fuzzy_match_names || [existing.name]), item.name];\n          fuzzyMatch = true;\n          break;\n        }\n      }\n    }\n    if (!fuzzyMatch) {\n      const idx = canonical.length;\n      canonical.push({...item});\n      if (phone && phone.length >= 10) phoneIndex[phone] = idx;\n      if (domain) domainIndex[domain] = idx;\n    }\n  }\n}\n\nconsole.log('Dedup:', items.length, 'raw ->', canonical.length, 'unique,', canonical.filter(c => c._fuzzy_match_flag).length, 'fuzzy flagged');\nreturn canonical.map(item => ({ json: item }));"
      },
      "id": "50caf015-dd4e-4183-8124-b35fddffa354",
      "name": "Deduplicate Records",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -8496,
        192
      ]
    },
    {
      "parameters": {},
      "id": "8fcec5c5-45b7-4b87-b2cb-a32c6d692aab",
      "name": "Merge All Sources",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3,
      "position": [
        -8720,
        192
      ]
    },
    {
      "parameters": {
        "path": "001b878c-b5af-4c3c-8b78-d41e526049f4",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2.1,
      "position": [
        -11184,
        304
      ],
      "id": "1425be88-641d-4abd-a094-acab6b05acd7",
      "name": "Webhook",
      "webhookId": "001b878c-b5af-4c3c-8b78-d41e526049f4"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "succeeded",
              "leftValue": "={{ $json.status }}",
              "rightValue": "SUCCEEDED",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "deb02ddd-d3e5-4f68-a564-a4380714224d",
      "name": "Run Succeeded?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        -9392,
        288
      ]
    },
    {
      "id": "a1-enrich-companies-0001",
      "name": "Enrich Companies",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -7100,
        192
      ],
      "parameters": {
        "jsCode": "// Enrich Companies \u2014 Single Code node replacing entire Step 2 + Step 3b pipeline\n// Mode: runOnceForAllItems\n// Input: trigger from Run Summary (Step 1 discovery complete)\n// Output: summary \u2192 Find Contacts\n//\n// For each discovered company: domain backfill, website scrape, Google Details,\n// company update, social profiles insert. All via this.helpers.httpRequest().\n\nconst metro = $('Metro Config').first().json.metro_name;\nconst supabaseUrl = $env.SUPABASE_URL;\nconst supabaseKey = $env.SUPABASE_SERVICE_KEY;\nconst googleApiKey = $env.GOOGLE_PLACES_API_KEY;\nconst sbHeaders = { 'apikey': supabaseKey, 'Authorization': 'Bearer ' + supabaseKey };\nconst sbWriteHeaders = { ...sbHeaders, 'Content-Type': 'application/json', 'Prefer': 'return=minimal' };\n\n// \u2550\u2550\u2550 CONFIG (previously in Enrichment Config Set node) \u2550\u2550\u2550\nconst SKIP_GOOGLE_DETAILS = false;\nconst HTTP_TIMEOUT = 15000;\n\n// \u2550\u2550\u2550 CONSTANTS \u2550\u2550\u2550\n\nconst BLOCKED_DOMAINS = ['wixsite.com','wix.com','setmore.com','schedulista.com','glossgenius.com','square.site','genbook.com','jane.app','acuityscheduling.com','mindbodyonline.com','mindbody.io','vagaro.com','fresha.com','schedulicity.com','booksy.com','massagebook.com','noterro.com','clinicsense.com','calendly.com','squarespace.com'];\n\nconst bookingSignatures = {\n  'jane_app': ['jane.app', 'janeapp.com'],\n  'acuity': ['acuityscheduling.com', 'squareup.com/appointments', 'app.acuityscheduling.com'],\n  'mindbody': ['mindbodyonline.com', 'clients.mindbodyonline.com', 'mindbody.io', 'healcode.com'],\n  'square': ['square.site', 'squareup.com'],\n  'vagaro': ['vagaro.com'],\n  'fresha': ['fresha.com', 'shedul.com'],\n  'schedulicity': ['schedulicity.com'],\n  'schedulista': ['schedulista.com'],\n  'booksy': ['booksy.com'],\n  'massagebook': ['massagebook.com'],\n  'genbook': ['genbook.com'],\n  'noterro': ['noterro.com'],\n  'clinicsense': ['clinicsense.com'],\n  'wix_bookings': ['wix.com/booking', 'bookings.wixapps.net'],\n  'calendly': ['calendly.com']\n};\n\nconst bookingPatterns = ['book now', 'book online', 'book appointment', 'schedule now', 'schedule online', 'book a massage', 'online booking'];\n\nconst adSignatures = [\n  'googleadservices.com', 'googlesyndication.com', 'googleads.g.doubleclick.net',\n  'google_conversion', 'conversion_async', 'ads/ga-audiences',\n  'fbevents.js', 'fbq(', 'snap.licdn.com', 'linkedin.com/insight',\n  'analytics.tiktok.com', 'tiktok.com/i18n/pixel', 'ads-twitter.com', 'static.ads-twitter.com'\n];\n\nconst socialPatterns = {\n  facebook: /https?:\\/\\/(?:www\\.)?facebook\\.com\\/[a-zA-Z0-9._-]+/gi,\n  instagram: /https?:\\/\\/(?:www\\.)?instagram\\.com\\/[a-zA-Z0-9._-]+/gi,\n  tiktok: /https?:\\/\\/(?:www\\.)?tiktok\\.com\\/@[a-zA-Z0-9._-]+/gi,\n  linkedin: /https?:\\/\\/(?:www\\.)?linkedin\\.com\\/(?:company|in)\\/[a-zA-Z0-9._-]+/gi,\n  x: /https?:\\/\\/(?:www\\.)?(?:twitter\\.com|x\\.com)\\/[a-zA-Z0-9._-]+/gi,\n  youtube: /https?:\\/\\/(?:www\\.)?youtube\\.com\\/(?:c\\/|channel\\/|@)[a-zA-Z0-9._-]+/gi\n};\n\nconst junkEmailDomains = [\n  'sentry.io', 'schema.org', 'w3.org', 'wordpress.com', 'wordpress.org',\n  'squarespace.com', 'wix.com', 'gravatar.com', 'facebook.com', 'twitter.com',\n  'instagram.com', 'youtube.com', 'linkedin.com', 'pinterest.com', 'tiktok.com',\n  'cloudflare.com', 'googleapis.com', 'googletagmanager.com', 'google-analytics.com',\n  'gstatic.com', 'jsdelivr.net', 'cdnjs.cloudflare.com', 'unpkg.com',\n  'bootstrapcdn.com', 'fontawesome.com', 'typekit.net', 'fonts.googleapis.com',\n  'example.com', 'example.org', 'test.com', 'localhost',\n  'mailinator.com', 'guerrillamail.com', 'tempmail.com', 'yopmail.com'\n];\n\nconst junkLocalPatterns = [\n  /^noreply$/i, /^no-reply$/i, /^donotreply$/i, /^do-not-reply$/i,\n  /^postmaster$/i, /^mailer-daemon$/i, /^webmaster$/i, /^root$/i,\n  /^null$/i, /^test$/i, /^admin$/i, /^abuse$/i\n];\n\nconst roleBasedPrefixes = ['info', 'contact', 'hello', 'office', 'reception',\n  'frontdesk', 'front.desk', 'appointments', 'booking', 'bookings',\n  'schedule', 'scheduling', 'inquiries', 'inquiry', 'general', 'team', 'staff',\n  'support', 'sales', 'billing'];\n\nconst emailRegex = /[a-zA-Z0-9._%+\\-]+@[a-zA-Z0-9.\\-]+\\.[a-zA-Z]{2,}/g;\nconst mailtoRegex = /mailto:([a-zA-Z0-9._%+\\-]+@[a-zA-Z0-9.\\-]+\\.[a-zA-Z]{2,})/gi;\n\nconst teamPatterns = [\n  /our\\s+team/i, /meet\\s+(?:the\\s+)?team/i, /our\\s+(?:therapists|practitioners|staff|massage\\s+therapists)/i,\n  /meet\\s+(?:our|the)\\s+(?:therapists|practitioners|staff)/i\n];\n\nconst soloSignals = ['sole proprietor', 'solo practice', 'independent massage',\n  'i am a licensed', \"i'm a licensed\", 'about me', 'my practice', 'my approach',\n  'my services', 'i specialize', 'i provide'];\n\n// \u2550\u2550\u2550 HELPER FUNCTIONS \u2550\u2550\u2550\n\nfunction isDomainBlocked(domain) {\n  if (!domain) return false;\n  const lower = domain.toLowerCase();\n  return BLOCKED_DOMAINS.some(b => lower === b || lower.endsWith('.' + b));\n}\n\nfunction detectBookingFromDomain(domain) {\n  if (!domain) return { has_online_booking: false, booking_platform: null };\n  const lower = domain.toLowerCase();\n  for (const [platform, sigs] of Object.entries(bookingSignatures)) {\n    for (const sig of sigs) {\n      if (lower.includes(sig)) return { has_online_booking: true, booking_platform: platform };\n    }\n  }\n  return { has_online_booking: false, booking_platform: null };\n}\n\nfunction analyzeWebsiteHtml(rawHtml, domain) {\n  const result = {\n    has_online_booking: false, booking_platform: null, has_paid_ads: false,\n    estimated_size: null, social_links_found: [], emails_found: [], best_email: null,\n    _website_fetch_status: 'success'\n  };\n\n  // Domain-based booking detection first\n  const domainBooking = detectBookingFromDomain(domain);\n  result.has_online_booking = domainBooking.has_online_booking;\n  result.booking_platform = domainBooking.booking_platform;\n\n  if (!rawHtml || typeof rawHtml !== 'string') {\n    result._website_fetch_status = 'empty_response';\n    return result;\n  }\n\n  const html = rawHtml.toLowerCase();\n  const htmlOriginal = rawHtml;\n\n  // Email extraction\n  const allEmailMatches = htmlOriginal.match(emailRegex) || [];\n  mailtoRegex.lastIndex = 0;\n  const mailtoEmails = new Set();\n  let mailtoMatch;\n  while ((mailtoMatch = mailtoRegex.exec(htmlOriginal)) !== null) {\n    mailtoEmails.add(mailtoMatch[1].toLowerCase());\n  }\n\n  const uniqueEmails = [...new Set(allEmailMatches.map(e => e.toLowerCase()))];\n  const scoredEmails = [];\n\n  for (const email of uniqueEmails) {\n    const [localPart, emailDomain] = email.split('@');\n    if (!emailDomain) continue;\n    if (junkEmailDomains.some(d => emailDomain.includes(d))) continue;\n    if (junkLocalPatterns.some(p => p.test(localPart))) continue;\n    if (/^\\d+$/.test(localPart)) continue;\n\n    let score = 0;\n    if (domain && emailDomain.includes(domain.replace('www.', ''))) score += 20;\n    if (mailtoEmails.has(email)) score += 10;\n    if (roleBasedPrefixes.some(p => localPart === p || localPart.startsWith(p + '.'))) score += 5;\n    scoredEmails.push({ email, score, from_mailto: mailtoEmails.has(email) });\n  }\n\n  scoredEmails.sort((a, b) => b.score - a.score);\n  result.emails_found = scoredEmails.slice(0, 5);\n  result.best_email = scoredEmails.length > 0 ? scoredEmails[0].email : null;\n\n  // HTML-based booking detection\n  if (!result.has_online_booking) {\n    for (const [platform, sigs] of Object.entries(bookingSignatures)) {\n      for (const sig of sigs) {\n        if (html.includes(sig)) {\n          result.booking_platform = platform;\n          result.has_online_booking = true;\n          break;\n        }\n      }\n      if (result.has_online_booking) break;\n    }\n  }\n  if (!result.has_online_booking) {\n    for (const pattern of bookingPatterns) {\n      if (html.includes(pattern)) {\n        result.has_online_booking = true;\n        result.booking_platform = 'unknown';\n        break;\n      }\n    }\n  }\n\n  // Paid ads detection\n  for (const sig of adSignatures) {\n    if (html.includes(sig)) { result.has_paid_ads = true; break; }\n  }\n\n  // Social links extraction\n  const seenPlatforms = new Set();\n  for (const [platform, regex] of Object.entries(socialPatterns)) {\n    regex.lastIndex = 0;\n    const matches = htmlOriginal.match(regex) || [];\n    for (const url of matches) {\n      const lowerUrl = url.toLowerCase();\n      if (lowerUrl.includes('/sharer') || lowerUrl.includes('/share') ||\n          lowerUrl.includes('/intent') || lowerUrl.includes('/login') ||\n          lowerUrl.includes('/help') || lowerUrl.includes('/about') ||\n          lowerUrl.includes('/policies') || lowerUrl.includes('/privacy')) continue;\n      if (!seenPlatforms.has(platform)) {\n        result.social_links_found.push({ platform, url: url.replace(/\\/+$/, '') });\n        seenPlatforms.add(platform);\n      }\n    }\n  }\n\n  // Team size estimation\n  let hasTeamPage = false;\n  for (const p of teamPatterns) { if (p.test(htmlOriginal)) { hasTeamPage = true; break; } }\n  if (hasTeamPage) {\n    const namePatterns = htmlOriginal.match(/<h[2-4][^>]*>[^<]{2,40}<\\/h[2-4]>/gi) || [];\n    const staffLinks = htmlOriginal.match(/\\/(?:team|staff|therapist|practitioner)s?\\/[a-z-]+/gi) || [];\n    const memberCount = Math.max(namePatterns.length, staffLinks.length);\n    if (memberCount <= 1) result.estimated_size = 'solo';\n    else if (memberCount <= 5) result.estimated_size = 'small';\n    else result.estimated_size = 'medium';\n  } else {\n    if (soloSignals.some(s => html.includes(s))) result.estimated_size = 'solo';\n  }\n\n  return result;\n}\n\nfunction extractDomainFromPlaces(company, places) {\n  if (!places || places.length === 0) return null;\n\n  const companyName = (company.name || '').toLowerCase().replace(/[^a-z0-9\\s]/g, '');\n  const companyPhone = (company.phone || '').replace(/[^\\d]/g, '');\n\n  let bestMatch = null;\n  let bestScore = 0;\n\n  for (const place of places) {\n    const placeName = ((place.displayName && place.displayName.text) || '').toLowerCase().replace(/[^a-z0-9\\s]/g, '');\n    let score = 0;\n\n    const companyWords = companyName.split(/\\s+/).filter(w => w.length > 2);\n    const placeWords = placeName.split(/\\s+/).filter(w => w.length > 2);\n    const matchingWords = companyWords.filter(w => placeWords.some(pw => pw.includes(w) || w.includes(pw)));\n    score = companyWords.length > 0 ? matchingWords.length / companyWords.length : 0;\n\n    const placePhone = (place.internationalPhoneNumber || place.nationalPhoneNumber || '').replace(/[^\\d]/g, '');\n    if (companyPhone && placePhone && (placePhone.includes(companyPhone.slice(-10)) || companyPhone.includes(placePhone.slice(-10)))) {\n      score += 0.5;\n    }\n\n    if (score > bestScore && score >= 0.4) { bestScore = score; bestMatch = place; }\n  }\n\n  if (!bestMatch) return null;\n\n  const website = bestMatch.websiteUri || '';\n  let domain = null;\n  if (website) {\n    const match = website.match(/^https?:\\/\\/(?:www\\.)?([^\\/]+)/i);\n    if (match) domain = match[1];\n  }\n\n  // Check domain against blocklist\n  if (domain && isDomainBlocked(domain)) domain = null;\n\n  return {\n    domain,\n    google_place_id: bestMatch.id || null,\n    google_rating: bestMatch.rating || null,\n    google_review_count: bestMatch.userRatingCount || null,\n    _match_score: bestScore\n  };\n}\n\nconst delay = (ms) => new Promise(r => setTimeout(r, ms));\n\n// \u2550\u2550\u2550 FETCH COMPANIES \u2550\u2550\u2550\n\nconst companies = await this.helpers.httpRequest({\n  method: 'GET',\n  url: `${supabaseUrl}/rest/v1/companies?enrichment_status=in.(discovered,partially_enriched)&discovery_metro=eq.${encodeURIComponent(metro)}&order=discovered_at.asc&limit=1000&select=id,name,phone,domain,address,city,state,country,google_place_id,category,has_website,google_review_count,google_rating,source_urls,on_yelp,on_groupon`,\n  headers: sbHeaders,\n  json: true\n});\n\nif (!Array.isArray(companies) || companies.length === 0) {\n  console.log('No companies to enrich for metro: ' + metro);\n  return [{ json: { step: 'enrich_companies', processed: 0, message: 'No companies to enrich' } }];\n}\n\nconsole.log(`Enrich Companies: ${companies.length} companies to process for ${metro}`);\n\n// \u2550\u2550\u2550 STATS \u2550\u2550\u2550\nconst stats = {\n  processed: 0, domainBackfilled: 0, websitesFetched: 0, websiteErrors: 0,\n  bookingDetected: 0, paidAdsDetected: 0, socialFromWebsite: 0, socialProfilesInserted: 0,\n  googleDetailsProcessed: 0, companyUpdates: 0, updateErrors: 0, errors: 0\n};\n\n// \u2550\u2550\u2550 MAIN LOOP \u2550\u2550\u2550\n\nfor (const company of companies) {\n  try {\n    let domain = company.domain;\n    let backfillPatch = {};\n    let has_website = company.has_website;\n\n    // \u2500\u2500 1. Domain backfill if needed \u2500\u2500\n    if (!domain && has_website) {\n      try {\n        const placesResp = await this.helpers.httpRequest({\n          method: 'POST',\n          url: 'https://places.googleapis.com/v1/places:searchText',\n          headers: {\n            'X-Goog-FieldMask': 'places.id,places.displayName,places.nationalPhoneNumber,places.internationalPhoneNumber,places.websiteUri,places.rating,places.userRatingCount',\n            'X-Goog-Api-Key': googleApiKey,\n            'Content-Type': 'application/json'\n          },\n          body: { textQuery: `${company.name} ${company.city} ${company.state}`, maxResultCount: 3 },\n          json: true\n        });\n\n        const result = extractDomainFromPlaces(company, placesResp.places || []);\n        if (result) {\n          if (result.domain) {\n            domain = result.domain;\n            has_website = true;\n            backfillPatch.domain = domain;\n            backfillPatch.has_website = true;\n          }\n          if (result.google_place_id && !company.google_place_id) backfillPatch.google_place_id = result.google_place_id;\n          if (result.google_rating && !company.google_rating) backfillPatch.google_rating = result.google_rating;\n          if (result.google_review_count && !company.google_review_count) backfillPatch.google_review_count = result.google_review_count;\n          stats.domainBackfilled++;\n        }\n        await delay(200);\n      } catch(e) {\n        console.log(`Domain backfill error for ${company.name}: ${e.message}`);\n      }\n    }\n\n    // \u2500\u2500 2. Website scrape \u2500\u2500\n    let websiteData = {\n      has_online_booking: false, booking_platform: null, has_paid_ads: false,\n      estimated_size: null, social_links_found: [], emails_found: [], best_email: null,\n      _website_fetch_status: 'skipped'\n    };\n\n    if (domain && !isDomainBlocked(domain)) {\n      try {\n        const resp = await this.helpers.httpRequest({\n          method: 'GET',\n          url: `https://${domain}`,\n          headers: {\n            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36',\n            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8'\n          },\n          returnFullResponse: true,\n          timeout: HTTP_TIMEOUT,\n          json: false,\n        });\n        const rawHtml = resp.body || '';\n        if (typeof rawHtml === 'string' && rawHtml.length > 100) {\n          websiteData = analyzeWebsiteHtml(rawHtml, domain);\n          stats.websitesFetched++;\n        } else {\n          websiteData._website_fetch_status = 'empty_response';\n          stats.websiteErrors++;\n        }\n      } catch(e) {\n        websiteData._website_fetch_status = 'error';\n        // Still check domain for booking platform signals\n        const domainBooking = detectBookingFromDomain(domain);\n        websiteData.has_online_booking = domainBooking.has_online_booking;\n        websiteData.booking_platform = domainBooking.booking_platform;\n        stats.websiteErrors++;\n      }\n    } else if (domain && isDomainBlocked(domain)) {\n      // Blocked domain \u2014 still detect booking platform from domain\n      const domainBooking = detectBookingFromDomain(domain);\n      websiteData.has_online_booking = domainBooking.has_online_booking;\n      websiteData.booking_platform = domainBooking.booking_platform;\n      websiteData._website_fetch_status = 'skipped_blocked_domain';\n    } else {\n      // No domain \u2014 check company's existing domain for booking signals\n      const domainBooking = detectBookingFromDomain(company.domain);\n      websiteData.has_online_booking = domainBooking.has_online_booking;\n      websiteData.booking_platform = domainBooking.booking_platform;\n      websiteData._website_fetch_status = 'skipped_no_website';\n    }\n\n    if (websiteData.has_online_booking) stats.bookingDetected++;\n    if (websiteData.has_paid_ads) stats.paidAdsDetected++;\n    stats.socialFromWebsite += websiteData.social_links_found.length;\n\n    // \u2500\u2500 3. Google Places Details \u2500\u2500\n    let googleDetails = {\n      opening_hours: null, business_status: null, photo_count: 0,\n      price_level: null, additional_types: [], _fetch_status: 'skipped'\n    };\n\n    const placeId = company.google_place_id || backfillPatch.google_place_id;\n    if (placeId && !SKIP_GOOGLE_DETAILS) {\n      try {\n        const details = await this.helpers.httpRequest({\n          method: 'GET',\n          url: `https://places.googleapis.com/v1/places/${placeId}`,\n          headers: {\n            'X-Goog-FieldMask': 'currentOpeningHours,regularOpeningHours,types,photos,priceLevel,businessStatus',\n            'X-Goog-Api-Key': googleApiKey\n          },\n          json: true\n        });\n\n        if (details && !details.error) {\n          if (details.regularOpeningHours && details.regularOpeningHours.periods) {\n            googleDetails.opening_hours = details.regularOpeningHours;\n          } else if (details.currentOpeningHours && details.currentOpeningHours.periods) {\n            googleDetails.opening_hours = details.currentOpeningHours;\n          }\n          googleDetails.business_status = details.businessStatus || null;\n          if (details.photos && Array.isArray(details.photos)) googleDetails.photo_count = details.photos.length;\n          googleDetails.price_level = details.priceLevel || null;\n          if (details.types && Array.isArray(details.types)) googleDetails.additional_types = details.types;\n          googleDetails._fetch_status = 'success';\n          stats.googleDetailsProcessed++;\n        }\n        await delay(100);\n      } catch(e) {\n        googleDetails._fetch_status = 'error';\n        console.log(`Google Details error for ${company.name}: ${e.message}`);\n      }\n    }\n\n    // \u2500\u2500 4. Build update payload \u2500\u2500\n    const now = new Date().toISOString();\n    const updatePayload = {\n      has_online_booking: websiteData.has_online_booking || false,\n      booking_platform: websiteData.booking_platform || null,\n      has_paid_ads: websiteData.has_paid_ads || false,\n      estimated_size: websiteData.estimated_size || null,\n      enrichment_status: 'partially_enriched',\n      enriched_at: now\n    };\n\n    // Backfill data\n    if (backfillPatch.domain) updatePayload.domain = backfillPatch.domain;\n    if (backfillPatch.google_place_id) updatePayload.google_place_id = backfillPatch.google_place_id;\n    if (backfillPatch.google_rating) updatePayload.google_rating = backfillPatch.google_rating;\n    if (backfillPatch.google_review_count) updatePayload.google_review_count = backfillPatch.google_review_count;\n    if (backfillPatch.has_website) updatePayload.has_website = backfillPatch.has_website;\n    if (has_website && !company.has_website) updatePayload.has_website = has_website;\n\n    // Website-scraped email\n    if (websiteData.best_email) updatePayload.email = websiteData.best_email;\n\n    // Google Details \u2014 store opening hours as JSON\n    // (opening_hours, business_status, photo_count, price_level stored in company row)\n    if (googleDetails._fetch_status === 'success') {\n      if (googleDetails.opening_hours) updatePayload.opening_hours = googleDetails.opening_hours;\n      if (googleDetails.business_status) updatePayload.business_status = googleDetails.business_status;\n      if (googleDetails.photo_count) updatePayload.photo_count = googleDetails.photo_count;\n      if (googleDetails.price_level) updatePayload.price_level = googleDetails.price_level;\n    }\n\n    // \u2500\u2500 5. PATCH company in Supabase \u2500\u2500\n    try {\n      await this.helpers.httpRequest({\n        method: 'PATCH',\n        url: `${supabaseUrl}/rest/v1/companies?id=eq.${company.id}`,\n        headers: sbWriteHeaders,\n        body: updatePayload,\n        json: true\n      });\n      stats.companyUpdates++;\n    } catch(e) {\n      console.log(`Company update error for ${company.name} (${company.id}): ${e.message}`);\n      stats.updateErrors++;\n    }\n\n    // \u2500\u2500 6. Insert social profiles if found \u2500\u2500\n    if (websiteData.social_links_found.length > 0) {\n      const rows = websiteData.social_links_found.map(link => ({\n        company_id: company.id,\n        platform: link.platform,\n        profile_url: link.url,\n        follower_count: null,\n        post_count: null,\n        last_post_date: null,\n        scraped_at: now\n      }));\n\n      try {\n        await this.helpers.httpRequest({\n          method: 'POST',\n          url: `${supabaseUrl}/rest/v1/social_profiles`,\n          headers: { ...sbHeaders, 'Content-Type': 'application/json', 'Prefer': 'resolution=merge-duplicates,return=minimal' },\n          body: rows,\n          json: true\n        });\n        stats.socialProfilesInserted += rows.length;\n      } catch(e) {\n        console.log(`Social profiles insert error for ${company.name}: ${e.message}`);\n      }\n    }\n\n    stats.processed++;\n    if (stats.processed % 25 === 0) {\n      console.log(`  Progress: ${stats.processed}/${companies.length} companies enriched`);\n    }\n  } catch(e) {\n    console.log(`FATAL error enriching ${company.name}: ${e.message}`);\n    stats.errors++;\n  }\n}\n\n// \u2550\u2550\u2550 SUMMARY \u2550\u2550\u2550\nconst summary = {\n  step: 'enrich_companies',\n  metro,\n  run_completed_at: new Date().toISOString(),\n  companies_processed: stats.processed,\n  domain_backfilled: stats.domainBackfilled,\n  websites_fetched: stats.websitesFetched,\n  website_errors: stats.websiteErrors,\n  booking_platforms_detected: stats.bookingDetected,\n  paid_ads_detected: stats.paidAdsDetected,\n  social_links_from_websites: stats.socialFromWebsite,\n  social_profiles_inserted: stats.socialProfilesInserted,\n  google_details_processed: stats.googleDetailsProcessed,\n  company_updates: stats.companyUpdates,\n  update_errors: stats.updateErrors,\n  fatal_errors: stats.errors,\n  message: `Enriched ${stats.processed} companies. ${stats.websitesFetched} websites fetched, ${stats.socialProfilesInserted} social profiles, ${stats.bookingDetected} booking platforms, ${stats.paidAdsDetected} paid ads. ${stats.updateErrors} update errors, ${stats.errors} fatal errors.`\n};\n\nconsole.log('=== STEP 2: ENRICH COMPANIES SUMMARY ===');\nconsole.log(JSON.stringify(summary, null, 2));\n\nreturn [{ json: summary }];\n",
        "mode": "runOnceForAllItems"
      }
    },
    {
      "id": "a1-find-contacts-0001",
      "name": "Find Contacts",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -6600,
        192
      ],
      "parameters": {
        "jsCode": "// Find Contacts \u2014 Single Code node replacing entire Step 3a pipeline\n// Mode: runOnceForAllItems\n// Input: trigger from Enrich Companies\n// Output: summary \u2192 Enrich Contacts\n//\n// For each company without contacts: solo detection, Apollo search/enrich,\n// about page scraping, name extraction, validation, Supabase insert.\n\nconst metro = $('Metro Config').first().json.metro_name;\nconst supabaseUrl = $env.SUPABASE_URL;\nconst supabaseKey = $env.SUPABASE_SERVICE_KEY;\nconst apolloApiKey = $env.APOLLO_API_KEY;\nconst sbHeaders = { 'apikey': supabaseKey, 'Authorization': 'Bearer ' + supabaseKey };\n\n// \u2550\u2550\u2550 CONFIG (previously in Step 3a Config Set node) \u2550\u2550\u2550\nconst SKIP_APOLLO = false;\nconst SKIP_WEBSITE_SCRAPE = false;\nconst APOLLO_ENRICH_ENABLED = true;\n\nconst delay = (ms) => new Promise(r => setTimeout(r, ms));\n\n// \u2550\u2550\u2550 COMMON FIRST NAMES \u2550\u2550\u2550\nconst commonFirstNames = new Set([\n  'aaron','abby','abigail','adam','adrian','adriana','aiden','aimee','alana','albert',\n  'alec','alexa','alexander','alexandra','alexis','alice','alicia','alina','alison','allison',\n  'alyssa','amanda','amber','amelia','amy','ana','andrea','andrew','angela','angelica',\n  'angie','anita','ann','anna','anne','annie','anthony','april','aria','ariana',\n  'ashley','audrey','austin','autumn','ava','avery','bailey','barbara','beatrice','becky',\n  'bella','ben','benjamin','beth','bethany','betty','beverly','bianca','blake','bonnie',\n  'brad','bradley','brandi','brandon','brandy','breanna','brenda','brent','brett','brian',\n  'briana','brianna','bridget','brittany','brittney','brooke','bruce','bryan','caitlin','caleb',\n  'cameron','camila','candace','cara','carina','carl','carla','carlos','carly','carmen',\n  'carol','carolina','caroline','carolyn','carrie','casey','cassandra','cassidy','catherine','cathy',\n  'cecilia','celeste','celia','chad','charlene','charles','charlie','charlotte','chase','chelsea',\n  'cheryl','chloe','chris','christa','christian','christina','christine','christopher','cindy','claire',\n  'clara','claudia','cody','colleen','connor','constance','corey','corinne','courtney','craig',\n  'crystal','cynthia','daisy','dale','dana','daniel','daniela','danielle','daphne','darlene',\n  'darren','dave','david','dawn','dean','deanna','debbie','deborah','debra','denise',\n  'derek','desiree','destiny','diana','diane','dianne','dolores','dominic','donna','doris',\n  'dorothy','douglas','drew','dustin','dylan','eddie','edith','edward','eileen','elaine',\n  'elena','elisa','elizabeth','ella','ellen','ellie','emily','emma','eric','erica',\n  'erika','erin','ernest','esther','ethan','eugene','eva','evan','evelyn','faith',\n  'faye','felicia','fiona','florence','frances','frank','gabriel','gabriela','gabriella','gabrielle',\n  'gail','gary','gavin','genevieve','george','georgia','gerald','gina','giselle','gladys',\n  'glen','glenn','gloria','grace','grant','greg','gregory','gretchen','hailey','haley',\n  'hannah','harold','harriet','harry','hayden','hazel','heather','heidi','helen','henry',\n  'hillary','holly','hope','howard','hunter','ian','irene','iris','isaac','isabel',\n  'isabella','ivy','jack','jackie','jackson','jacob','jacqueline','jade','jaime','jake',\n  'james','jamie','jan','jane','janet','janice','jared','jasmine','jason','jay',\n  'jean','jeanette','jeanne','jeff','jeffrey','jenna','jennifer','jenny','jeremy','jerry',\n  'jesse','jessica','jill','jillian','jim','jimmy','jo','joan','joann','joanna',\n  'joanne','jocelyn','jodi','jody','joe','joel','johanna','john','johnny','jolene',\n  'jon','jonathan','jordan','jorge','jose','joseph','josephine','josh','joshua','joy',\n  'joyce','juan','judith','judy','julia','julian','juliana','julie','june','justin',\n  'kaitlyn','kara','karen','karina','karl','kate','katelyn','katherine','kathleen','kathryn',\n  'kathy','katie','katrina','kay','kayla','keith','kelley','kelli','kelly','kelsey',\n  'ken','kendra','kenneth','kenny','kerry','kevin','kim','kimberly','kirsten','krista',\n  'kristen','kristin','kristina','kristy','kyle','kylie','lacey','lana','lance','larry',\n  'laura','lauren','laurie','leah','lee','leigh','lena','leo','leon','leslie',\n  'lexy','liam','lillian','lily','linda','lindsay','lindsey','lisa','logan','lois',\n  'lora','lorena','lori','lorraine','louis','louise','lucia','luis','luke','lydia',\n  'lynn','mackenzie','madeline','madison','maggie','malik','mallory','mandy','marc','marcia',\n  'marco','marcus','margaret','maria','mariah','marie','marilyn','marina','mario','marisa',\n  'marissa','mark','marlene','marsha','martha','martin','mary','mason','matt','matthew',\n  'maureen','max','maya','megan','meghan','melanie','melinda','melissa','melody','meredith',\n  'mia','michael','michele','michelle','miguel','mike','mildred','mindy','miranda','misty',\n  'mitchell','molly','monica','monique','morgan','mya','nadia','nancy','naomi','natalia',\n  'natalie','natasha','nathan','nathaniel','neil','nelson','nicholas','nicole','nina','noah',\n  'noel','nora','norma','olivia','owen','paige','pam','pamela','patricia','patrick',\n  'patty','paul','paula','pauline','peggy','penny','peter','philip','phyllis','priscilla',\n  'rachel','ralph','ramona','randall','randy','ray','raymond','rebecca','regina','renee',\n  'rhonda','ricardo','richard','rick','ricky','riley','rita','rob','robert','roberta',\n  'robin','rochelle','rodney','roger','ronald','rosa','rosalie','rose','rosemary','roxanne',\n  'ruby','russell','ruth','ryan','sabrina','sally','samantha','samuel','sandra','sandy',\n  'sara','sarah','savannah','scott','sean','selena','serena','seth','shana','shane',\n  'shannon','sharon','shawn','sheila','shelby','shelley','shelly','sheri','sherri','sherry',\n  'shirley','sierra','silvia','simone','sofia','sonia','sonya','sophia','stacey','stacy',\n  'stella','stephanie','stephen','steve','steven','sue','summer','susan','suzanne','sydney',\n  'sylvia','tabitha','tamara','tammy','tanya','tara','tatiana','taylor','teresa','terri',\n  'terry','tess','tessa','theresa','thomas','tiffany','tim','timothy','tina','tito',\n  'todd','tom','tommy','toni','tony','tonya','tracey','traci','tracy','travis',\n  'tricia','trisha','troy','tyler','valerie','vanessa','vera','veronica','vicki','vicky',\n  'victoria','vincent','violet','virginia','vivian','wade','walter','wanda','warren','wayne',\n  'wendy','wesley','whitney','william','willie','wilma','xavier','yolanda','yvette','yvonne',\n  'zachary','zoe'\n]);\n\nfunction isLikelyFirstName(word) {\n  return commonFirstNames.has((word || '').toLowerCase());\n}\n\n// \u2550\u2550\u2550 SOLO PRACTITIONER DETECTION \u2550\u2550\u2550\n\nfunction checkSoloPractitioner(company) {\n  const name = (company.name || '').trim();\n  const estimatedSize = company.estimated_size;\n  let isSolo = false, firstName = null, lastName = null;\n\n  // Pattern 1: \"by Name\"\n  const byPattern = name.match(/\\bby\\s+([A-Z][a-z]+)(?:\\s+([A-Z][a-z]+))?/i);\n  if (byPattern) {\n    if (isLikelyFirstName(byPattern[1]) || estimatedSize === 'solo') {\n      isSolo = true; firstName = byPattern[1]; lastName = byPattern[2] || null;\n    }\n  }\n\n  // Pattern 2: \"with Name\"\n  if (!firstName) {\n    const withPattern = name.match(/\\bwith\\s+([A-Z][a-z]+)(?:\\s+([A-Z][a-z]+))?/i);\n    if (withPattern && (isLikelyFirstName(withPattern[1]) || estimatedSize === 'solo')) {\n      isSolo = true; firstName = withPattern[1]; lastName = withPattern[2] || null;\n    }\n  }\n\n  // Pattern 3: Possessive\n  if (!firstName) {\n    const possessiveMatch = name.match(/^([A-Z][a-z]+)'s\\s+/i);\n    if (possessiveMatch && isLikelyFirstName(possessiveMatch[1])) {\n      isSolo = true; firstName = possessiveMatch[1];\n    }\n  }\n\n  // Pattern 4: \"FirstName LastName, LMT/CMT/RMT\"\n  if (!firstName) {\n    const nameFirst = name.match(/^([A-Z][a-z]+)\\s+([A-Z][a-z]+)(?:\\s*[,|]\\s*|\\s+)(?:LMT|CMT|RMT|Licensed|Massage|Bodywork|Therapeutic|Wellness)/i);\n    if (nameFirst && isLikelyFirstName(nameFirst[1]) && !commonFirstNames.has(nameFirst[2].toLowerCase())) {\n      isSolo = true; firstName = nameFirst[1]; lastName = nameFirst[2];\n    }\n  }\n\n  // Pattern 5: \"FirstName LastName's Massage/Spa\"\n  if (!firstName) {\n    const possessiveFullName = name.match(/^([A-Z][a-z]+)\\s+([A-Z][a-z]+)'s\\s+(?:Massage|Bodywork|Wellness|Spa|Healing)/i);\n    if (possessiveFullName && isLikelyFirstName(possessiveFullName[1])) {\n      isSolo = true; firstName = possessiveFullName[1]; lastName = possessiveFullName[2];\n    }\n  }\n\n  // Pattern 6: Three-part name with title\n  if (!firstName) {\n    const threePartName = name.match(/^([A-Z][a-z]+)\\s+([A-Z][a-z]+)\\s+([A-Z][a-z]+),?\\s+(?:LMT|CMT|RMT|Licensed)/i);\n    if (threePartName && isLikelyFirstName(threePartName[1])) {\n      isSolo = true; firstName = threePartName[1]; lastName = threePartName[3];\n    }\n  }\n\n  // Pattern 7: Name after comma\n  if (!firstName) {\n    const commaNameMatch = name.match(/,\\s*([A-Z][a-z]+)\\s+([A-Z][a-z]+)(?:\\s*,?\\s*(?:LMT|CMT|RMT|Licensed))?/i);\n    if (commaNameMatch && isLikelyFirstName(commaNameMatch[1])) {\n      isSolo = true; firstName = commaNameMatch[1]; lastName = commaNameMatch[2];\n    }\n  }\n\n  if (estimatedSize === 'solo' && !isSolo) isSolo = true;\n\n  // Reject if extracted first name matches city\n  if (firstName && company.city && firstName.toLowerCase() === company.city.toLowerCase()) {\n    firstName = null; lastName = null;\n  }\n\n  return { isSolo, firstName, lastName };\n}\n\n// \u2550\u2550\u2550 NAME EXTRACTION FROM HTML \u2550\u2550\u2550\n\nfunction extractNameFromHtml(html) {\n  if (!html || html.length < 100) return null;\n  const textOnly = html.replace(/<[^>]+>/g, ' ').replace(/\\s+/g, ' ');\n\n  const patterns = [\n    /(?:owner|owned\\s+by|founded\\s+by|proprietor)[:\\s]+([A-Z][a-z]+)\\s+([A-Z][a-z]+)/i,\n    /(?:hi,?\\s+i'?m|hello,?\\s+i'?m|my\\s+name\\s+is|i\\s+am)\\s+([A-Z][a-z]+)\\s+([A-Z][a-z]+)/i,\n    /(?:^|\\s)about\\s+([A-Z][a-z]+)\\s+([A-Z][a-z]+)(?:\\s*[,|]|\\s+(?:LMT|CMT|RMT|Licensed))/i,\n    /(?:^|\\s)meet\\s+([A-Z][a-z]+)\\s+([A-Z][a-z]+)(?:\\s*[,|]|\\s+(?:LMT|CMT|RMT|Licensed|is\\s+a|has\\s+been))/i,\n    /([A-Z][a-z]+)\\s+([A-Z][a-z]+),?\\s+(?:LMT|CMT|RMT|Licensed\\s+Massage)/i\n  ];\n\n  for (const pattern of patterns) {\n    for (const source of [textOnly, html]) {\n      const match = source.match(pattern);\n      if (match) {\n        const fn = match[1], ln = match[2];\n        if (isLikelyFirstName(fn) && fn.length >= 2 && fn.length <= 20 && ln.length >= 2 && ln.length <= 20) {\n          return { firstName: fn, lastName: ln };\n        }\n      }\n    }\n  }\n  return null;\n}\n\n// \u2550\u2550\u2550 NAME EXTRACTION FROM BUSINESS NAME (no domain fallback) \u2550\u2550\u2550\n\nfunction extractNameFromBusinessName(company) {\n  const name = (company.name || '').trim();\n  let firstName = null, lastName = null;\n\n  const patterns = [\n    { re: /\\bby\\s+([A-Z][a-z]+)(?:\\s+([A-Z][a-z]+))?/i, fi: 1, li: 2 },\n    { re: /\\bwith\\s+([A-Z][a-z]+)(?:\\s+([A-Z][a-z]+))?/i, fi: 1, li: 2 },\n    { re: /^([A-Z][a-z]+)'s\\s+/i, fi: 1, li: null },\n    { re: /^([A-Z][a-z]+)\\s+([A-Z][a-z]+)(?:\\s*,?\\s*(?:LMT|CMT|RMT|Licensed))/i, fi: 1, li: 2 },\n    { re: /,\\s*([A-Z][a-z]+)\\s+([A-Z][a-z]+)/i, fi: 1, li: 2 },\n    { re: /^([A-Z][a-z]+)\\s+([A-Z][a-z]+)\\s+(?:Massage|Bodywork|Therapeutic|Wellness|Healing|Spa)/i, fi: 1, li: 2 },\n  ];\n\n  for (const p of patterns) {\n    const m = name.match(p.re);\n    if (m && isLikelyFirstName(m[p.fi])) {\n      firstName = m[p.fi];\n      lastName = p.li ? (m[p.li] || null) : null;\n      // For pattern 6, reject if lastName is also a common first name\n      if (p.re.source.includes('Massage|Bodywork') && lastName && isLikelyFirstName(lastName)) continue;\n      break;\n    }\n  }\n\n  return firstName ? { firstName, lastName } : null;\n}\n\n// \u2550\u2550\u2550 CONTACT VALIDATION \u2550\u2550\u2550\n\nfunction validateAndCleanContact(contact) {\n  const flags = [];\n\n  function validateEmail(email, fieldName) {\n    if (!email) return null;\n    let cleaned = email.trim().toLowerCase();\n    if (!/^[a-zA-Z0-9._%+\\-]+@[a-zA-Z0-9.\\-]+\\.[a-zA-Z]{2,}$/.test(cleaned)) {\n      flags.push(`${fieldName}_invalid_format`); return null;\n    }\n    const junkPatterns = [/^noreply@/, /^no-reply@/, /^donotreply@/, /^test@/, /^admin@example\\./, /^sample@/, /^fake@/, /^placeholder@/, /^null@/, /^none@/, /^unknown@/, /^abuse@/, /^postmaster@/, /^mailer-daemon@/];\n    if (junkPatterns.some(p => p.test(cleaned))) { flags.push(`${fieldName}_junk`); return null; }\n    const rolePatterns = [/^info@/, /^contact@/, /^hello@/, /^support@/, /^sales@/, /^office@/, /^billing@/, /^reception@/, /^frontdesk@/, /^front\\.desk@/, /^appointments@/, /^booking@/, /^bookings@/, /^schedule@/, /^scheduling@/, /^inquiries@/, /^inquiry@/, /^general@/, /^team@/, /^staff@/];\n    if (rolePatterns.some(p => p.test(cleaned))) flags.push(`${fieldName}_role_based_kept`);\n    const junkDomains = ['example.com', 'example.org', 'test.com', 'localhost', 'mailinator.com', 'guerrillamail.com', 'tempmail.com', 'yopmail.com'];\n    const domain = cleaned.split('@')[1];\n    if (junkDomains.includes(domain)) { flags.push(`${fieldName}_junk_domain`); return null; }\n    const localPart = cleaned.split('@')[0];\n    if (/^\\d+$/.test(localPart)) { flags.push(`${fieldName}_numeric_local`); return null; }\n    return cleaned;\n  }\n\n  function validatePhone(phone, fieldName) {\n    if (!phone) return null;\n    if (typeof phone === 'object') phone = phone.sanitized_number || phone.raw_number || phone.number || '';\n    let cleaned = phone.toString().trim().replace(/[^\\d]/g, '');\n    if (!cleaned || cleaned.length === 0) return null;\n    if (cleaned.length === 11 && cleaned.startsWith('1')) { /* ok */ }\n    else if (cleaned.length === 10) cleaned = '1' + cleaned;\n    else if (cleaned.length < 10) { flags.push(`${fieldName}_too_short`); return null; }\n    else if (cleaned.length > 11 && cleaned.length <= 15) {\n      if (cleaned.startsWith('1')) return null;\n      return '+' + cleaned;\n    }\n    else if (cleaned.length > 15) return null;\n    const areaCode = cleaned.substring(1, 4);\n    if (areaCode.startsWith('0') || areaCode.startsWith('1')) return null;\n    return '+' + cleaned;\n  }\n\n  function cleanName(name, fieldName) {\n    if (!name) return null;\n    let cleaned = name.trim().replace(/\\*+$/, '').trim();\n    if (cleaned.length <= 1) return null;\n    if (/^\\d+$/.test(cleaned) || /\\d/.test(cleaned)) return null;\n    const junkNames = ['unknown', 'n/a', 'na', 'none', 'null', 'test', 'owner', 'manager', 'admin', 'info', 'contact'];\n    if (junkNames.includes(cleaned.toLowerCase())) return null;\n    const credentials = ['lmt', 'cmt', 'rmt', 'lmbt', 'lmp', 'bctmb', 'nctmb', 'nctm', 'cpt', 'cst', 'mld', 'nmt', 'amt', 'abmp'];\n    if (credentials.includes(cleaned.toLowerCase())) return null;\n    if (cleaned === cleaned.toUpperCase() || cleaned === cleaned.toLowerCase()) {\n      cleaned = cleaned.charAt(0).toUpperCase() + cleaned.slice(1).toLowerCase();\n    }\n    return cleaned;\n  }\n\n  contact.email_business = validateEmail(contact.email_business, 'email_business');\n  contact.email_personal = validateEmail(contact.email_personal, 'email_personal');\n  contact.phone_direct = validatePhone(contact.phone_direct, 'phone_direct');\n  contact.first_name = cleanName(contact.first_name, 'first_name');\n  contact.last_name = cleanName(contact.last_name, 'last_name');\n  if (!contact.first_name) flags.push('contact_has_no_valid_first_name');\n\n  if (contact.linkedin_url) {\n    if (!/linkedin\\.com\\/in\\//i.test(contact.linkedin_url)) contact.linkedin_url = null;\n    else if (!contact.linkedin_url.startsWith('http')) contact.linkedin_url = 'https://' + contact.linkedin_url;\n  }\n\n  if (contact.location) {\n    contact.location = contact.location.trim();\n    if (!contact.location || contact.location === ',' || contact.location.length < 2) contact.location = null;\n  }\n\n  return { contact, flags, hasValidContact: !!(contact.first_name) };\n}\n\n// \u2550\u2550\u2550 APOLLO ROLE SCORING \u2550\u2550\u2550\n\nconst ownerKeywords = ['owner', 'founder', 'ceo', 'proprietor', 'principal', 'co-founder'];\nconst managerKeywords = ['manager', 'director', 'general manager', 'gm', 'head'];\nconst practitionerKeywords = ['massage', 'therapist', 'lmt', 'cmt', 'rmt', 'bodywork', 'esthetician'];\n\n// \u2550\u2550\u2550 FETCH DATA FROM SUPABASE \u2550\u2550\u2550\n\n// 1. Fetch enriched companies for this metro\nconst companies = await this.helpers.httpRequest({\n  method: 'GET',\n  url: `${supabaseUrl}/rest/v1/companies?enrichment_status=in.(partially_enriched,fully_enriched)&discovery_metro=eq.${encodeURIComponent(metro)}&order=lead_score.desc,discovered_at.asc&limit=1000&select=id,name,phone,domain,address,city,state,country,google_place_id,category,estimated_size,has_website,google_review_count,google_rating`,\n  headers: sbHeaders,\n  json: true\n});\n\nif (!Array.isArray(companies) || companies.length === 0) {\n  console.log('No enriched companies found for metro: ' + metro);\n  return [{ json: { step: 'find_contacts', processed: 0, message: 'No companies to find contacts for' } }];\n}\n\n// 2. Fetch existing contacts (for dedup) \u2014 only company_id needed\nconst existingContacts = await this.helpers.httpRequest({\n  method: 'GET',\n  url: `${supabaseUrl}/rest/v1/contacts?select=company_id`,\n  headers: sbHeaders,\n  json: true\n});\n\nconst existingSet = new Set();\nif (Array.isArray(existingContacts)) {\n  for (const c of existingContacts) {\n    if (c.company_id) existingSet.add(c.company_id);\n  }\n}\n\n// 3. Filter to companies without contacts\nconst needsContacts = companies.filter(c => c.id && !existingSet.has(c.id));\n\nconsole.log(`Find Contacts: ${companies.length} companies total, ${existingSet.size} already have contacts, ${needsContacts.length} need people discovery for ${metro}`);\n\nif (needsContacts.length === 0) {\n  return [{ json: { step: 'find_contacts', processed: 0, message: 'All companies already have contacts' } }];\n}\n\n// \u2550\u2550\u2550 STATS \u2550\u2550\u2550\nconst stats = {\n  processed: 0, soloDetected: 0, soloWithName: 0,\n  apolloSearched: 0, apolloFound: 0, apolloEnriched: 0,\n  websiteScraped: 0, websiteFoundName: 0,\n  noDomainFallback: 0, noDomainFoundName: 0,\n  contactsInserted: 0, validationIssues: 0, errors: 0\n};\n\n// \u2550\u2550\u2550 MAIN LOOP \u2550\u2550\u2550\n\nlet apolloBatchCount = 0;\n\nfor (const company of needsContacts) {\n  try {\n    let contact = null;\n    let sourceMethod = 'none';\n\n    // \u2500\u2500 1. Solo practitioner check \u2500\u2500\n    const soloResult = checkSoloPractitioner(company);\n    if (soloResult.isSolo) {\n      stats.soloDetected++;\n      if (soloResult.firstName) {\n        stats.soloWithName++;\n        contact = {\n          company_id: company.id, first_name: soloResult.firstName, last_name: soloResult.lastName,\n          role: 'owner', is_owner: true, email_business: null, email_personal: null,\n          phone_direct: null, linkedin_url: null,\n          location: [company.city, company.state].filter(Boolean).join(', ') || null,\n          cultural_affinity: null, source: 'solo_detection'\n        };\n        sourceMethod = 'solo_detection';\n      }\n    }\n\n    // \u2500\u2500 2. Apollo search (if not solo, has domain, enabled) \u2500\u2500\n    if (!soloResult.isSolo && company.domain && !SKIP_APOLLO) {\n      try {\n        // Rate limiting: 3 per batch, 2s delay between batches\n        apolloBatchCount++;\n        if (apolloBatchCount > 3) {\n          await delay(2000);\n          apolloBatchCount = 1;\n        }\n\n        const apolloResp = await this.helpers.httpRequest({\n          method: 'POST',\n          url: 'https://api.apollo.io/api/v1/mixed_people/api_search',\n          headers: {\n            'Content-Type': 'application/json', 'Cache-Control': 'no-cache',\n            'X-Api-Key': apolloApiKey\n          },\n          body: {\n            q_organization_domains: company.domain,\n            person_titles: ['owner', 'founder', 'ceo', 'proprietor', 'director', 'manager', 'massage therapist', 'licensed massage therapist'],\n            per_page: 5\n          },\n          json: true\n        });\n\n        const people = apolloResp.people || [];\n        stats.apolloSearched++;\n\n        if (people.length > 0) {\n          stats.apolloFound++;\n\n          // Score people by role relevance\n          let bestPerson = null, bestScore = -1;\n          for (const person of people) {\n            const title = (person.title || '').toLowerCase();\n            let score = 0;\n            if (ownerKeywords.some(k => title.includes(k))) score = 10;\n            else if (managerKeywords.some(k => title.includes(k))) score = 5;\n            else if (practitionerKeywords.some(k => title.includes(k))) score = 3;\n            else score = 1;\n            if (person.has_email === true || person.has_email === 'true') score += 1;\n            if (score > bestScore) { bestScore = score; bestPerson = person; }\n          }\n\n          // Enrich if enabled\n          if (APOLLO_ENRICH_ENABLED && bestPerson.id) {\n            try {\n              const enrichResp = await this.helpers.httpRequest({\n                method: 'POST',\n                url: 'https://api.apollo.io/api/v1/people/match',\n                headers: {\n                  'Content-Type': 'application/json', 'Cache-Control': 'no-cache',\n                  'X-Api-Key': apolloApiKey\n                },\n                body: { id: bestPerson.id, reveal_personal_emails: true, reveal_phone_number: false },\n                json: true\n              });\n\n              const person = enrichResp.person || enrichResp.match || enrichResp;\n              if (person && person.first_name) {\n                const title = (person.title || '').toLowerCase();\n                let role = 'unknown', isOwner = false;\n                if (['owner','founder','ceo','proprietor','principal','co-founder'].some(k => title.includes(k))) { role = 'owner'; isOwner = true; }\n                else if (['manager','director','gm','general manager'].some(k => title.includes(k))) role = 'manager';\n                else if (['massage','therapist','lmt','cmt','rmt','esthetician'].some(k => title.includes(k))) role = 'practitioner';\n\n                let phoneNumber = null;\n                if (person.phone_numbers && person.phone_numbers.length > 0) {\n                  phoneNumber = person.phone_numbers[0].sanitized_number || person.phone_numbers[0].raw_number || null;\n                }\n\n                contact = {\n                  company_id: company.id, first_name: person.first_name || null,\n                  last_name: person.last_name || null, role, is_owner: isOwner,\n                  email_business: person.email || null,\n                  email_personal: (person.personal_emails && person.personal_emails[0]) || null,\n                  phone_direct: phoneNumber, linkedin_url: person.linkedin_url || null,\n                  location: [person.city, person.state].filter(Boolean).join(', ') || [company.city, company.state].filter(Boolean).join(', ') || null,\n                  cultural_affinity: null, source: 'apollo'\n                };\n                sourceMethod = 'apollo_enriched';\n                stats.apolloEnriched++;\n              } else {\n                // Enrichment returned no usable data \u2014 use search-only\n                contact = {\n                  company_id: company.id, first_name: bestPerson.first_name || null,\n                  last_name: null, role: (bestPerson.title || '').toLowerCase().includes('owner') ? 'owner' : 'unknown',\n                  is_owner: (bestPerson.title || '').toLowerCase().includes('owner'),\n                  email_business: null, email_personal: null, phone_direct: null, linkedin_url: null,\n                  location: [company.city, company.state].filter(Boolean).join(', ') || null,\n                  cultural_affinity: null, source: 'apollo'\n                };\n                sourceMethod = 'apollo_search_only';\n                stats.apolloEnriched++;\n              }\n            } catch(e) {\n              // Enrich failed \u2014 use search-only data\n              contact = {\n                company_id: company.id, first_name: bestPerson.first_name || null,\n                last_name: null, role: (bestPerson.title || '').toLowerCase().includes('owner') ? 'owner' : 'unknown',\n                is_owner: (bestPerson.title || '').toLowerCase().includes('owner'),\n                email_business: null, email_personal: null, phone_direct: null, linkedin_url: null,\n                location: [company.city, company.state].filter(Boolean).join(', ') || null,\n                cultural_affinity: null, source: 'apollo'\n              };\n              sourceMethod = 'apollo_search_only';\n              stats.apolloEnriched++;\n            }\n          } else {\n            // Enrichment disabled \u2014 use search-only\n            contact = {\n              company_id: company.id, first_name: bestPerson.first_name || null,\n              last_name: null, role: (bestPerson.title || '').toLowerCase().includes('owner') ? 'owner' : 'unknown',\n              is_owner: (bestPerson.title || '').toLowerCase().includes('owner'),\n              email_business: null, email_personal: null, phone_direct: null, linkedin_url: null,\n              location: [company.city, company.state].filter(Boolean).join(', ') || null,\n              cultural_affinity: null, source: 'apollo'\n            };\n            sourceMethod = 'apollo_search_only';\n            stats.apolloEnriched++;\n          }\n        } else {\n          // Apollo found nobody \u2014 try about page\n          if (company.domain && !SKIP_WEBSITE_SCRAPE) {\n            const additionalPaths = ['/about', '/about-us', '/about-me', '/our-team', '/team', '/our-story'];\n            let nameResult = null;\n            let usedPath = '';\n\n            for (const path of additionalPaths) {\n              try {\n                const resp = await this.helpers.httpRequest({\n                  method: 'GET',\n                  url: `https://${company.domain}${path}`,\n                  headers: { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36' },\n                  returnFullResponse: true, timeout: 10000, json: false,\n                });\n                const html = resp.body || '';\n                if (typeof html === 'string' && html.length > 500) {\n                  const found = extractNameFromHtml(html);\n                  if (found) { nameResult = found; usedPath = path; break; }\n                }\n              } catch(e) { /* Path doesn't exist or timed out */ }\n            }\n\n            stats.websiteScraped++;\n            if (nameResult) {\n              stats.websiteFoundName++;\n              contact = {\n                company_id: company.id, first_name: nameResult.firstName, last_name: nameResult.lastName,\n                role: 'owner', is_owner: true, email_business: null, email_personal: null,\n                phone_direct: null, linkedin_url: null,\n                location: [company.city, company.state].filter(Boolean).join(', ') || null,\n                cultural_affinity: null, source: 'website'\n              };\n              sourceMethod = 'website_scrape_' + usedPath.replace('/', '');\n            }\n          }\n        }\n      } catch(e) {\n        console.log(`Apollo error for ${company.name} (${company.domain}): ${e.message}`);\n      }\n    }\n\n    // \u2500\u2500 3. No domain fallback \u2014 extract name from business name \u2500\u2500\n    if (!contact && !company.domain) {\n      stats.noDomainFallback++;\n      const nameResult = extractNameFromBusinessName(company);\n      if (nameResult) {\n        stats.noDomainFoundName++;\n        contact = {\n          company_id: company.id, first_name: nameResult.firstName, last_name: nameResult.lastName,\n          role: 'owner', is_owner: true, email_business: null, email_personal: null,\n          phone_direct: null, linkedin_url: null,\n          location: [company.city, company.state].filter(Boolean).join(', ') || null,\n          cultural_affinity: null, source: 'manual'\n        };\n        sourceMethod = 'no_domain_name_extraction';\n      }\n    }\n\n    // \u2500\u2500 4. Validate & clean contact \u2500\u2500\n    if (contact) {\n      const { contact: cleanedContact, flags, hasValidContact } = validateAndCleanContact(contact);\n      if (flags.length > 0) stats.validationIssues++;\n\n      // \u2500\u2500 5. Insert to Supabase (with dedup) \u2500\u2500\n      if (hasValidContact) {\n        try {\n          await this.helpers.httpRequest({\n            method: 'POST',\n            url: `${supabaseUrl}/rest/v1/contacts?on_conflict=company_id,first_name,last_name,source`,\n            headers: { ...sbHeaders, 'Content-Type': 'application/json', 'Prefer': 'resolution=ignore-duplicates,return=minimal' },\n            body: cleanedContact,\n            json: true\n          });\n          stats.contactsInserted++;\n        } catch(e) {\n          console.log(`Contact insert error for ${company.name}: ${e.message}`);\n        }\n      }\n    }\n\n    stats.processed++;\n    if (stats.processed % 25 === 0) {\n      console.log(`  Progress: ${stats.processed}/${needsContacts.length} companies checked for contacts`);\n    }\n  } catch(e) {\n    console.log(`FATAL error finding contacts for ${company.name}: ${e.message}`);\n    stats.errors++;\n  }\n}\n\n// \u2550\u2550\u2550 SUMMARY \u2550\u2550\u2550\nconst summary = {\n  step: 'find_contacts',\n  metro,\n  run_completed_at: new Date().toISOString(),\n  companies_processed: stats.processed,\n  solo_detected: stats.soloDetected,\n  solo_with_name: stats.soloWithName,\n  apollo_searched: stats.apolloSearched,\n  apollo_found_people: stats.apolloFound,\n  apollo_contacts_created: stats.apolloEnriched,\n  website_scraped: stats.websiteScraped,\n  website_names_found: stats.websiteFoundName,\n  no_domain_fallback: stats.noDomainFallback,\n  no_domain_names_found: stats.noDomainFoundName,\n  contacts_inserted: stats.contactsInserted,\n  validation_issues: stats.validationIssues,\n  fatal_errors: stats.errors,\n  message: `Found contacts for ${stats.contactsInserted} of ${stats.processed} companies. Sources: ${stats.soloWithName} solo, ${stats.apolloEnriched} Apollo, ${stats.websiteFoundName} website, ${stats.noDomainFoundName} name extraction. Validation issues: ${stats.validationIssues}.`\n};\n\nconsole.log('=== STEP 3a: FIND CONTACTS SUMMARY ===');\nconsole.log(JSON.stringify(summary, null, 2));\n\nreturn [{ json: summary }];\n",
        "mode": "runOnceForAllItems"
      }
    },
    {
      "parameters": {
        "jsCode": "// Enrich Contacts \u2014 Modified to include inline Supabase fetch/merge\n// Mode: runOnceForAllItems\n// Input: trigger from Find Contacts\n// Output: enrichment results \u2192 Run Summary4\n//\n// Previously depended on: Step 4 Config, Fetch Contacts, Fetch Companies1,\n// Filter & Merge Contacts, Collapse to Single. Now handles all of that inline.\n\nconst metro = $('Metro Config').first().json.metro_name;\nconst supabaseUrl = $env.SUPABASE_URL;\nconst supabaseKey = $env.SUPABASE_SERVICE_KEY;\nconst sbHeaders = { 'apikey': supabaseKey, 'Authorization': 'Bearer ' + supabaseKey };\n\n// \u2550\u2550\u2550 CONFIG (previously in Step 4 Config Set node) \u2550\u2550\u2550\nconst config = {\n  skip_hunter: 'false',\n  skip_snovio: 'true',\n  skip_hunter_verifier: 'false',\n  skip_namsor: 'false',\n  skip_phone_verifier: 'false',\n  batch_size: '1000',\n  batch_offset: '0'\n};\n\n// \u2550\u2550\u2550 INLINE FETCH: Contacts needing enrichment \u2550\u2550\u2550\nconst rawContacts = await this.helpers.httpRequest({\n  method: 'GET',\n  url: `${supabaseUrl}/rest/v1/contacts?select=id,company_id,first_name,last_name,role,is_owner,email_business,email_personal,phone_direct,linkedin_url,cultural_affinity,source,email_status,phone_status,phone_line_type,phone_carrier&or=(email_status.is.null,email_status.eq.unverified,and(phone_direct.not.is.null,phone_status.is.null))&order=created_at.asc&limit=${config.batch_size}&offset=${config.batch_offset}`,\n  headers: sbHeaders,\n  json: true\n});\n\n// \u2550\u2550\u2550 INLINE FETCH: Companies for this metro \u2550\u2550\u2550\nconst rawCompanies = await this.helpers.httpRequest({\n  method: 'GET',\n  url: `${supabaseUrl}/rest/v1/companies?select=id,name,phone,domain,email,email_status,phone_status,phone_line_type,city,state&enrichment_status=in.(partially_enriched,fully_enriched)&discovery_metro=eq.${encodeURIComponent(metro)}`,\n  headers: sbHeaders,\n  json: true\n});\n\n// \u2550\u2550\u2550 INLINE: Filter & Merge Contacts \u2550\u2550\u2550\n// Deduplicate contacts by id\nconst seenIds = new Set();\nlet uniqueContacts = [];\nif (Array.isArray(rawContacts)) {\n  for (const c of rawContacts) {\n    if (c.id && !seenIds.has(c.id)) {\n      seenIds.add(c.id);\n      uniqueContacts.push(c);\n    }\n  }\n}\n\n// Build company lookup map (metro-scoped)\nconst companyMap = {};\nif (Array.isArray(rawCompanies)) {\n  for (const co of rawCompanies) {\n    if (co.id) companyMap[co.id] = co;\n  }\n}\n\n// Filter contacts that need enrichment\nconst needsEnrichment = uniqueContacts.filter(c => {\n  const missingEmail = !c.email_business;\n  const missingCulturalAffinity = !c.cultural_affinity;\n  const missingPhone = !c.phone_direct;\n  const missingLinkedin = !c.linkedin_url;\n  const verifiedStatuses = ['verified', 'invalid', 'risky', 'accept_all'];\n  const emailNeedsVerification = c.email_business && !verifiedStatuses.includes(c.email_status);\n  const phoneNeedsVerification = c.phone_direct && !c.phone_status;\n  return missingEmail || missingCulturalAffinity || missingPhone || missingLinkedin || emailNeedsVerification || phoneNeedsVerification;\n});\n\n// Metro filter: only keep contacts whose company is in the metro-scoped companyMap\nconst metroFiltered = needsEnrichment.filter(c => companyMap[c.company_id]);\nconst crossMetroSkipped = needsEnrichment.length - metroFiltered.length;\n\nconsole.log(`Contacts: ${uniqueContacts.length} unique, ${needsEnrichment.length} need enrichment, ${crossMetroSkipped} skipped (other metro), ${metroFiltered.length} in current metro`);\n\nif (metroFiltered.length === 0) {\n  return [{ json: { _empty: true, _count: 0, _message: 'All contacts are already enriched or belong to other metros' } }];\n}\n\n// Merge company data into each contact\nconst contacts = metroFiltered.map(c => {\n  const company = companyMap[c.company_id];\n  return {\n    json: {\n      ...c,\n      _company_name: company.name || null,\n      _company_domain: company.domain || null,\n      _company_phone: company.phone || null,\n      _company_email: company.email || null,\n      _company_email_status: company.email_status || null,\n      _company_phone_status: company.phone_status || null,\n      _company_phone_line_type: company.phone_line_type || null,\n      _company_city: company.city || null,\n      _company_state: company.state || null\n    }\n  };\n});\n\n// \u2550\u2550\u2550 ENRICHMENT PIPELINE (unchanged from original Enrich Contacts node) \u2550\u2550\u2550\n\nconst results = [];\n\n// Helper: delay between API calls for rate limiting\nconst delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));\n\n// Dedup guard: track companies that already had email set/verified this execution\nconst staticData = $getWorkflowStaticData('global');\nif (!staticData._companyEmailsSet) staticData._companyEmailsSet = {};\nconst companyEmailsSet = staticData._companyEmailsSet;\n\n// BUG-F019 FIX: Clear ALL stale keys from previous executions.\nfor (const key of Object.keys(companyEmailsSet)) {\n  delete companyEmailsSet[key];\n}\n\n// Phone validation (from Prepare Contact Update)\nfunction validatePhone(phone) {\n  if (!phone) return null;\n  if (typeof phone === 'object' && phone !== null) {\n    phone = phone.sanitized_number || phone.raw_number || phone.number || '';\n  }\n  let cleaned = phone.toString().trim().replace(/[^\\d]/g, '');\n  if (!cleaned || cleaned.length === 0) return null;\n  if (cleaned.length === 11 && cleaned.startsWith('1')) { /* ok */ }\n  else if (cleaned.length === 10) { cleaned = '1' + cleaned; }\n  else if (cleaned.length < 10) { return null; }\n  else if (cleaned.length > 11 && cleaned.length <= 15) {\n    if (cleaned.startsWith('1')) return null;\n    return '+' + cleaned;\n  }\n  else if (cleaned.length > 15) { return null; }\n  const areaCode = cleaned.substring(1, 4);\n  if (areaCode.startsWith('0') || areaCode.startsWith('1')) return null;\n  return '+' + cleaned;\n}\n\n// Role-based email detection\nconst rolePatterns = [\n  /^info@/i, /^contact@/i, /^hello@/i, /^support@/i, /^sales@/i,\n  /^office@/i, /^billing@/i, /^reception@/i, /^frontdesk@/i, /^front\\.desk@/i,\n  /^appointments@/i, /^booking@/i, /^bookings@/i, /^schedule@/i, /^scheduling@/i,\n  /^inquiries@/i, /^inquiry@/i, /^general@/i, /^team@/i, /^staff@/i\n];\n\nfunction isRoleBased(email) {\n  if (!email) return false;\n  return rolePatterns.some(p => p.test(email));\n}\n\nconst freeWebmailDomains = [\n  'gmail.com', 'yahoo.com', 'outlook.com', 'hotmail.com', 'aol.com',\n  'icloud.com', 'me.com', 'mac.com', 'live.com', 'msn.com',\n  'protonmail.com', 'proton.me', 'zoho.com', 'yandex.com',\n  'mail.com', 'gmx.com', 'fastmail.com', 'tutanota.com'\n];\n\nfunction isFreeWebmail(email) {\n  if (!email) return false;\n  const domain = email.split('@')[1];\n  return freeWebmailDomains.includes(domain);\n}\n\n// Helper: verify an email via Hunter Verifier API\nasync function verifyEmail(email) {\n  try {\n    const verifyUrl = `https://api.hunter.io/v2/email-verifier?email=${encodeURIComponent(email)}&api_key=${$env.HUNTER_API_KEY}`;\n    const verifyResp = await this.helpers.httpRequest({ method: 'GET', url: verifyUrl, headers: { 'Accept': 'application/json' }, json: true });\n    const vBody = verifyResp.data || verifyResp;\n    if (vBody && vBody.status) {\n      let status;\n      switch (vBody.status) {\n        case 'valid': status = 'verified'; break;\n        case 'invalid': status = 'invalid'; break;\n        case 'accept_all': status = 'accept_all'; break;\n        case 'disposable': status = 'invalid'; break;\n        case 'webmail': status = 'verified'; break;\n        default: status = 'risky'; break;\n      }\n      return { status, score: vBody.score || null, verified_at: new Date().toISOString() };\n    }\n  } catch(e) {\n    console.log(`Verifier error for ${email}: ${e.message}`);\n  }\n  return null;\n}\n\n// Helper: verify a phone number via Telnyx Number Lookup API\nasync function verifyPhone(phoneNumber) {\n  try {\n    const resp = await this.helpers.httpRequest({\n      method: 'GET',\n      url: `https://api.telnyx.com/v2/number_lookup/${encodeURIComponent(phoneNumber)}?type=carrier`,\n      headers: {\n        'Authorization': `Bearer ${$env.TELNYX_API_KEY}`,\n        'Accept': 'application/json'\n      },\n      json: true\n    });\n    const data = resp.data || resp;\n    if (data && data.valid === false) {\n      return { phone_status: 'invalid', phone_line_type: null, phone_carrier: null };\n    }\n    let lineType = null;\n    const carrierType = (data.carrier && data.carrier.type) || null;\n    if (carrierType) {\n      const typeMap = { 'mobile': 'mobile', 'landline': 'landline', 'fixed line': 'landline', 'voip': 'voip', 'toll free': 'toll_free', 'toll_free': 'toll_free' };\n      lineType = typeMap[carrierType.toLowerCase()] || null;\n    }\n    const carrierName = (data.carrier && data.carrier.name) || null;\n    const phoneStatus = lineType === 'voip' ? 'voip' : 'valid';\n    return {\n      phone_status: phoneStatus,\n      phone_line_type: lineType,\n      phone_carrier: carrierName\n    };\n  } catch(e) {\n    if (e.statusCode === 404 || e.statusCode === 422) {\n      return { phone_status: 'invalid', phone_line_type: null, phone_carrier: null };\n    }\n    console.log(`Telnyx error for ${phoneNumber}: ${e.message} (status: ${e.statusCode || 'unknown'})`);\n    return { phone_status: null, phone_line_type: null, phone_carrier: null, _error: `${e.statusCode || 'unknown'}: ${e.message}` };\n  }\n}\n\nfor (const item of contacts) {\n  const contact = { ...item.json };\n\n  // Initialize enrichment fields\n  contact._hunter_email = null;\n  contact._hunter_score = 0;\n  contact._hunter_linkedin = null;\n  contact._hunter_phone = null;\n  contact._snovio_email = null;\n  contact._email_source = null;\n  contact._best_email = contact.email_business || null;\n  contact._best_phone = contact.phone_direct || contact._company_phone || null;\n  contact._best_linkedin = contact.linkedin_url || null;\n  contact._email_status = null;\n  contact._email_verified_at = null;\n  contact._verifier_score = null;\n  contact._cultural_affinity = contact.cultural_affinity || null;\n  contact._namsor_country = null;\n  contact._namsor_region = null;\n  contact._namsor_probability = null;\n  contact._company_email_routed = false;\n  contact._company_email_verified = false;\n  contact._phone_status = null;\n  contact._phone_line_type = null;\n  contact._phone_carrier = null;\n  contact._company_phone_verified = false;\n  contact._phone_error = null;\n\n  const needsEmail = !contact.email_business;\n  const hasDomainAndName = contact._company_domain && contact.first_name;\n  const verifiedStatuses = ['verified', 'invalid', 'risky', 'accept_all'];\n  const emailNeedsVerification = contact.email_business && !verifiedStatuses.includes(contact.email_status);\n\n  // EMAIL WATERFALL\n\n  if (needsEmail && hasDomainAndName) {\n    // --- HUNTER EMAIL FINDER ---\n    if (config.skip_hunter !== 'true') {\n      try {\n        const hunterUrl = `https://api.hunter.io/v2/email-finder?domain=${encodeURIComponent(contact._company_domain)}&first_name=${encodeURIComponent(contact.first_name)}&last_name=${encodeURIComponent(contact.last_name || '')}&api_key=${$env.HUNTER_API_KEY}`;\n        const hunterResp = await this.helpers.httpRequest({ method: 'GET', url: hunterUrl, headers: { 'Accept': 'application/json' }, json: true });\n        const hData = hunterResp.data || hunterResp;\n        if (hData && hData.email && (hData.score === undefined || hData.score >= 50)) {\n          contact._hunter_email = hData.email;\n          contact._hunter_score = hData.score || 0;\n          contact._hunter_linkedin = hData.linkedin_url || null;\n          contact._hunter_phone = hData.phone_number || null;\n          contact._email_source = 'hunter';\n        }\n        await delay(200);\n      } catch(e) {\n        console.log(`Hunter error for ${contact.first_name}: ${e.message}`);\n      }\n    }\n\n    // --- SNOV.IO EMAIL FINDER (fallback) ---\n    if (!contact._hunter_email && config.skip_snovio !== 'true') {\n      try {\n        const snovResp = await this.helpers.httpRequest({\n          method: 'POST',\n          url: 'https://api.snov.io/v1/get-emails-from-names',\n          headers: { 'Content-Type': 'application/json' },\n          body: {\n            firstName: contact.first_name,\n            lastName: contact.last_name || '',\n            domain: contact._company_domain\n          },\n          json: true\n        });\n        const emails = snovResp.emails || snovResp.data?.emails || [];\n        if (Array.isArray(emails) && emails.length > 0) {\n          const valid = emails.find(e => e.emailStatus === 'valid' || e.status === 'valid') || emails[0];\n          contact._snovio_email = valid.email || valid.value || null;\n          if (contact._snovio_email) contact._email_source = 'snovio';\n        }\n        await delay(500);\n      } catch(e) {\n        console.log(`Snov.io error for ${contact.first_name}: ${e.message}`);\n      }\n    }\n\n    contact._best_email = contact._hunter_email || contact._snovio_email || null;\n    contact._best_phone = contact.phone_direct || contact._hunter_phone || contact._company_phone || null;\n    contact._best_linkedin = contact.linkedin_url || contact._hunter_linkedin || null;\n  } else if (contact.email_business) {\n    contact._best_email = contact.email_business;\n    contact._email_source = 'existing';\n  }\n\n  // COMPANY EMAIL ROUTING\n  if (contact._best_email && isRoleBased(contact._best_email) && !isFreeWebmail(contact._best_email)) {\n    const companyId = contact.company_id;\n    const companyHasEmail = !!(contact._company_email);\n\n    if (!companyHasEmail && !companyEmailsSet[companyId]) {\n      contact._routed_company_email = contact._best_email;\n      contact._company_email_routed = true;\n      companyEmailsSet[companyId] = contact._best_email;\n      console.log(`Routed role-based email ${contact._best_email} to company ${contact._company_name || companyId}`);\n    }\n\n    if (contact.email_personal) {\n      contact._best_email = contact.email_personal;\n      contact._email_source = 'personal_promoted';\n      console.log(`Promoted personal email ${contact.email_personal} for ${contact.first_name} (role-based went to company)`);\n    }\n  }\n\n  // EMAIL VERIFICATION (contact email)\n  if (contact._best_email && config.skip_hunter_verifier !== 'true') {\n    const shouldVerify = !contact.email_business || emailNeedsVerification || contact._email_source === 'hunter' || contact._email_source === 'snovio' || contact._email_source === 'personal_promoted';\n    if (shouldVerify) {\n      const vResult = await verifyEmail.call(this, contact._best_email);\n      if (vResult) {\n        contact._email_status = vResult.status;\n        contact._email_verified_at = vResult.verified_at;\n        contact._verifier_score = vResult.score;\n      }\n      await delay(700);\n    }\n  } else if (contact._best_email) {\n    contact._email_status = 'unverified';\n  }\n\n  // COMPANY EMAIL VERIFICATION\n  const companyEmailToVerify = contact._routed_company_email || contact._company_email;\n  const companyEmailNeedsVerification = companyEmailToVerify && !contact._company_email_status;\n  const companyId = contact.company_id;\n\n  if (companyEmailNeedsVerification && config.skip_hunter_verifier !== 'true' && !companyEmailsSet[companyId + '_verified']) {\n    const vResult = await verifyEmail.call(this, companyEmailToVerify);\n    let companyPatch = {};\n\n    if (contact._routed_company_email) {\n      companyPatch.email = contact._routed_company_email;\n    }\n\n    if (vResult) {\n      companyPatch.email_status = vResult.status;\n      contact._company_email_verified = true;\n      console.log(`Verified company email ${companyEmailToVerify}: ${vResult.status}`);\n    }\n\n    if (Object.keys(companyPatch).length > 0) {\n      try {\n        await this.helpers.httpRequest({\n          method: 'PATCH',\n          url: `${supabaseUrl}/rest/v1/companies?id=eq.${companyId}`,\n          headers: {\n            'apikey': supabaseKey,\n            'Authorization': `Bearer ${supabaseKey}`,\n            'Content-Type': 'application/json',\n            'Prefer': 'return=minimal'\n          },\n          body: companyPatch,\n          json: true\n        });\n        console.log(`PATCHed company ${contact._company_name || companyId}: ${JSON.stringify(companyPatch)}`);\n      } catch(e) {\n        console.log(`Company PATCH error for ${companyId}: ${e.message}`);\n      }\n    }\n\n    companyEmailsSet[companyId + '_verified'] = true;\n    await delay(700);\n  } else if (contact._routed_company_email && !companyEmailsSet[companyId + '_verified']) {\n    try {\n      await this.helpers.httpRequest({\n        method: 'PATCH',\n        url: `${supabaseUrl}/rest/v1/companies?id=eq.${companyId}`,\n        headers: {\n          'apikey': supabaseKey,\n          'Authorization': `Bearer ${supabaseKey}`,\n          'Content-Type': 'application/json',\n          'Prefer': 'return=minimal'\n        },\n        body: { email: contact._routed_company_email },\n        json: true\n      });\n      console.log(`PATCHed company email (unverified) ${contact._company_name || companyId}: ${contact._routed_company_email}`);\n    } catch(e) {\n      console.log(`Company PATCH error for ${companyId}: ${e.message}`);\n    }\n    companyEmailsSet[companyId + '_verified'] = true;\n    await delay(50);\n  }\n\n  // NAMSOR CULTURAL AFFINITY\n  if (!contact.cultural_affinity && contact.first_name && (contact.last_name || '').length > 0 && config.skip_namsor !== 'true') {\n    try {\n      const namsorUrl = `https://v2.namsor.com/NamSorAPIv2/api2/json/origin/${encodeURIComponent(contact.first_name)}/${encodeURIComponent(contact.last_name || 'Unknown')}`;\n      const namsorResp = await this.helpers.httpRequest({ method: 'GET', url: namsorUrl, headers: { 'X-API-KEY': $env.NAMSOR_API_KEY, 'Accept': 'application/json' }, json: true });\n      if (namsorResp && namsorResp.countryOrigin) {\n        const parts = [];\n        if (namsorResp.regionOrigin) parts.push(namsorResp.regionOrigin);\n        if (namsorResp.subRegionOrigin && namsorResp.subRegionOrigin !== namsorResp.regionOrigin) parts.push(namsorResp.subRegionOrigin);\n        if (namsorResp.countryOrigin) parts.push(namsorResp.countryOrigin);\n        contact._cultural_affinity = parts.join(' / ');\n        if (namsorResp.probabilityCalibrated && namsorResp.probabilityCalibrated < 0.3) {\n          contact._cultural_affinity += ' (low confidence)';\n        }\n        contact._namsor_country = namsorResp.countryOrigin;\n        contact._namsor_region = namsorResp.regionOrigin;\n        contact._namsor_probability = namsorResp.probabilityCalibrated;\n      }\n      await delay(100);\n    } catch(e) {\n      console.log(`NamSor error for ${contact.first_name}: ${e.message}`);\n    }\n  }\n\n  // PHONE VERIFICATION (Telnyx Number Lookup)\n  if (contact._best_phone && !contact.phone_status && config.skip_phone_verifier !== 'true') {\n    const phoneResult = await verifyPhone.call(this, contact._best_phone);\n    if (phoneResult) {\n      contact._phone_status = phoneResult.phone_status;\n      contact._phone_line_type = phoneResult.phone_line_type;\n      contact._phone_carrier = phoneResult.phone_carrier;\n      if (phoneResult._error) {\n        contact._phone_error = phoneResult._error;\n      } else {\n        console.log(`Phone verified ${contact._best_phone}: ${phoneResult.phone_status} (${phoneResult.phone_line_type || 'unknown type'}, ${phoneResult.phone_carrier || 'unknown carrier'})`);\n      }\n    }\n    await delay(100);\n  }\n\n  // COMPANY PHONE VERIFICATION (Telnyx)\n  if (contact._company_phone && !contact._company_phone_status && config.skip_phone_verifier !== 'true' && !companyEmailsSet[companyId + '_phone_verified']) {\n    const compPhoneResult = await verifyPhone.call(this, contact._company_phone);\n    if (compPhoneResult && !compPhoneResult._error) {\n      try {\n        await this.helpers.httpRequest({\n          method: 'PATCH',\n          url: `${supabaseUrl}/rest/v1/companies?id=eq.${companyId}`,\n          headers: {\n            'apikey': supabaseKey,\n            'Authorization': `Bearer ${supabaseKey}`,\n            'Content-Type': 'application/json',\n            'Prefer': 'return=minimal'\n          },\n          body: {\n            phone_status: compPhoneResult.phone_status,\n            phone_line_type: compPhoneResult.phone_line_type\n          },\n          json: true\n        });\n        contact._company_phone_verified = true;\n        console.log(`Company phone verified ${contact._company_phone}: ${compPhoneResult.phone_status} (${compPhoneResult.phone_line_type || 'unknown'})`);\n      } catch(e) {\n        console.log(`Company phone PATCH error for ${companyId}: ${e.message}`);\n      }\n    } else if (compPhoneResult && compPhoneResult._error) {\n      contact._phone_error = contact._phone_error || compPhoneResult._error;\n    }\n    companyEmailsSet[companyId + '_phone_verified'] = true;\n    await delay(100);\n  }\n\n  // BUILD UPDATE PAYLOAD\n  const update = {};\n  if (contact._best_email && !contact.email_business) {\n    update.email_business = contact._best_email;\n  }\n  if (contact._email_status && contact._email_status !== 'unverified') {\n    update.email_status = contact._email_status;\n    update.email_verified_at = contact._email_verified_at;\n    if (contact._email_status === 'invalid') {\n      update.email_business = null;\n    }\n  } else if (contact._best_email || contact.email_business) {\n    update.email_status = 'unverified';\n  }\n\n  const newPhone = validatePhone(contact._best_phone);\n  if (newPhone && !contact.phone_direct) update.phone_direct = newPhone;\n  if (contact._best_linkedin && !contact.linkedin_url) update.linkedin_url = contact._best_linkedin;\n  if (contact._cultural_affinity && !contact.cultural_affinity) update.cultural_affinity = contact._cultural_affinity;\n\n  // Phone verification fields\n  if (contact._phone_status) {\n    update.phone_status = contact._phone_status;\n    update.phone_verified_at = new Date().toISOString();\n    update.phone_line_type = contact._phone_line_type;\n    update.phone_carrier = contact._phone_carrier;\n    if (contact._phone_status === 'invalid' || contact._phone_status === 'disconnected') {\n      update.phone_direct = null;\n    }\n  }\n\n  contact._update_payload = Object.keys(update).length > 0 ? update : null;\n  contact._has_updates = Object.keys(update).length > 0;\n\n  // SUPABASE UPDATE (inline)\n  if (contact._has_updates) {\n    try {\n      await this.helpers.httpRequest({\n        method: 'PATCH',\n        url: `${supabaseUrl}/rest/v1/contacts?id=eq.${contact.id}`,\n        headers: {\n          'apikey': supabaseKey,\n          'Authorization': `Bearer ${supabaseKey}`,\n          'Content-Type': 'application/json',\n          'Prefer': 'return=minimal'\n        },\n        body: update,\n        json: true\n      });\n      console.log(`Updated ${contact.first_name} ${contact.last_name || ''}: ${JSON.stringify(update)}`);\n    } catch(e) {\n      console.log(`Supabase update error for ${contact.id}: ${e.message}`);\n      contact._update_error = e.message;\n    }\n    await delay(50);\n  }\n\n  results.push({\n    json: {\n      _contact_id: contact.id,\n      _company_id: contact.company_id,\n      _first_name: contact.first_name,\n      _last_name: contact.last_name,\n      _company_name: contact._company_name,\n      _update_payload: contact._update_payload,\n      _has_updates: contact._has_updates,\n      _email_source: contact._email_source,\n      _email_status: contact._email_status,\n      _verifier_score: contact._verifier_score,\n      _namsor_country: contact._namsor_country,\n      _namsor_probability: contact._namsor_probability,\n      _company_email_routed: contact._company_email_routed,\n      _company_email_verified: contact._company_email_verified,\n      _routed_company_email: contact._routed_company_email || null,\n      _phone_status: contact._phone_status,\n      _phone_line_type: contact._phone_line_type,\n      _phone_carrier: contact._phone_carrier,\n      _company_phone_verified: contact._company_phone_verified,\n      _phone_error: contact._phone_error,\n      _update_error: contact._update_error || null\n    }\n  });\n}\n\nif (results.length === 0) {\n  return [{ json: { _empty: true, _count: 0 } }];\n}\n\nreturn results;\n"
      },
      "id": "aec203c3-be0e-40bb-9ada-7d85d644ab16",
      "name": "Enrich Contacts",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -6100,
        192
      ],
      "notes": "Replaces the entire Step 4 branching pipeline (31 nodes) with a single sequential loop.\nFor each contact: Hunter Email Finder \u2192 Snov.io fallback \u2192 Hunter Email Verifier \u2192 NamSor Origin \u2192 Supabase PATCH.\nAll API calls happen inline via $http.request(). No convergence = no batching bugs.\nConfig toggles (skip_hunter, skip_snovio, etc.) are checked inside the loop."
    },
    {
      "parameters": {
        "jsCode": "// Run Summary4 \u2014 Modified to use embedded config instead of $('Step 4 Config')\n// Mode: runOnceForAllItems\n// Input: enrichment results from Enrich Contacts\n// Output: summary \u2192 Calculate Lead Scores\n\n// Embedded config (previously from Step 4 Config Set node)\nconst config = {\n  skip_hunter: 'false',\n  skip_snovio: 'true',\n  skip_hunter_verifier: 'false',\n  skip_namsor: 'false',\n  skip_phone_verifier: 'false',\n  batch_size: '1000',\n  batch_offset: '0'\n};\n\nconst items = $input.all();\n\nlet totalProcessed = 0;\nlet emailsFound = 0;\nlet emailsFromHunter = 0;\nlet emailsFromSnovio = 0;\nlet emailsExisting = 0;\nlet emailsPersonalPromoted = 0;\nlet phonesEnriched = 0;\nlet linkedinEnriched = 0;\nlet namsorProcessed = 0;\nlet namsorSuccess = 0;\nlet contactsUpdated = 0;\nlet contactsSkipped = 0;\n\nlet emailsVerified = 0;\nlet emailsInvalid = 0;\nlet emailsRisky = 0;\nlet emailsAcceptAll = 0;\nlet emailsUnverified = 0;\nlet verificationTotal = 0;\nlet updateErrors = 0;\n\n// Company email routing stats\nlet companyEmailsRouted = 0;\nlet companyEmailsVerified = 0;\n\n// Phone verification stats\nlet phonesVerifiedValid = 0;\nlet phonesInvalidRemoved = 0;\nlet phonesVoipFlagged = 0;\nlet phonesDisconnectedRemoved = 0;\nlet companyPhonesVerified = 0;\n\nfor (const item of items) {\n  const d = item.json;\n  if (d._empty) continue;\n  totalProcessed++;\n\n  if (d._has_updates) contactsUpdated++;\n  else contactsSkipped++;\n\n  if (d._email_source === 'hunter') emailsFromHunter++;\n  else if (d._email_source === 'snovio') emailsFromSnovio++;\n  else if (d._email_source === 'existing') emailsExisting++;\n  else if (d._email_source === 'personal_promoted') emailsPersonalPromoted++;\n\n  if (d._update_payload && d._update_payload.email_business) emailsFound++;\n  if (d._update_payload && d._update_payload.phone_direct) phonesEnriched++;\n  if (d._update_payload && d._update_payload.linkedin_url) linkedinEnriched++;\n  if (d._namsor_country) namsorProcessed++;\n  if (d._namsor_country && d._update_payload && d._update_payload.cultural_affinity) namsorSuccess++;\n\n  if (d._email_status) {\n    verificationTotal++;\n    switch (d._email_status) {\n      case 'verified': emailsVerified++; break;\n      case 'invalid': emailsInvalid++; break;\n      case 'risky': emailsRisky++; break;\n      case 'accept_all': emailsAcceptAll++; break;\n      case 'unverified': emailsUnverified++; break;\n    }\n  }\n\n  if (d._company_email_routed) companyEmailsRouted++;\n  if (d._company_email_verified) companyEmailsVerified++;\n  if (d._update_error) updateErrors++;\n\n  // Phone verification stats\n  if (d._phone_status) {\n    switch (d._phone_status) {\n      case 'valid': phonesVerifiedValid++; break;\n      case 'invalid': phonesInvalidRemoved++; break;\n      case 'voip': phonesVoipFlagged++; break;\n      case 'disconnected': phonesDisconnectedRemoved++; break;\n    }\n  }\n  if (d._company_phone_verified) companyPhonesVerified++;\n}\n\nconst summary = {\n  run_completed_at: new Date().toISOString(),\n  config: {\n    batch_size: config.batch_size,\n    hunter_finder_enabled: config.skip_hunter !== 'true',\n    hunter_verifier_enabled: config.skip_hunter_verifier !== 'true',\n    snovio_enabled: config.skip_snovio !== 'true',\n    namsor_enabled: config.skip_namsor !== 'true',\n    phone_verifier_enabled: config.skip_phone_verifier !== 'true'\n  },\n  contacts_processed: totalProcessed,\n  contacts_updated: contactsUpdated,\n  contacts_no_changes: contactsSkipped,\n  update_errors: updateErrors,\n  email_enrichment: {\n    new_emails_found: emailsFound,\n    from_hunter: emailsFromHunter,\n    from_snovio: emailsFromSnovio,\n    personal_promoted: emailsPersonalPromoted,\n    already_had_email: emailsExisting\n  },\n  email_verification: {\n    total_checked: verificationTotal,\n    verified: emailsVerified,\n    invalid_removed: emailsInvalid,\n    risky: emailsRisky,\n    accept_all: emailsAcceptAll,\n    not_verified: emailsUnverified\n  },\n  company_email_routing: {\n    role_based_routed_to_company: companyEmailsRouted,\n    company_emails_verified: companyEmailsVerified\n  },\n  phone_verification: {\n    verified_valid: phonesVerifiedValid,\n    invalid_removed: phonesInvalidRemoved,\n    voip_flagged: phonesVoipFlagged,\n    disconnected_removed: phonesDisconnectedRemoved,\n    company_phones_verified: companyPhonesVerified\n  },\n  phone_enrichment: { phones_added: phonesEnriched },\n  linkedin_enrichment: { linkedin_added: linkedinEnriched },\n  namsor_enrichment: { names_sent: namsorProcessed, cultural_affinity_set: namsorSuccess },\n  message: `Processed ${totalProcessed} contacts. Updated ${contactsUpdated} (${emailsFound} emails, ${phonesEnriched} phones, ${linkedinEnriched} LinkedIn, ${namsorSuccess} cultural affinity). Email verification: ${emailsVerified} valid, ${emailsInvalid} invalid, ${emailsRisky} risky, ${emailsAcceptAll} accept_all. Phone verification: ${phonesVerifiedValid} valid, ${phonesInvalidRemoved} invalid removed, ${phonesVoipFlagged} voip, ${phonesDisconnectedRemoved} disconnected removed, ${companyPhonesVerified} company phones. Company emails: ${companyEmailsRouted} routed, ${companyEmailsVerified} verified. ${contactsSkipped} no changes. ${updateErrors} errors.`\n};\n\nconsole.log('=== STEP 4: ENRICH PEOPLE SUMMARY ===');\nconsole.log(JSON.stringify(summary, null, 2));\n\nreturn [{ json: summary }];\n"
      },
      "id": "fca629db-4e74-42e6-9fc0-e652ba284137",
      "name": "Run Summary4",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -5600,
        192
      ],
      "notes": "Final summary: contacts enriched, emails found (Hunter/Snov.io), verification stats, NamSor stats, update counts."
    }
  ],
  "connections": {
    "Split Search Queries": {
      "main": [
        [
          {
            "node": "Google Places - Text Search",
            "type": "main",
            "index": 0
          },
          {
            "node": "Start Apify Run",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Google Places - Text Search": {
      "main": [
        [
          {
            "node": "Normalize Google Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Normalize Google Results": {
      "main": [
        [
          {
            "node": "Merge All Sources",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge All Sources": {
      "main": [
        [
          {
            "node": "Deduplicate Records",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Deduplicate Records": {
      "main": [
        [
          {
            "node": "Prepare for Supabase",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare for Supabase": {
      "main": [
        [
          {
            "node": "Fuzzy Match?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fuzzy Match?": {
      "main": [
        [
          {
            "node": "Insert Flagged (Needs Review)",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Insert to Supabase",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Run ID": {
      "main": [
        [
          {
            "node": "Wait 30s",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Wait 30s": {
      "main": [
        [
          {
            "node": "Check Run Status",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Run Status": {
      "main": [
        [
          {
            "node": "Parse Status",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Status": {
      "main": [
        [
          {
            "node": "Run Succeeded?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Run Succeeded?": {
      "main": [
        [
          {
            "node": "Fetch Apify Results",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Wait 30s",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Start Apify Run": {
      "main": [
        [
          {
            "node": "Extract Run ID",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Normalize Yelp Results": {
      "main": [
        [
          {
            "node": "Merge All Sources",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Fetch Apify Results": {
      "main": [
        [
          {
            "node": "Normalize Yelp Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Enrich Contacts": {
      "main": [
        [
          {
            "node": "Run Summary4",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Run Summary4": {
      "main": [
        [
          {
            "node": "Calculate Lead Scores",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Calculate Lead Scores": {
      "main": [
        [
          {
            "node": "Run Summary5",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Webhook": {
      "main": [
        [
          {
            "node": "Metro Config",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Metro Config": {
      "main": [
        [
          {
            "node": "Split Search Queries",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Insert to Supabase": {
      "main": [
        [
          {
            "node": "Collapse to Single2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Insert Flagged (Needs Review)": {
      "main": [
        [
          {
            "node": "Collapse to Single2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Collapse to Single2": {
      "main": [
        [
          {
            "node": "Run Summary",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Run Summary": {
      "main": [
        [
          {
            "node": "Enrich Companies",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Enrich Companies": {
      "main": [
        [
          {
            "node": "Find Contacts",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Find Contacts": {
      "main": [
        [
          {
            "node": "Enrich Contacts",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  }
}